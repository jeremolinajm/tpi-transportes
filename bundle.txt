==================================================
RUTH: .env.example
==================================================
# ==================== DATABASE CONFIGURATION ====================
# Clients Database
CLIENTS_DB_NAME=clients_db
CLIENTS_DB_USER=clients_user
CLIENTS_DB_PASSWORD=clients_pass
CLIENTS_DB_PORT=5432

# Logistics Database
LOGISTICS_DB_NAME=logistics_db
LOGISTICS_DB_USER=logistics_user
LOGISTICS_DB_PASSWORD=logistics_pass
LOGISTICS_DB_PORT=5433

# Billing Database
BILLING_DB_NAME=billing_db
BILLING_DB_USER=billing_user
BILLING_DB_PASSWORD=billing_pass
BILLING_DB_PORT=5434

# Keycloak Database
KEYCLOAK_DB_NAME=keycloak_db
KEYCLOAK_DB_USER=keycloak_user
KEYCLOAK_DB_PASSWORD=keycloak_pass
KEYCLOAK_DB_PORT=5435

# ==================== KEYCLOAK CONFIGURATION ====================
KEYCLOAK_PORT=8180
KEYCLOAK_ADMIN_USER=admin
KEYCLOAK_ADMIN_PASSWORD=admin
KEYCLOAK_REALM=transportes-realm

# ==================== MICROSERVICES PORTS ====================
GATEWAY_PORT=8080
CLIENTS_SERVICE_PORT=8081
LOGISTICS_SERVICE_PORT=8082
BILLING_SERVICE_PORT=8083

# ==================== OSRM CONFIGURATION ====================
OSRM_PORT=5000

# ==================== SPRING PROFILES ====================
SPRING_PROFILES_ACTIVE=docker



==================================================
RUTH: .gitignore
==================================================
# Compiled class file
*.class

# Log file
*.log

# BlueJ files
*.ctxt

# Mobile Tools for Java (J2ME)
.mtj.tmp/

# Package Files
*.jar
*.war
*.nar
*.ear
*.zip
*.tar.gz
*.rar

# Virtual machine crash logs
hs_err_pid*
replay_pid*

# Maven
target/
pom.xml.tag
pom.xml.releaseBackup
pom.xml.versionsBackup
pom.xml.next
release.properties
dependency-reduced-pom.xml
buildNumber.properties
.mvn/timing.properties
.mvn/wrapper/maven-wrapper.jar

# Gradle
.gradle
build/
!gradle/wrapper/gradle-wrapper.jar
!**/src/main/**/build/
!**/src/test/**/build/

# IntelliJ IDEA
.idea/
*.iws
*.iml
*.ipr
out/
!**/src/main/**/out/
!**/src/test/**/out/

# Eclipse
.apt_generated
.classpath
.factorypath
.project
.settings
.springBeans
.sts4-cache
bin/
!**/src/main/**/bin/
!**/src/test/**/bin/

# NetBeans
/nbproject/private/
/nbbuild/
/dist/
/nbdist/
/.nb-gradle/

# VS Code
.vscode/

# Mac
.DS_Store

# Windows
Thumbs.db
ehthumbs.db
Desktop.ini

# Environment variables
.env

# Docker
*.pid
*.seed
*.pid.lock

# Logs
logs/
*.log

# Database
*.db
*.sqlite
*.sqlite3

# OSRM data
osrm-data/
*.osm
*.osm.pbf
*.osrm
*.osrm.*

# Temporary files
tmp/
temp/
*.tmp
*.bak
*.swp
*~.nib



==================================================
RUTH: INSTRUCCIONES_POSTMAN.md
==================================================
# Instrucciones - Colecci√≥n Postman TPI Transportes

## üì• Importar la Colecci√≥n

1. Abrir Postman
2. Click en **Import**
3. Seleccionar el archivo `TPI_Transportes_Postman_Collection.json`
4. La colecci√≥n aparecer√° en el panel izquierdo

## üöÄ Orden de Ejecuci√≥n (Caminito Feliz)

### PASO 1: Autenticaci√≥n de Operador
Ejecutar **carpeta 1** en orden:
1. **1.1 Login Operador** ‚Üí Guarda el token autom√°ticamente

### PASO 2: Configuraci√≥n Inicial (Operador)
Ejecutar **carpetas 1-3** en orden:

#### Tarifas (Carpeta 1):
2. **1.2 Crear Tarifa Base**
3. **1.3 Crear Tarifa Combustible**
4. **1.4 Crear Tarifa Estad√≠a**
5. **1.5 Listar Tarifas Base** (opcional)
6. **1.6 Obtener Tarifa Base Vigente** (opcional)

#### Transportistas y Camiones (Carpeta 2):
7. **2.1 Crear Transportista** ‚Üí Guarda ID y email del transportista
8. **2.2 Crear Cami√≥n** ‚Üí Guarda ID del cami√≥n (usa el transportista_id autom√°ticamente)
9. **2.3 Listar Camiones** (opcional)
10. **2.4 Obtener Camiones Disponibles** (opcional)

#### Dep√≥sitos (Carpeta 3):
11. **3.1 Crear Dep√≥sito** (opcional - ya hay dep√≥sitos pre-cargados)
12. **3.2 Actualizar Dep√≥sito** (opcional)

### PASO 3: Cliente Crea Solicitud
Ejecutar **carpeta 4** en orden:
1. **4.1 Crear Solicitud (sin autenticaci√≥n)** ‚Üí Guarda solicitud_id y cliente_email
   - ‚úÖ Verifica que el estado sea **BORRADOR**
2. **4.2 Login Cliente** ‚Üí Guarda token del cliente
3. **4.3 Consultar Mis Solicitudes**
4. **4.4 Consultar Estado/Seguimiento**

### PASO 4: Operador Asigna Ruta
Ejecutar **carpeta 5** en orden:
1. **5.1 Generar Rutas Alternativas**
   - Devuelve 3 rutas:
     - √≠ndice 0: ruta directa (sin dep√≥sitos)
     - √≠ndice 1: ruta con 1 dep√≥sito
     - √≠ndice 2: ruta con 2 dep√≥sitos
   - ‚ö†Ô∏è Las rutas NO tienen ID (son temporales)
   - ‚úÖ Los tramos NO tienen ID a√∫n

2. **5.2 Asignar Ruta (√≠ndice 0 - directa)** ‚Üí Guarda ruta_id y tramo_id
   - ‚úÖ Ahora la ruta tiene ID (fue guardada)
   - ‚úÖ Los tramos tienen IDs
   - ‚úÖ Estado de solicitud cambia a **PROGRAMADA** autom√°ticamente

3. **5.3 Asignar Cami√≥n a Tramo**
   - Usa el tramo_id y camion_id guardados autom√°ticamente
   - ‚úÖ Estado del tramo cambia a **ASIGNADO**
   - ‚úÖ Estado del cami√≥n cambia a **OCUPADO**

### PASO 5: Operador Consulta Costos
Ejecutar **carpeta 6**:
1. **6.1 Obtener Costo Estimado**
2. **6.2 Calcular Costo Final** (despu√©s de finalizar tramos)

### PASO 6: Transportista Ejecuta el Viaje
Ejecutar **carpeta 7** en orden:
1. **7.1 Login Transportista** ‚Üí Guarda token
2. **7.2 Ver Tramos Asignados** ‚Üí Muestra tramos asignados al transportista
3. **7.3 Iniciar Tramo**
   - ‚úÖ Estado del tramo cambia a **INICIADO**
   - ‚úÖ Registra fecha/hora de inicio real
   - ‚úÖ Si es el primer tramo, solicitud cambia a **EN_TRANSITO**

4. **7.4 Finalizar Tramo**
   - ‚úÖ Estado del tramo cambia a **FINALIZADO**
   - ‚úÖ Registra fecha/hora de fin real
   - ‚úÖ Si es el √∫ltimo tramo:
     - Calcula costo real
     - Solicitud cambia a **ENTREGADA**
     - Libera el cami√≥n (DISPONIBLE)

## üìä Variables de Colecci√≥n

Las siguientes variables se guardan autom√°ticamente mediante los scripts de test:

| Variable | Se Guarda En | Se Usa En |
|----------|--------------|-----------|
| `operador_token` | Login Operador | Todos los endpoints de operador |
| `cliente_token` | Login Cliente | Endpoints de cliente |
| `transportista_token` | Login Transportista | Endpoints de transportista |
| `solicitud_id` | Crear Solicitud | Generar rutas, asignar ruta, costos |
| `cliente_email` | Crear Solicitud | Login Cliente |
| `transportista_id` | Crear Transportista | Crear Cami√≥n |
| `transportista_email` | Crear Transportista | Login Transportista |
| `camion_id` | Crear Cami√≥n | Asignar Cami√≥n a Tramo |
| `tramo_id` | Asignar Ruta | Iniciar/Finalizar Tramo |
| `ruta_id` | Asignar Ruta | (Referencia) |

## ‚ö†Ô∏è Notas Importantes

### Estados de Solicitud (Cambios Autom√°ticos)
- `BORRADOR` ‚Üí Al crear la solicitud
- `PROGRAMADA` ‚Üí Al asignar una ruta (autom√°tico)
- `EN_TRANSITO` ‚Üí Al iniciar el primer tramo (autom√°tico)
- `ENTREGADA` ‚Üí Al finalizar el √∫ltimo tramo (autom√°tico)

### Rutas Alternativas
- Las rutas generadas NO tienen ID (son temporales, no se guardan en BD)
- Los tramos de rutas alternativas NO tienen ID
- Al asignar una ruta, se regenera y se guarda con IDs

### Datos Pre-cargados
El sistema tiene datos pre-cargados:
- ‚úÖ 3 Dep√≥sitos activos
- ‚úÖ 3 Camiones
- ‚úÖ 3 Transportistas
- ‚úÖ Tarifas base

Puedes usar los datos pre-cargados o crear nuevos con la colecci√≥n.

### Usuario Operador
El usuario operador debe existir en Keycloak:
- **Username**: `operador.demo@mail.com`
- **Password**: `Demo123!`
- **Rol**: OPERADOR

Si no existe, ejecutar el script:
```bash
./test_endpoints_fixed.sh
```
El script incluye la creaci√≥n del operador en Keycloak.

## üîÑ Reiniciar el Flujo

Para probar nuevamente desde cero:
1. Cambiar el email en **4.1 Crear Solicitud** (ej: `maria.cliente2@demo.com`)
2. Ejecutar desde el **PASO 3** en adelante
3. El sistema crear√° un nuevo cliente y solicitud

## ‚úÖ Verificaciones en Cada Paso

### Despu√©s de Crear Solicitud (4.1):
```json
{
  "estado": "BORRADOR",  // ‚úÖ Debe ser BORRADOR
  "id": 1,
  "numeroSolicitud": "SOL-2025-XXXXX"
}
```

### Despu√©s de Asignar Ruta (5.2):
```json
{
  "id": 1,  // ‚úÖ La ruta ahora tiene ID
  "tramos": [
    {
      "id": 1,  // ‚úÖ Los tramos tienen IDs
      "estado": "ESTIMADO"
    }
  ]
}
```

### Despu√©s de Asignar Cami√≥n (5.3):
- Verificar en **7.2 Ver Tramos Asignados** que el transportista ve el tramo

### Despu√©s de Iniciar Tramo (7.3):
```json
{
  "estado": "INICIADO",  // ‚úÖ Debe ser INICIADO
  "fechaHoraInicioReal": "2025-12-03T10:30:00"  // ‚úÖ Tiene fecha real
}
```

### Despu√©s de Finalizar Tramo (7.4):
```json
{
  "estado": "FINALIZADO",  // ‚úÖ Debe ser FINALIZADO
  "fechaHoraFinReal": "2025-12-03T14:30:00"  // ‚úÖ Tiene fecha real
}
```

Verificar en **4.4 Consultar Estado** que la solicitud est√© en estado `ENTREGADA`.

## üìû Soporte

Para dudas o problemas:
1. Verificar logs de Docker: `docker compose logs -f`
2. Verificar que todos los servicios est√©n activos: `docker compose ps`
3. Revisar la documentaci√≥n Swagger: `http://localhost:8080/swagger-ui.html`



==================================================
RUTH: TPI_Transportes_Postman_Collection.json
==================================================
{
	"info": {
		"_postman_id": "tpi-transportes-2025-v2",
		"name": "TPI Transportes - Caminito Feliz",
		"description": "Colecci√≥n completa para demostrar el flujo de trabajo del sistema de transportes",
		"schema": "https://schema.getpostman.com/json/collection/v2.1.0/collection.json"
	},
	"variable": [
		{
			"key": "base_url",
			"value": "http://localhost:8080",
			"type": "string"
		},
		{
			"key": "keycloak_url",
			"value": "http://localhost:8180",
			"type": "string"
		},
		{
			"key": "operador_token",
			"value": "",
			"type": "string"
		},
		{
			"key": "cliente_token",
			"value": "",
			"type": "string"
		},
		{
			"key": "transportista_token",
			"value": "",
			"type": "string"
		},
		{
			"key": "solicitud_id",
			"value": "",
			"type": "string"
		},
		{
			"key": "cliente_email",
			"value": "",
			"type": "string"
		},
		{
			"key": "transportista_email",
			"value": "",
			"type": "string"
		},
		{
			"key": "transportista_id",
			"value": "",
			"type": "string"
		},
		{
			"key": "camion_id",
			"value": "",
			"type": "string"
		},
		{
			"key": "tramo_id",
			"value": "",
			"type": "string"
		},
		{
			"key": "ruta_id",
			"value": "",
			"type": "string"
		}
	],
	"item": [
		{
			"name": "1. OPERADOR - Autenticaci√≥n y Tarifas",
			"item": [
				{
					"name": "1.1 Login Operador",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.test(\"Login exitoso\", function () {",
									"    pm.response.to.have.status(200);",
									"    var jsonData = pm.response.json();",
									"    pm.expect(jsonData.access_token).to.exist;",
									"    pm.collectionVariables.set(\"operador_token\", jsonData.access_token);",
									"});"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "POST",
						"header": [
							{
								"key": "Content-Type",
								"value": "application/x-www-form-urlencoded"
							}
						],
						"body": {
							"mode": "urlencoded",
							"urlencoded": [
								{
									"key": "username",
									"value": "operador.demo@mail.com",
									"type": "text"
								},
								{
									"key": "password",
									"value": "Demo123!",
									"type": "text"
								},
								{
									"key": "grant_type",
									"value": "password",
									"type": "text"
								},
								{
									"key": "client_id",
									"value": "public-app",
									"type": "text"
								}
							]
						},
						"url": {
							"raw": "{{keycloak_url}}/realms/transportes-realm/protocol/openid-connect/token",
							"host": [
								"{{keycloak_url}}"
							],
							"path": [
								"realms",
								"transportes-realm",
								"protocol",
								"openid-connect",
								"token"
							]
						}
					},
					"response": []
				},
				{
					"name": "1.2 Crear Tarifa Base",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.test(\"Tarifa base creada\", function () {",
									"    pm.response.to.have.status(201);",
									"    var jsonData = pm.response.json();",
									"    pm.expect(jsonData.id).to.exist;",
									"});"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "POST",
						"header": [
							{
								"key": "Authorization",
								"value": "Bearer {{operador_token}}"
							},
							{
								"key": "Content-Type",
								"value": "application/json"
							}
						],
						"body": {
							"mode": "raw",
							"raw": "{\n  \"nombre\": \"Tarifa Base 2025\",\n  \"descripcion\": \"Tarifa base para gesti√≥n y tramos\",\n  \"costoFijoGestion\": 5000.00,\n  \"costoAdicionalPorTramo\": 1500.00,\n  \"fechaVigenciaDesde\": \"2025-01-01\",\n  \"fechaVigenciaHasta\": \"2025-12-31\",\n  \"activa\": true\n}"
						},
						"url": {
							"raw": "{{base_url}}/api/tarifas/base",
							"host": [
								"{{base_url}}"
							],
							"path": [
								"api",
								"tarifas",
								"base"
							]
						}
					},
					"response": []
				},
				{
					"name": "1.3 Crear Tarifa Combustible",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.test(\"Tarifa combustible creada\", function () {",
									"    pm.response.to.have.status(201);",
									"});"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "POST",
						"header": [
							{
								"key": "Authorization",
								"value": "Bearer {{operador_token}}"
							},
							{
								"key": "Content-Type",
								"value": "application/json"
							}
						],
						"body": {
							"mode": "raw",
							"raw": "{\n  \"descripcion\": \"Tarifa combustible 2025\",\n  \"precioPorLitro\": 850.00,\n  \"fechaVigenciaDesde\": \"2025-01-01\",\n  \"fechaVigenciaHasta\": \"2025-12-31\",\n  \"activa\": true\n}"
						},
						"url": {
							"raw": "{{base_url}}/api/tarifas/combustible",
							"host": [
								"{{base_url}}"
							],
							"path": [
								"api",
								"tarifas",
								"combustible"
							]
						}
					},
					"response": []
				},
				{
					"name": "1.4 Crear Tarifa Estad√≠a",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.test(\"Tarifa estad√≠a creada\", function () {",
									"    pm.response.to.have.status(201);",
									"});"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "POST",
						"header": [
							{
								"key": "Authorization",
								"value": "Bearer {{operador_token}}"
							},
							{
								"key": "Content-Type",
								"value": "application/json"
							}
						],
						"body": {
							"mode": "raw",
							"raw": "{\n  \"costoPorDia\": 12000.00,\n  \"costoPorHora\": 500.00,\n  \"fechaVigenciaDesde\": \"2025-01-01\",\n  \"fechaVigenciaHasta\": \"2025-12-31\",\n  \"activa\": true\n}"
						},
						"url": {
							"raw": "{{base_url}}/api/tarifas/estadia",
							"host": [
								"{{base_url}}"
							],
							"path": [
								"api",
								"tarifas",
								"estadia"
							]
						}
					},
					"response": []
				},
				{
					"name": "1.5 Listar Tarifas Base",
					"request": {
						"method": "GET",
						"header": [
							{
								"key": "Authorization",
								"value": "Bearer {{operador_token}}"
							}
						],
						"url": {
							"raw": "{{base_url}}/api/tarifas/base",
							"host": [
								"{{base_url}}"
							],
							"path": [
								"api",
								"tarifas",
								"base"
							]
						}
					},
					"response": []
				},
				{
					"name": "1.6 Obtener Tarifa Base Vigente",
					"request": {
						"method": "GET",
						"header": [
							{
								"key": "Authorization",
								"value": "Bearer {{operador_token}}"
							}
						],
						"url": {
							"raw": "{{base_url}}/api/tarifas/base/vigente",
							"host": [
								"{{base_url}}"
							],
							"path": [
								"api",
								"tarifas",
								"base",
								"vigente"
							]
						}
					},
					"response": []
				}
			]
		},
		{
			"name": "2. OPERADOR - Transportistas y Camiones",
			"item": [
				{
					"name": "2.1 Crear Transportista",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.test(\"Transportista creado\", function () {",
									"    pm.response.to.have.status(200);",
									"    var jsonData = pm.response.json();",
									"    pm.collectionVariables.set(\"transportista_id\", jsonData.id);",
									"    pm.collectionVariables.set(\"transportista_email\", jsonData.email);",
									"});"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "POST",
						"header": [
							{
								"key": "Authorization",
								"value": "Bearer {{operador_token}}"
							},
							{
								"key": "Content-Type",
								"value": "application/json"
							}
						],
						"body": {
							"mode": "raw",
							"raw": "{\n  \"nombre\": \"Juan\",\n  \"apellido\": \"Transportista\",\n  \"dni\": \"30456789\",\n  \"telefono\": \"11-5555-6666\",\n  \"email\": \"juan.trans@demo.com\",\n  \"password\": \"Trans123!\",\n  \"licenciaConducir\": \"B1-30456789\",\n  \"activo\": true\n}"
						},
						"url": {
							"raw": "{{base_url}}/api/transportista",
							"host": [
								"{{base_url}}"
							],
							"path": [
								"api",
								"transportista"
							]
						}
					},
					"response": []
				},
				{
					"name": "2.2 Crear Cami√≥n",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.test(\"Cami√≥n creado\", function () {",
									"    pm.response.to.have.status(200);",
									"    var jsonData = pm.response.json();",
									"    pm.collectionVariables.set(\"camion_id\", jsonData.id);",
									"});"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "POST",
						"header": [
							{
								"key": "Authorization",
								"value": "Bearer {{operador_token}}"
							},
							{
								"key": "Content-Type",
								"value": "application/json"
							}
						],
						"body": {
							"mode": "raw",
							"raw": "{\n  \"dominio\": \"AB123CD\",\n  \"marca\": \"Scania\",\n  \"modelo\": \"R450\",\n  \"anio\": 2024,\n  \"capacidadPesoKg\": 30000,\n  \"capacidadVolumenM3\": 80,\n  \"consumoCombustibleKmLitro\": 0.35,\n  \"costoBasePorKm\": 250.00,\n  \"transportistaId\": \"{{transportista_id}}\",\n  \"estado\": \"DISPONIBLE\",\n  \"activo\": true\n}"
						},
						"url": {
							"raw": "{{base_url}}/api/camiones",
							"host": [
								"{{base_url}}"
							],
							"path": [
								"api",
								"camiones"
							]
						}
					},
					"response": []
				},
				{
					"name": "2.3 Listar Camiones",
					"request": {
						"method": "GET",
						"header": [
							{
								"key": "Authorization",
								"value": "Bearer {{operador_token}}"
							}
						],
						"url": {
							"raw": "{{base_url}}/api/camiones",
							"host": [
								"{{base_url}}"
							],
							"path": [
								"api",
								"camiones"
							]
						}
					},
					"response": []
				}
			]
		},
		{
			"name": "3. OPERADOR - Dep√≥sitos",
			"item": [
				{
					"name": "3.1 Crear Dep√≥sito",
					"request": {
						"method": "POST",
						"header": [
							{
								"key": "Authorization",
								"value": "Bearer {{operador_token}}"
							},
							{
								"key": "Content-Type",
								"value": "application/json"
							}
						],
						"body": {
							"mode": "raw",
							"raw": "{\n  \"nombre\": \"Dep√≥sito Demo Nuevo\",\n  \"direccion\": \"Av. Demo 1234, CABA\",\n  \"latitud\": -34.6037,\n  \"longitud\": -58.3816,\n  \"capacidadMaxima\": 100,\n  \"activo\": true\n}"
						},
						"url": {
							"raw": "{{base_url}}/api/depositos",
							"host": [
								"{{base_url}}"
							],
							"path": [
								"api",
								"depositos"
							]
						}
					},
					"response": []
				},
				{
					"name": "3.2 Listar Dep√≥sitos",
					"request": {
						"method": "GET",
						"header": [
							{
								"key": "Authorization",
								"value": "Bearer {{operador_token}}"
							}
						],
						"url": {
							"raw": "{{base_url}}/api/depositos",
							"host": [
								"{{base_url}}"
							],
							"path": [
								"api",
								"depositos"
							]
						}
					},
					"response": []
				}
			]
		},
		{
			"name": "4. CLIENTE - Solicitudes",
			"item": [
				{
					"name": "4.1 Crear Solicitud (sin autenticaci√≥n)",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.test(\"Solicitud creada con estado BORRADOR\", function () {",
									"    pm.response.to.have.status(200);",
									"    var jsonData = pm.response.json();",
									"    pm.expect(jsonData.estado).to.eql(\"BORRADOR\");",
									"    pm.collectionVariables.set(\"solicitud_id\", jsonData.id);",
									"    pm.collectionVariables.set(\"cliente_email\", jsonData.cliente.email);",
									"});"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "POST",
						"header": [
							{
								"key": "Content-Type",
								"value": "application/json"
							}
						],
						"body": {
							"mode": "raw",
							"raw": "{\n  \"nombre\": \"Mar√≠a\",\n  \"apellido\": \"Cliente\",\n  \"email\": \"maria.cliente@demo.com\",\n  \"password\": \"Cliente123!\",\n  \"telefono\": \"11-9999-8888\",\n  \"direccion\": \"Calle Demo 123\",\n  \"contenedor\": {\n    \"pesoKg\": 18000,\n    \"volumenM3\": 35.5,\n    \"descripcion\": \"Contenedor de prueba\"\n  },\n  \"origen\": {\n    \"direccion\": \"Buenos Aires, Argentina\",\n    \"latitud\": -34.6037,\n    \"longitud\": -58.3816\n  },\n  \"destino\": {\n    \"direccion\": \"Rosario, Santa Fe, Argentina\",\n    \"latitud\": -32.9442,\n    \"longitud\": -60.6505\n  },\n  \"observaciones\": \"Solicitud de prueba para demostraci√≥n\"\n}"
						},
						"url": {
							"raw": "{{base_url}}/api/solicitudes",
							"host": [
								"{{base_url}}"
							],
							"path": [
								"api",
								"solicitudes"
							]
						}
					},
					"response": []
				},
				{
					"name": "4.2 Login Cliente",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.test(\"Login cliente exitoso\", function () {",
									"    pm.response.to.have.status(200);",
									"    var jsonData = pm.response.json();",
									"    pm.collectionVariables.set(\"cliente_token\", jsonData.access_token);",
									"});"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "POST",
						"header": [
							{
								"key": "Content-Type",
								"value": "application/x-www-form-urlencoded"
							}
						],
						"body": {
							"mode": "urlencoded",
							"urlencoded": [
								{
									"key": "username",
									"value": "{{cliente_email}}",
									"type": "text"
								},
								{
									"key": "password",
									"value": "Cliente123!",
									"type": "text"
								},
								{
									"key": "grant_type",
									"value": "password",
									"type": "text"
								},
								{
									"key": "client_id",
									"value": "public-app",
									"type": "text"
								}
							]
						},
						"url": {
							"raw": "{{keycloak_url}}/realms/transportes-realm/protocol/openid-connect/token",
							"host": [
								"{{keycloak_url}}"
							],
							"path": [
								"realms",
								"transportes-realm",
								"protocol",
								"openid-connect",
								"token"
							]
						}
					},
					"response": []
				},
				{
					"name": "4.3 Crear Solicitud (con autenticaci√≥n)",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.test(\"Solicitud creada\", function () {",
									"    pm.response.to.have.status(200);",
									"    var jsonData = pm.response.json();",
									"    pm.expect(jsonData.estado).to.eql(\"BORRADOR\");",
									"});"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "POST",
						"header": [
							{
								"key": "Authorization",
								"value": "Bearer {{cliente_token}}"
							},
							{
								"key": "Content-Type",
								"value": "application/json"
							}
						],
						"body": {
							"mode": "raw",
							"raw": "{\n  \"contenedor\": {\n    \"pesoKg\": 20000,\n    \"volumenM3\": 40,\n    \"descripcion\": \"Otro contenedor\"\n  },\n  \"origen\": {\n    \"direccion\": \"C√≥rdoba, Argentina\",\n    \"latitud\": -31.4201,\n    \"longitud\": -64.1888\n  },\n  \"destino\": {\n    \"direccion\": \"Mendoza, Argentina\",\n    \"latitud\": -32.8895,\n    \"longitud\": -68.8458\n  },\n  \"observaciones\": \"Segunda solicitud del mismo cliente\"\n}"
						},
						"url": {
							"raw": "{{base_url}}/api/solicitudes",
							"host": [
								"{{base_url}}"
							],
							"path": [
								"api",
								"solicitudes"
							]
						}
					},
					"response": []
				},
				{
					"name": "4.4 Consultar Mis Solicitudes",
					"request": {
						"method": "GET",
						"header": [
							{
								"key": "Authorization",
								"value": "Bearer {{cliente_token}}"
							}
						],
						"url": {
							"raw": "{{base_url}}/api/solicitudes/mis-solicitudes",
							"host": [
								"{{base_url}}"
							],
							"path": [
								"api",
								"solicitudes",
								"mis-solicitudes"
							]
						}
					},
					"response": []
				},
				{
					"name": "4.5 Consultar Estado/Seguimiento",
					"request": {
						"method": "GET",
						"header": [
							{
								"key": "Authorization",
								"value": "Bearer {{cliente_token}}"
							}
						],
						"url": {
							"raw": "{{base_url}}/api/solicitudes/{{solicitud_id}}/seguimiento",
							"host": [
								"{{base_url}}"
							],
							"path": [
								"api",
								"solicitudes",
								"{{solicitud_id}}",
								"seguimiento"
							]
						}
					},
					"response": []
				}
			]
		},
		{
			"name": "5. OPERADOR - Gesti√≥n de Rutas",
			"item": [
				{
					"name": "5.1 Generar Rutas Alternativas",
					"request": {
						"method": "GET",
						"header": [
							{
								"key": "Authorization",
								"value": "Bearer {{operador_token}}"
							}
						],
						"url": {
							"raw": "{{base_url}}/api/rutas/alternativas/{{solicitud_id}}",
							"host": [
								"{{base_url}}"
							],
							"path": [
								"api",
								"rutas",
								"alternativas",
								"{{solicitud_id}}"
							]
						},
						"description": "Genera 3 rutas alternativas SIN guardar en BD:\n- √≠ndice 0: ruta directa (sin dep√≥sitos)\n- √≠ndice 1: ruta con 1 dep√≥sito\n- √≠ndice 2: ruta con 2 dep√≥sitos\n\nNOTA: Las rutas NO tienen ID porque son temporales. Los tramos tampoco tienen ID. Muchos campos aparecen como null porque son estimaciones preliminares."
					},
					"response": []
				},
				{
					"name": "5.2 Asignar Ruta (√≠ndice 0 - directa)",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.test(\"Ruta asignada correctamente\", function () {",
									"    pm.response.to.have.status(200);",
									"    var jsonData = pm.response.json();",
									"    pm.expect(jsonData.id).to.exist;",
									"    pm.expect(jsonData.tramos).to.be.an('array');",
									"    pm.expect(jsonData.tramos.length).to.be.above(0);",
									"    if (jsonData.tramos[0]) {",
									"        pm.expect(jsonData.tramos[0].id).to.exist;",
									"        pm.collectionVariables.set(\"tramo_id\", jsonData.tramos[0].id);",
									"    }",
									"    pm.collectionVariables.set(\"ruta_id\", jsonData.id);",
									"});"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "POST",
						"header": [
							{
								"key": "Authorization",
								"value": "Bearer {{operador_token}}"
							}
						],
						"url": {
							"raw": "{{base_url}}/api/rutas/{{solicitud_id}}/asignar/0",
							"host": [
								"{{base_url}}"
							],
							"path": [
								"api",
								"rutas",
								"{{solicitud_id}}",
								"asignar",
								"0"
							]
						},
						"description": "Asigna la ruta con √≠ndice 0 (directa). La ruta se GUARDA en BD y retorna con:\n- Ruta ID\n- Tramos con IDs\n- Estado de solicitud cambia a PROGRAMADA autom√°ticamente"
					},
					"response": []
				},
				{
					"name": "5.3 Asignar Cami√≥n a Tramo",
					"request": {
						"method": "POST",
						"header": [
							{
								"key": "Authorization",
								"value": "Bearer {{operador_token}}"
							}
						],
						"url": {
							"raw": "{{base_url}}/api/tramos/{{tramo_id}}/asignar-camion?camionId={{camion_id}}",
							"host": [
								"{{base_url}}"
							],
							"path": [
								"api",
								"tramos",
								"{{tramo_id}}",
								"asignar-camion"
							],
							"query": [
								{
									"key": "camionId",
									"value": "{{camion_id}}"
								}
							]
						},
						"description": "Asigna el cami√≥n al tramo. Cambios:\n- Estado del tramo: ESTIMADO -> ASIGNADO\n- Estado del cami√≥n: DISPONIBLE -> OCUPADO"
					},
					"response": []
				}
			]
		},
		{
			"name": "6. OPERADOR - Costos",
			"item": [
				{
					"name": "6.1 Obtener Costo Estimado",
					"request": {
						"method": "GET",
						"header": [
							{
								"key": "Authorization",
								"value": "Bearer {{operador_token}}"
							}
						],
						"url": {
							"raw": "{{base_url}}/api/costos/solicitud/{{solicitud_id}}/estimado",
							"host": [
								"{{base_url}}"
							],
							"path": [
								"api",
								"costos",
								"solicitud",
								"{{solicitud_id}}",
								"estimado"
							]
						}
					},
					"response": []
				},
				{
					"name": "6.2 Calcular Costo Final",
					"request": {
						"method": "GET",
						"header": [
							{
								"key": "Authorization",
								"value": "Bearer {{operador_token}}"
							}
						],
						"url": {
							"raw": "{{base_url}}/api/costos/solicitud/{{solicitud_id}}/final",
							"host": [
								"{{base_url}}"
							],
							"path": [
								"api",
								"costos",
								"solicitud",
								"{{solicitud_id}}",
								"final"
							]
						},
						"description": "NOTA: Solo funciona despu√©s de que el transportista haya finalizado todos los tramos de la ruta."
					},
					"response": []
				}
			]
		},
		{
			"name": "7. TRANSPORTISTA - Gesti√≥n de Viajes",
			"item": [
				{
					"name": "7.1 Login Transportista",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.test(\"Login transportista exitoso\", function () {",
									"    pm.response.to.have.status(200);",
									"    var jsonData = pm.response.json();",
									"    pm.collectionVariables.set(\"transportista_token\", jsonData.access_token);",
									"});"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "POST",
						"header": [
							{
								"key": "Content-Type",
								"value": "application/x-www-form-urlencoded"
							}
						],
						"body": {
							"mode": "urlencoded",
							"urlencoded": [
								{
									"key": "username",
									"value": "{{transportista_email}}",
									"type": "text"
								},
								{
									"key": "password",
									"value": "Trans123!",
									"type": "text"
								},
								{
									"key": "grant_type",
									"value": "password",
									"type": "text"
								},
								{
									"key": "client_id",
									"value": "public-app",
									"type": "text"
								}
							]
						},
						"url": {
							"raw": "{{keycloak_url}}/realms/transportes-realm/protocol/openid-connect/token",
							"host": [
								"{{keycloak_url}}"
							],
							"path": [
								"realms",
								"transportes-realm",
								"protocol",
								"openid-connect",
								"token"
							]
						}
					},
					"response": []
				},
				{
					"name": "7.2 Ver Tramos Asignados",
					"request": {
						"method": "GET",
						"header": [
							{
								"key": "Authorization",
								"value": "Bearer {{transportista_token}}"
							}
						],
						"url": {
							"raw": "{{base_url}}/api/transportista/tramos-asignados",
							"host": [
								"{{base_url}}"
							],
							"path": [
								"api",
								"transportista",
								"tramos-asignados"
							]
						}
					},
					"response": []
				},
				{
					"name": "7.3 Iniciar Tramo",
					"request": {
						"method": "POST",
						"header": [
							{
								"key": "Authorization",
								"value": "Bearer {{transportista_token}}"
							}
						],
						"url": {
							"raw": "{{base_url}}/api/transportista/tramos/{{tramo_id}}/iniciar",
							"host": [
								"{{base_url}}"
							],
							"path": [
								"api",
								"transportista",
								"tramos",
								"{{tramo_id}}",
								"iniciar"
							]
						},
						"description": "Inicia el tramo. Cambios:\n- Estado: ASIGNADO -> INICIADO\n- Registra fecha/hora inicio real\n- Si es el primer tramo, solicitud cambia a EN_TRANSITO"
					},
					"response": []
				},
				{
					"name": "7.4 Finalizar Tramo",
					"request": {
						"method": "POST",
						"header": [
							{
								"key": "Authorization",
								"value": "Bearer {{transportista_token}}"
							}
						],
						"url": {
							"raw": "{{base_url}}/api/transportista/tramos/{{tramo_id}}/finalizar",
							"host": [
								"{{base_url}}"
							],
							"path": [
								"api",
								"transportista",
								"tramos",
								"{{tramo_id}}",
								"finalizar"
							]
						},
						"description": "Finaliza el tramo. Cambios:\n- Estado: INICIADO -> FINALIZADO\n- Registra fecha/hora fin real\n- Si es el √∫ltimo tramo:\n  - Calcula costo real\n  - Solicitud cambia a ENTREGADA\n  - Libera el cami√≥n (DISPONIBLE)"
					},
					"response": []
				}
			]
		}
	]
}



==================================================
RUTH: billing-service/Dockerfile
==================================================
# Usamos solo una etapa - esperamos que el JAR ya est√© compilado
FROM eclipse-temurin:17-jre-alpine
WORKDIR /app

# Copiamos el JAR ya compilado desde el host
COPY target/billing-service-1.0.0.jar app.jar

EXPOSE 8083

ENTRYPOINT ["java", "-jar", "app.jar"]



==================================================
RUTH: billing-service/pom.xml
==================================================
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 
         http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <parent>
        <groupId>com.transportes</groupId>
        <artifactId>tpi-transportes</artifactId>
        <version>1.0.0</version>
    </parent>

    <artifactId>billing-service</artifactId>
    <name>Billing Service</name>
    <description>Microservicio para gesti√≥n de tarifas y c√°lculo de costos</description>

    <dependencies>
        <!-- Spring Boot Starters -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-jpa</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-validation</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-actuator</artifactId>
        </dependency>

        <!-- Spring Security + OAuth2 Resource Server -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-security</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-oauth2-resource-server</artifactId>
        </dependency>

        <!-- Database -->
        <dependency>
            <groupId>org.postgresql</groupId>
            <artifactId>postgresql</artifactId>
            <scope>runtime</scope>
        </dependency>

        <!-- Lombok -->
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <optional>true</optional>
        </dependency>

        <!-- MapStruct -->
        <dependency>
            <groupId>org.mapstruct</groupId>
            <artifactId>mapstruct</artifactId>
        </dependency>

        <!-- Springdoc OpenAPI -->
        <dependency>
            <groupId>org.springdoc</groupId>
            <artifactId>springdoc-openapi-starter-webmvc-ui</artifactId>
        </dependency>

        <!-- Test -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>

        <dependency>
            <groupId>org.springframework.security</groupId>
            <artifactId>spring-security-test</artifactId>
            <scope>test</scope>
        </dependency>

        <dependency>
            <groupId>com.h2database</groupId>
            <artifactId>h2</artifactId>
            <scope>test</scope>
        </dependency>
    </dependencies>

    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
                <executions>
                    <execution>
                        <goals>
                            <goal>repackage</goal>
                        </goals>
                    </execution>
                </executions>
            </plugin>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
            </plugin>
        </plugins>
    </build>

</project>



==================================================
RUTH: billing-service/src/main/java/com/transportes/billing/BillingServiceApplication.java
==================================================
package com.transportes.billing;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class BillingServiceApplication {

    public static void main(String[] args) {
        SpringApplication.run(BillingServiceApplication.class, args);
    }
}



==================================================
RUTH: billing-service/src/main/java/com/transportes/billing/config/SecurityConfig.java
==================================================
package com.transportes.billing.config;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.oauth2.jwt.Jwt;
import org.springframework.security.oauth2.jwt.JwtDecoder;
import org.springframework.security.oauth2.jwt.NimbusJwtDecoder;
import org.springframework.security.oauth2.server.resource.authentication.JwtAuthenticationConverter;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.core.convert.converter.Converter;

import java.util.Collection;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

@Configuration
@EnableWebSecurity
@EnableMethodSecurity
public class SecurityConfig {

    @Value("${spring.security.oauth2.resourceserver.jwt.jwk-set-uri}")
    private String jwkSetUri;

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
                .csrf(csrf -> csrf.disable())
                .authorizeHttpRequests(auth -> auth
                        .requestMatchers("/actuator/**").permitAll()
                        .requestMatchers("/swagger-ui/**", "/v3/api-docs/**").permitAll()
                        .anyRequest().authenticated()
                )
                .oauth2ResourceServer(oauth2 -> oauth2
                        .jwt(jwt -> jwt
                                .decoder(jwtDecoder())
                                .jwtAuthenticationConverter(jwtAuthenticationConverter())
                        )
                )
                .sessionManagement(session -> session
                        .sessionCreationPolicy(SessionCreationPolicy.STATELESS)
                );
        return http.build();
    }

    @Bean
    public JwtDecoder jwtDecoder() {
        return NimbusJwtDecoder.withJwkSetUri(jwkSetUri).build();
    }

    @Bean
    public JwtAuthenticationConverter jwtAuthenticationConverter() {
        JwtAuthenticationConverter converter = new JwtAuthenticationConverter();
        converter.setJwtGrantedAuthoritiesConverter(new Converter<Jwt, Collection<GrantedAuthority>>() {
            @Override
            public Collection<GrantedAuthority> convert(Jwt jwt) {
                Map<String, Object> realmAccess = jwt.getClaim("realm_access");
                Collection<String> roles = List.of();
                if (realmAccess != null && !realmAccess.isEmpty()) {
                    roles = (Collection<String>) realmAccess.get("roles");
                }

                return roles.stream()
                        .map(role -> new SimpleGrantedAuthority("ROLE_" + role))
                        .collect(Collectors.toList());
            }
        });

        // Esta l√≠nea es clave para que lea el email del token como principal
        converter.setPrincipalClaimName("email");

        return converter;
    }
}


==================================================
RUTH: billing-service/src/main/java/com/transportes/billing/controller/CostoController.java
==================================================
package com.transportes.billing.controller;

import com.transportes.billing.dto.CalcularCostoRequest;
import com.transportes.billing.dto.CostoSolicitudDTO;
import com.transportes.billing.entity.CostoSolicitud;
import com.transportes.billing.entity.CostoTramo;
import com.transportes.billing.service.CostoService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.security.SecurityRequirement;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

import java.util.List;
import java.util.stream.Collectors;

@Tag(name = "Costos", description = "API para c√°lculo de costos")
@RestController
@RequestMapping("/api/costos")
@RequiredArgsConstructor
@SecurityRequirement(name = "bearer-jwt")
public class CostoController {

    private final CostoService costoService;

    @Operation(summary = "Calcular costo estimado de una solicitud")
    @PreAuthorize("hasRole('OPERADOR')")
    @PostMapping("/calcular-estimado")
    public ResponseEntity<CostoSolicitudDTO> calcularCostoEstimado(
            @Valid @RequestBody CalcularCostoRequest request) {

        List<CostoService.TramoInfo> tramosInfo = request.getTramos().stream()
                .map(t -> new CostoService.TramoInfo(
                        t.getTramoId(),
                        t.getDistanciaKm(),
                        t.getCostoBasePorKm(),
                        t.getConsumoKmLitro()
                ))
                .collect(Collectors.toList());

        CostoSolicitud costo = costoService.calcularCostoEstimado(
                request.getSolicitudId(),
                tramosInfo,
                request.getPesoTotalKg(),
                request.getVolumenTotalM3(),
                request.getDiasEstadiaEstimados()
        );

        return ResponseEntity.status(HttpStatus.CREATED).body(convertirADTO(costo));
    }

    @Operation(summary = "Calcular costo real/final de una solicitud")
    @PreAuthorize("hasRole('OPERADOR')")
    @PostMapping("/calcular-real")
    public ResponseEntity<CostoSolicitudDTO> calcularCostoReal(
            @Valid @RequestBody CalcularCostoRequest request) {

        List<CostoService.TramoInfo> tramosInfo = request.getTramos().stream()
                .map(t -> new CostoService.TramoInfo(
                        t.getTramoId(),
                        t.getDistanciaKm(),
                        t.getCostoBasePorKm(),
                        t.getConsumoKmLitro()
                ))
                .collect(Collectors.toList());

        CostoSolicitud costo = costoService.calcularCostoReal(
                request.getSolicitudId(),
                tramosInfo,
                request.getPesoTotalKg(),
                request.getVolumenTotalM3(),
                request.getHorasEstadiaTotales(),
                request.getCostosAdicionales()
        );

        return ResponseEntity.status(HttpStatus.CREATED).body(convertirADTO(costo));
    }

    @Operation(summary = "Obtener todos los costos de una solicitud")
    @PreAuthorize("hasRole('OPERADOR')")
    @GetMapping("/solicitud/{solicitudId}")
    public ResponseEntity<List<CostoSolicitudDTO>> obtenerCostosSolicitud(
            @PathVariable("solicitudId") Long solicitudId) {

        List<CostoSolicitud> costos = costoService.obtenerCostosSolicitud(solicitudId);
        List<CostoSolicitudDTO> costosDTO = costos.stream()
                .map(this::convertirADTO)
                .collect(Collectors.toList());

        return ResponseEntity.ok(costosDTO);
    }

    @Operation(summary = "Obtener costo estimado de una solicitud")
    @PreAuthorize("hasRole('OPERADOR')")
    @GetMapping("/solicitud/{solicitudId}/estimado")
    public ResponseEntity<CostoSolicitudDTO> obtenerCostoEstimado(
            @PathVariable("solicitudId") Long solicitudId) {

        try {
            CostoSolicitud costo = costoService.obtenerCostoEstimado(solicitudId);
            return ResponseEntity.ok(convertirADTO(costo));
        } catch (RuntimeException e) {
            return ResponseEntity.notFound().build();
        }
    }

    @Operation(summary = "Obtener costo final de una solicitud")
    @PreAuthorize("hasRole('OPERADOR')")
    @GetMapping("/solicitud/{solicitudId}/final")
    public ResponseEntity<CostoSolicitudDTO> obtenerCostoFinal(
            @PathVariable("solicitudId") Long solicitudId) {

        try {
            CostoSolicitud costo = costoService.obtenerCostoFinal(solicitudId);
            return ResponseEntity.ok(convertirADTO(costo));
        } catch (RuntimeException e) {
            return ResponseEntity.notFound().build();
        }
    }

    // M√©todo auxiliar para convertir entidad a DTO
    private CostoSolicitudDTO convertirADTO(CostoSolicitud costo) {
        return CostoSolicitudDTO.builder()
                .id(costo.getId())
                .solicitudId(costo.getSolicitudId())
                .tipo(costo.getTipo().name())
                .costoGestion(costo.getCostoGestion())
                .costoTransporte(costo.getCostoTransporte())
                .costoCombustible(costo.getCostoCombustible())
                .costoEstadia(costo.getCostoEstadia())
                .costoAdicionales(costo.getCostoAdicionales())
                .costoTotal(costo.getCostoTotal())
                .tarifaBaseId(costo.getTarifaBase() != null ? costo.getTarifaBase().getId() : null)
                .tarifaCombustibleId(costo.getTarifaCombustible() != null ? costo.getTarifaCombustible().getId() : null)
                .tarifaEstadiaId(costo.getTarifaEstadia() != null ? costo.getTarifaEstadia().getId() : null)
                .fechaCalculo(costo.getFechaCalculo())
                .observaciones(costo.getObservaciones())
                .costosTramos(costo.getCostosTramos().stream()
                        .map(this::convertirTramoADTO)
                        .collect(Collectors.toList()))
                .build();
    }

    private com.transportes.billing.dto.CostoTramoDTO convertirTramoADTO(CostoTramo tramo) {
        return com.transportes.billing.dto.CostoTramoDTO.builder()
                .id(tramo.getId())
                .tramoId(tramo.getTramoId())
                .tipo(tramo.getTipo().name())
                .distanciaKm(tramo.getDistanciaKm())
                .costoPorKm(tramo.getCostoPorKm())
                .costoCombustible(tramo.getCostoCombustible())
                .costoEstadia(tramo.getCostoEstadia())
                .horasEstadia(tramo.getHorasEstadia())
                .costoTotalTramo(tramo.getCostoTotalTramo())
                .fechaCalculo(tramo.getFechaCalculo())
                .build();
    }
}



==================================================
RUTH: billing-service/src/main/java/com/transportes/billing/controller/TarifaBaseController.java
==================================================
package com.transportes.billing.controller;

import com.transportes.billing.dto.TarifaBaseDTO;
import com.transportes.billing.entity.TarifaBase;
import com.transportes.billing.repository.TarifaBaseRepository;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

import java.util.List;
import java.util.stream.Collectors;

@RestController
@RequestMapping("/api/tarifas/base")
@PreAuthorize("hasRole('OPERADOR')")
@RequiredArgsConstructor
@Tag(name = "Tarifas Base", description = "Gesti√≥n de tarifas base")
public class TarifaBaseController {

    private final TarifaBaseRepository tarifaBaseRepository;

    @GetMapping
    @Operation(summary = "Listar todas las tarifas base")
    public ResponseEntity<List<TarifaBaseDTO>> listarTodas() {
        List<TarifaBaseDTO> tarifas = tarifaBaseRepository.findAll()
                .stream()
                .map(this::convertirADTO)
                .collect(Collectors.toList());
        return ResponseEntity.ok(tarifas);
    }

    @GetMapping("/{id}")
    @Operation(summary = "Obtener tarifa base por ID")
    public ResponseEntity<TarifaBaseDTO> obtenerPorId(@PathVariable Long id) {
        return tarifaBaseRepository.findById(id)
                .map(this::convertirADTO)
                .map(ResponseEntity::ok)
                .orElse(ResponseEntity.notFound().build());
    }

    @GetMapping("/vigente")
    @Operation(summary = "Obtener tarifa base vigente")
    public ResponseEntity<TarifaBaseDTO> obtenerVigente() {
        return tarifaBaseRepository.findFirstByActivaTrueOrderByFechaVigenciaDesdeDesc()
                .map(this::convertirADTO)
                .map(ResponseEntity::ok)
                .orElse(ResponseEntity.notFound().build());
    }

    @PostMapping
    @Operation(summary = "Crear nueva tarifa base")
    public ResponseEntity<TarifaBaseDTO> crear(@Valid @RequestBody TarifaBaseDTO dto) {
        TarifaBase tarifa = TarifaBase.builder()
                .nombre(dto.getNombre())
                .descripcion(dto.getDescripcion())
                .costoFijoGestion(dto.getCostoFijoGestion())
                .costoAdicionalPorTramo(dto.getCostoAdicionalPorTramo())
                .fechaVigenciaDesde(dto.getFechaVigenciaDesde())
                .fechaVigenciaHasta(dto.getFechaVigenciaHasta())
                .activa(dto.getActiva() != null ? dto.getActiva() : true)
                .build();

        TarifaBase guardada = tarifaBaseRepository.save(tarifa);
        return ResponseEntity.status(HttpStatus.CREATED).body(convertirADTO(guardada));
    }

    @PutMapping("/{id}")
    @Operation(summary = "Actualizar tarifa base")
    public ResponseEntity<TarifaBaseDTO> actualizar(
            @PathVariable Long id,
            @Valid @RequestBody TarifaBaseDTO dto) {

        return tarifaBaseRepository.findById(id)
                .map(tarifa -> {
                    tarifa.setNombre(dto.getNombre());
                    tarifa.setDescripcion(dto.getDescripcion());
                    tarifa.setCostoFijoGestion(dto.getCostoFijoGestion());
                    tarifa.setCostoAdicionalPorTramo(dto.getCostoAdicionalPorTramo());
                    tarifa.setFechaVigenciaDesde(dto.getFechaVigenciaDesde());
                    tarifa.setFechaVigenciaHasta(dto.getFechaVigenciaHasta());
                    if (dto.getActiva() != null) {
                        tarifa.setActiva(dto.getActiva());
                    }
                    TarifaBase actualizada = tarifaBaseRepository.save(tarifa);
                    return ResponseEntity.ok(convertirADTO(actualizada));
                })
                .orElse(ResponseEntity.notFound().build());
    }

    @DeleteMapping("/{id}")
    @Operation(summary = "Eliminar tarifa base")
    public ResponseEntity<Void> eliminar(@PathVariable Long id) {
        if (!tarifaBaseRepository.existsById(id)) {
            return ResponseEntity.notFound().build();
        }
        tarifaBaseRepository.deleteById(id);
        return ResponseEntity.noContent().build();
    }

    private TarifaBaseDTO convertirADTO(TarifaBase tarifa) {
        return TarifaBaseDTO.builder()
                .id(tarifa.getId())
                .nombre(tarifa.getNombre())
                .descripcion(tarifa.getDescripcion())
                .costoFijoGestion(tarifa.getCostoFijoGestion())
                .costoAdicionalPorTramo(tarifa.getCostoAdicionalPorTramo())
                .fechaVigenciaDesde(tarifa.getFechaVigenciaDesde())
                .fechaVigenciaHasta(tarifa.getFechaVigenciaHasta())
                .activa(tarifa.getActiva())
                .fechaCreacion(tarifa.getFechaCreacion())
                .build();
    }
}



==================================================
RUTH: billing-service/src/main/java/com/transportes/billing/controller/TarifaCombustibleController.java
==================================================
package com.transportes.billing.controller;

import com.transportes.billing.dto.TarifaCombustibleDTO;
import com.transportes.billing.entity.TarifaCombustible;
import com.transportes.billing.repository.TarifaCombustibleRepository;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

import java.util.List;
import java.util.stream.Collectors;

@RestController
@RequestMapping("/api/tarifas/combustible")
@PreAuthorize("hasRole('OPERADOR')")
@RequiredArgsConstructor
@Tag(name = "Tarifas Combustible", description = "Gesti√≥n de tarifas de combustible")
public class TarifaCombustibleController {

    private final TarifaCombustibleRepository tarifaCombustibleRepository;

    @GetMapping
    @Operation(summary = "Listar todas las tarifas de combustible")
    public ResponseEntity<List<TarifaCombustibleDTO>> listarTodas() {
        List<TarifaCombustibleDTO> tarifas = tarifaCombustibleRepository.findAll()
                .stream()
                .map(this::convertirADTO)
                .collect(Collectors.toList());
        return ResponseEntity.ok(tarifas);
    }

    @GetMapping("/{id}")
    @Operation(summary = "Obtener tarifa de combustible por ID")
    public ResponseEntity<TarifaCombustibleDTO> obtenerPorId(@PathVariable Long id) {
        return tarifaCombustibleRepository.findById(id)
                .map(this::convertirADTO)
                .map(ResponseEntity::ok)
                .orElse(ResponseEntity.notFound().build());
    }

    @GetMapping("/vigente")
    @Operation(summary = "Obtener tarifa de combustible vigente")
    public ResponseEntity<TarifaCombustibleDTO> obtenerVigente() {
        return tarifaCombustibleRepository.findFirstByActivaTrueOrderByFechaVigenciaDesdeDesc()
                .map(this::convertirADTO)
                .map(ResponseEntity::ok)
                .orElse(ResponseEntity.notFound().build());
    }

    @PostMapping
    @Operation(summary = "Crear nueva tarifa de combustible")
    public ResponseEntity<TarifaCombustibleDTO> crear(@Valid @RequestBody TarifaCombustibleDTO dto) {
        TarifaCombustible tarifa = TarifaCombustible.builder()
                .precioPorLitro(dto.getPrecioPorLitro())
                .fechaVigenciaDesde(dto.getFechaVigenciaDesde())
                .fechaVigenciaHasta(dto.getFechaVigenciaHasta())
                .activa(dto.getActiva() != null ? dto.getActiva() : true)
                .build();

        TarifaCombustible guardada = tarifaCombustibleRepository.save(tarifa);
        return ResponseEntity.status(HttpStatus.CREATED).body(convertirADTO(guardada));
    }

    @PutMapping("/{id}")
    @Operation(summary = "Actualizar tarifa de combustible")
    public ResponseEntity<TarifaCombustibleDTO> actualizar(
            @PathVariable Long id,
            @Valid @RequestBody TarifaCombustibleDTO dto) {

        return tarifaCombustibleRepository.findById(id)
                .map(tarifa -> {
                    tarifa.setPrecioPorLitro(dto.getPrecioPorLitro());
                    tarifa.setFechaVigenciaDesde(dto.getFechaVigenciaDesde());
                    tarifa.setFechaVigenciaHasta(dto.getFechaVigenciaHasta());
                    if (dto.getActiva() != null) {
                        tarifa.setActiva(dto.getActiva());
                    }
                    TarifaCombustible actualizada = tarifaCombustibleRepository.save(tarifa);
                    return ResponseEntity.ok(convertirADTO(actualizada));
                })
                .orElse(ResponseEntity.notFound().build());
    }

    @DeleteMapping("/{id}")
    @Operation(summary = "Eliminar tarifa de combustible")
    public ResponseEntity<Void> eliminar(@PathVariable Long id) {
        if (!tarifaCombustibleRepository.existsById(id)) {
            return ResponseEntity.notFound().build();
        }
        tarifaCombustibleRepository.deleteById(id);
        return ResponseEntity.noContent().build();
    }

    private TarifaCombustibleDTO convertirADTO(TarifaCombustible tarifa) {
        return TarifaCombustibleDTO.builder()
                .id(tarifa.getId())
                .precioPorLitro(tarifa.getPrecioPorLitro())
                .fechaVigenciaDesde(tarifa.getFechaVigenciaDesde())
                .fechaVigenciaHasta(tarifa.getFechaVigenciaHasta())
                .activa(tarifa.getActiva())
                .fechaCreacion(tarifa.getFechaCreacion())
                .build();
    }
}



==================================================
RUTH: billing-service/src/main/java/com/transportes/billing/controller/TarifaEstadiaController.java
==================================================
package com.transportes.billing.controller;

import com.transportes.billing.dto.TarifaEstadiaDTO;
import com.transportes.billing.entity.TarifaEstadia;
import com.transportes.billing.repository.TarifaEstadiaRepository;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

import java.util.List;
import java.util.stream.Collectors;

@RestController
@RequestMapping("/api/tarifas/estadia")
@PreAuthorize("hasRole('OPERADOR')")
@RequiredArgsConstructor
@Tag(name = "Tarifas Estad√≠a", description = "Gesti√≥n de tarifas de estad√≠a")
public class TarifaEstadiaController {

    private final TarifaEstadiaRepository tarifaEstadiaRepository;

    @GetMapping
    @Operation(summary = "Listar todas las tarifas de estad√≠a")
    public ResponseEntity<List<TarifaEstadiaDTO>> listarTodas() {
        List<TarifaEstadiaDTO> tarifas = tarifaEstadiaRepository.findAll()
                .stream()
                .map(this::convertirADTO)
                .collect(Collectors.toList());
        return ResponseEntity.ok(tarifas);
    }

    @GetMapping("/{id}")
    @Operation(summary = "Obtener tarifa de estad√≠a por ID")
    public ResponseEntity<TarifaEstadiaDTO> obtenerPorId(@PathVariable Long id) {
        return tarifaEstadiaRepository.findById(id)
                .map(this::convertirADTO)
                .map(ResponseEntity::ok)
                .orElse(ResponseEntity.notFound().build());
    }

    @GetMapping("/vigente")
    @Operation(summary = "Obtener tarifa de estad√≠a vigente")
    public ResponseEntity<TarifaEstadiaDTO> obtenerVigente() {
        return tarifaEstadiaRepository.findFirstByActivaTrueOrderByFechaVigenciaDesdeDesc()
                .map(this::convertirADTO)
                .map(ResponseEntity::ok)
                .orElse(ResponseEntity.notFound().build());
    }

    @PostMapping
    @Operation(summary = "Crear nueva tarifa de estad√≠a")
    public ResponseEntity<TarifaEstadiaDTO> crear(@Valid @RequestBody TarifaEstadiaDTO dto) {
        TarifaEstadia tarifa = TarifaEstadia.builder()
                .costoPorDia(dto.getCostoPorDia())
                .costoPorHora(dto.getCostoPorHora())
                .fechaVigenciaDesde(dto.getFechaVigenciaDesde())
                .fechaVigenciaHasta(dto.getFechaVigenciaHasta())
                .activa(dto.getActiva() != null ? dto.getActiva() : true)
                .build();

        TarifaEstadia guardada = tarifaEstadiaRepository.save(tarifa);
        return ResponseEntity.status(HttpStatus.CREATED).body(convertirADTO(guardada));
    }

    @PutMapping("/{id}")
    @Operation(summary = "Actualizar tarifa de estad√≠a")
    public ResponseEntity<TarifaEstadiaDTO> actualizar(
            @PathVariable Long id,
            @Valid @RequestBody TarifaEstadiaDTO dto) {

        return tarifaEstadiaRepository.findById(id)
                .map(tarifa -> {
                    tarifa.setCostoPorDia(dto.getCostoPorDia());
                    tarifa.setCostoPorHora(dto.getCostoPorHora());
                    tarifa.setFechaVigenciaDesde(dto.getFechaVigenciaDesde());
                    tarifa.setFechaVigenciaHasta(dto.getFechaVigenciaHasta());
                    if (dto.getActiva() != null) {
                        tarifa.setActiva(dto.getActiva());
                    }
                    TarifaEstadia actualizada = tarifaEstadiaRepository.save(tarifa);
                    return ResponseEntity.ok(convertirADTO(actualizada));
                })
                .orElse(ResponseEntity.notFound().build());
    }

    @DeleteMapping("/{id}")
    @Operation(summary = "Eliminar tarifa de estad√≠a")
    public ResponseEntity<Void> eliminar(@PathVariable Long id) {
        if (!tarifaEstadiaRepository.existsById(id)) {
            return ResponseEntity.notFound().build();
        }
        tarifaEstadiaRepository.deleteById(id);
        return ResponseEntity.noContent().build();
    }

    private TarifaEstadiaDTO convertirADTO(TarifaEstadia tarifa) {
        return TarifaEstadiaDTO.builder()
                .id(tarifa.getId())
                .costoPorDia(tarifa.getCostoPorDia())
                .costoPorHora(tarifa.getCostoPorHora())
                .fechaVigenciaDesde(tarifa.getFechaVigenciaDesde())
                .fechaVigenciaHasta(tarifa.getFechaVigenciaHasta())
                .activa(tarifa.getActiva())
                .fechaCreacion(tarifa.getFechaCreacion())
                .build();
    }
}



==================================================
RUTH: billing-service/src/main/java/com/transportes/billing/controller/TarifaPesoVolumenController.java
==================================================
package com.transportes.billing.controller;

import com.transportes.billing.dto.TarifaPesoVolumenDTO;
import com.transportes.billing.entity.TarifaPesoVolumen;
import com.transportes.billing.repository.TarifaPesoVolumenRepository;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

import java.math.BigDecimal;
import java.util.List;
import java.util.stream.Collectors;

@RestController
@RequestMapping("/api/tarifas/peso-volumen")
@PreAuthorize("hasRole('OPERADOR')")
@RequiredArgsConstructor
@Tag(name = "Tarifas Peso/Volumen", description = "Gesti√≥n de tarifas por peso y volumen")
public class TarifaPesoVolumenController {

    private final TarifaPesoVolumenRepository tarifaPesoVolumenRepository;

    @GetMapping
    @Operation(summary = "Listar todas las tarifas de peso/volumen")
    public ResponseEntity<List<TarifaPesoVolumenDTO>> listarTodas() {
        List<TarifaPesoVolumenDTO> tarifas = tarifaPesoVolumenRepository.findAll()
                .stream()
                .map(this::convertirADTO)
                .collect(Collectors.toList());
        return ResponseEntity.ok(tarifas);
    }

    @GetMapping("/{id}")
    @Operation(summary = "Obtener tarifa de peso/volumen por ID")
    public ResponseEntity<TarifaPesoVolumenDTO> obtenerPorId(@PathVariable Long id) {
        return tarifaPesoVolumenRepository.findById(id)
                .map(this::convertirADTO)
                .map(ResponseEntity::ok)
                .orElse(ResponseEntity.notFound().build());
    }

    @GetMapping("/buscar")
    @Operation(summary = "Buscar tarifa por peso y volumen")
    public ResponseEntity<TarifaPesoVolumenDTO> buscarPorPesoYVolumen(
            @RequestParam BigDecimal peso,
            @RequestParam BigDecimal volumen) {
        return tarifaPesoVolumenRepository.findByPesoYVolumen(peso, volumen)
                .map(this::convertirADTO)
                .map(ResponseEntity::ok)
                .orElse(ResponseEntity.notFound().build());
    }

    @PostMapping
    @Operation(summary = "Crear nueva tarifa de peso/volumen")
    public ResponseEntity<TarifaPesoVolumenDTO> crear(@Valid @RequestBody TarifaPesoVolumenDTO dto) {
        TarifaPesoVolumen tarifa = TarifaPesoVolumen.builder()
                .pesoMinimoKg(dto.getPesoMinimoKg())
                .pesoMaximoKg(dto.getPesoMaximoKg())
                .volumenMinimoM3(dto.getVolumenMinimoM3())
                .volumenMaximoM3(dto.getVolumenMaximoM3())
                .multiplicadorCosto(dto.getMultiplicadorCosto())
                .fechaVigenciaDesde(dto.getFechaVigenciaDesde())
                .fechaVigenciaHasta(dto.getFechaVigenciaHasta())
                .activa(dto.getActiva() != null ? dto.getActiva() : true)
                .build();

        TarifaPesoVolumen guardada = tarifaPesoVolumenRepository.save(tarifa);
        return ResponseEntity.status(HttpStatus.CREATED).body(convertirADTO(guardada));
    }

    @PutMapping("/{id}")
    @Operation(summary = "Actualizar tarifa de peso/volumen")
    public ResponseEntity<TarifaPesoVolumenDTO> actualizar(
            @PathVariable Long id,
            @Valid @RequestBody TarifaPesoVolumenDTO dto) {

        return tarifaPesoVolumenRepository.findById(id)
                .map(tarifa -> {
                    tarifa.setPesoMinimoKg(dto.getPesoMinimoKg());
                    tarifa.setPesoMaximoKg(dto.getPesoMaximoKg());
                    tarifa.setVolumenMinimoM3(dto.getVolumenMinimoM3());
                    tarifa.setVolumenMaximoM3(dto.getVolumenMaximoM3());
                    tarifa.setMultiplicadorCosto(dto.getMultiplicadorCosto());
                    tarifa.setFechaVigenciaDesde(dto.getFechaVigenciaDesde());
                    tarifa.setFechaVigenciaHasta(dto.getFechaVigenciaHasta());
                    if (dto.getActiva() != null) {
                        tarifa.setActiva(dto.getActiva());
                    }
                    TarifaPesoVolumen actualizada = tarifaPesoVolumenRepository.save(tarifa);
                    return ResponseEntity.ok(convertirADTO(actualizada));
                })
                .orElse(ResponseEntity.notFound().build());
    }

    @DeleteMapping("/{id}")
    @Operation(summary = "Eliminar tarifa de peso/volumen")
    public ResponseEntity<Void> eliminar(@PathVariable Long id) {
        if (!tarifaPesoVolumenRepository.existsById(id)) {
            return ResponseEntity.notFound().build();
        }
        tarifaPesoVolumenRepository.deleteById(id);
        return ResponseEntity.noContent().build();
    }

    private TarifaPesoVolumenDTO convertirADTO(TarifaPesoVolumen tarifa) {
        return TarifaPesoVolumenDTO.builder()
                .id(tarifa.getId())
                .pesoMinimoKg(tarifa.getPesoMinimoKg())
                .pesoMaximoKg(tarifa.getPesoMaximoKg())
                .volumenMinimoM3(tarifa.getVolumenMinimoM3())
                .volumenMaximoM3(tarifa.getVolumenMaximoM3())
                .multiplicadorCosto(tarifa.getMultiplicadorCosto())
                .fechaVigenciaDesde(tarifa.getFechaVigenciaDesde())
                .fechaVigenciaHasta(tarifa.getFechaVigenciaHasta())
                .activa(tarifa.getActiva())
                .fechaCreacion(tarifa.getFechaCreacion())
                .build();
    }
}



==================================================
RUTH: billing-service/src/main/java/com/transportes/billing/dto/CalcularCostoRequest.java
==================================================
package com.transportes.billing.dto;

import jakarta.validation.Valid;
import jakarta.validation.constraints.NotEmpty;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Positive;
import jakarta.validation.constraints.PositiveOrZero;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.math.BigDecimal;
import java.util.List;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class CalcularCostoRequest {

    @NotNull(message = "El ID de solicitud es obligatorio")
    private Long solicitudId;

    @NotEmpty(message = "Debe incluir al menos un tramo")
    @Valid
    private List<TramoRequest> tramos;

    @Positive(message = "El peso total debe ser positivo")
    private BigDecimal pesoTotalKg;

    @Positive(message = "El volumen total debe ser positivo")
    private BigDecimal volumenTotalM3;

    @PositiveOrZero(message = "Los d√≠as de estad√≠a no pueden ser negativos")
    private Integer diasEstadiaEstimados;

    @PositiveOrZero(message = "Las horas de estad√≠a no pueden ser negativas")
    private BigDecimal horasEstadiaTotales;

    @PositiveOrZero(message = "Los costos adicionales no pueden ser negativos")
    private BigDecimal costosAdicionales;

    @Data
    @Builder
    @NoArgsConstructor
    @AllArgsConstructor
    public static class TramoRequest {

        @NotNull(message = "El ID del tramo es obligatorio")
        private Long tramoId;

        @NotNull(message = "La distancia es obligatoria")
        @Positive(message = "La distancia debe ser positiva")
        private BigDecimal distanciaKm;

        @NotNull(message = "El costo base por km es obligatorio")
        @Positive(message = "El costo base por km debe ser positivo")
        private BigDecimal costoBasePorKm;

        @NotNull(message = "El consumo de combustible es obligatorio")
        @Positive(message = "El consumo de combustible debe ser positivo")
        private BigDecimal consumoKmLitro;
    }
}



==================================================
RUTH: billing-service/src/main/java/com/transportes/billing/dto/CostoEstimadoDTO.java
==================================================
package com.transportes.billing.dto;

import lombok.*;
import java.math.BigDecimal;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class CostoEstimadoDTO {
    private BigDecimal costoGestion;
    private BigDecimal costoTramos;
    private BigDecimal costoKilometros;
    private BigDecimal costoCombustible;
    private BigDecimal costoEstadia;
    private BigDecimal costoTotal;
}



==================================================
RUTH: billing-service/src/main/java/com/transportes/billing/dto/CostoSolicitudDTO.java
==================================================
package com.transportes.billing.dto;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.List;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class CostoSolicitudDTO {

    private Long id;

    private Long solicitudId;

    private String tipo;

    private BigDecimal costoGestion;

    private BigDecimal costoTransporte;

    private BigDecimal costoCombustible;

    private BigDecimal costoEstadia;

    private BigDecimal costoAdicionales;

    private BigDecimal costoTotal;

    private Long tarifaBaseId;

    private Long tarifaCombustibleId;

    private Long tarifaEstadiaId;

    private LocalDateTime fechaCalculo;

    private String observaciones;

    private List<CostoTramoDTO> costosTramos;
}



==================================================
RUTH: billing-service/src/main/java/com/transportes/billing/dto/CostoTramoDTO.java
==================================================
package com.transportes.billing.dto;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.math.BigDecimal;
import java.time.LocalDateTime;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class CostoTramoDTO {

    private Long id;

    private Long tramoId;

    private String tipo;

    private BigDecimal distanciaKm;

    private BigDecimal costoPorKm;

    private BigDecimal costoCombustible;

    private BigDecimal costoEstadia;

    private BigDecimal horasEstadia;

    private BigDecimal costoTotalTramo;

    private LocalDateTime fechaCalculo;
}



==================================================
RUTH: billing-service/src/main/java/com/transportes/billing/dto/TarifaBaseDTO.java
==================================================
package com.transportes.billing.dto;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Positive;
import jakarta.validation.constraints.Size;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.math.BigDecimal;
import java.time.LocalDate;
import java.time.LocalDateTime;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class TarifaBaseDTO {

    private Long id;

    @NotBlank(message = "El nombre es obligatorio")
    @Size(max = 100, message = "El nombre no puede superar los 100 caracteres")
    private String nombre;

    @Size(max = 500, message = "La descripci√≥n no puede superar los 500 caracteres")
    private String descripcion;

    @NotNull(message = "El costo fijo de gesti√≥n es obligatorio")
    @Positive(message = "El costo fijo de gesti√≥n debe ser positivo")
    private BigDecimal costoFijoGestion;

    @Positive(message = "El costo adicional por tramo debe ser positivo")
    private BigDecimal costoAdicionalPorTramo;

    @NotNull(message = "La fecha de vigencia desde es obligatoria")
    private LocalDate fechaVigenciaDesde;

    private LocalDate fechaVigenciaHasta;

    private Boolean activa;

    private LocalDateTime fechaCreacion;
}



==================================================
RUTH: billing-service/src/main/java/com/transportes/billing/dto/TarifaCombustibleDTO.java
==================================================
package com.transportes.billing.dto;

import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Positive;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.math.BigDecimal;
import java.time.LocalDate;
import java.time.LocalDateTime;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class TarifaCombustibleDTO {

    private Long id;

    @NotNull(message = "El precio por litro es obligatorio")
    @Positive(message = "El precio por litro debe ser positivo")
    private BigDecimal precioPorLitro;

    @NotNull(message = "La fecha de vigencia desde es obligatoria")
    private LocalDate fechaVigenciaDesde;

    private LocalDate fechaVigenciaHasta;

    private Boolean activa;

    private LocalDateTime fechaCreacion;
}



==================================================
RUTH: billing-service/src/main/java/com/transportes/billing/dto/TarifaEstadiaDTO.java
==================================================
package com.transportes.billing.dto;

import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Positive;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.math.BigDecimal;
import java.time.LocalDate;
import java.time.LocalDateTime;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class TarifaEstadiaDTO {

    private Long id;

    @NotNull(message = "El costo por d√≠a es obligatorio")
    @Positive(message = "El costo por d√≠a debe ser positivo")
    private BigDecimal costoPorDia;

    @NotNull(message = "El costo por hora es obligatorio")
    @Positive(message = "El costo por hora debe ser positivo")
    private BigDecimal costoPorHora;

    @NotNull(message = "La fecha de vigencia desde es obligatoria")
    private LocalDate fechaVigenciaDesde;

    private LocalDate fechaVigenciaHasta;

    private Boolean activa;

    private LocalDateTime fechaCreacion;
}



==================================================
RUTH: billing-service/src/main/java/com/transportes/billing/dto/TarifaPesoVolumenDTO.java
==================================================
package com.transportes.billing.dto;

import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Positive;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.math.BigDecimal;
import java.time.LocalDate;
import java.time.LocalDateTime;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class TarifaPesoVolumenDTO {

    private Long id;

    @NotNull(message = "El peso m√≠nimo es obligatorio")
    @Positive(message = "El peso m√≠nimo debe ser positivo")
    private BigDecimal pesoMinimoKg;

    @NotNull(message = "El peso m√°ximo es obligatorio")
    @Positive(message = "El peso m√°ximo debe ser positivo")
    private BigDecimal pesoMaximoKg;

    @NotNull(message = "El volumen m√≠nimo es obligatorio")
    @Positive(message = "El volumen m√≠nimo debe ser positivo")
    private BigDecimal volumenMinimoM3;

    @NotNull(message = "El volumen m√°ximo es obligatorio")
    @Positive(message = "El volumen m√°ximo debe ser positivo")
    private BigDecimal volumenMaximoM3;

    @Positive(message = "El multiplicador de costo debe ser positivo")
    private BigDecimal multiplicadorCosto;

    @NotNull(message = "La fecha de vigencia desde es obligatoria")
    private LocalDate fechaVigenciaDesde;

    private LocalDate fechaVigenciaHasta;

    private Boolean activa;

    private LocalDateTime fechaCreacion;
}



==================================================
RUTH: billing-service/src/main/java/com/transportes/billing/entity/CostoSolicitud.java
==================================================
package com.transportes.billing.entity;

import jakarta.persistence.*;
import lombok.*;
import org.hibernate.annotations.CreationTimestamp;

import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;

@Entity
@Table(name = "costo_solicitud")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class CostoSolicitud {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = "solicitud_id", nullable = false)
    private Long solicitudId;

    @Enumerated(EnumType.STRING)
    @Column(nullable = false, length = 20)
    private TipoCosto tipo;

    // Costos desglosados
    @Column(name = "costo_gestion", precision = 10, scale = 2)
    private BigDecimal costoGestion;

    @Column(name = "costo_transporte", precision = 10, scale = 2)
    private BigDecimal costoTransporte;

    @Column(name = "costo_combustible", precision = 10, scale = 2)
    private BigDecimal costoCombustible;

    @Column(name = "costo_estadia", precision = 10, scale = 2)
    private BigDecimal costoEstadia;

    @Column(name = "costo_adicionales", precision = 10, scale = 2)
    private BigDecimal costoAdicionales;

    // Total
    @Column(name = "costo_total", nullable = false, precision = 12, scale = 2)
    private BigDecimal costoTotal;

    // Referencias a tarifas usadas
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "tarifa_base_id")
    private TarifaBase tarifaBase;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "tarifa_combustible_id")
    private TarifaCombustible tarifaCombustible;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "tarifa_estadia_id")
    private TarifaEstadia tarifaEstadia;

    @CreationTimestamp
    @Column(name = "fecha_calculo", updatable = false)
    private LocalDateTime fechaCalculo;

    @Column(columnDefinition = "TEXT")
    private String observaciones;

    @OneToMany(mappedBy = "costoSolicitud", cascade = CascadeType.ALL, orphanRemoval = true)
    @Builder.Default
    private List<CostoTramo> costosTramos = new ArrayList<>();

    public enum TipoCosto {
        ESTIMADO, FINAL
    }

    // Helper methods
    public void agregarCostoTramo(CostoTramo costoTramo) {
        costosTramos.add(costoTramo);
        costoTramo.setCostoSolicitud(this);
    }
}



==================================================
RUTH: billing-service/src/main/java/com/transportes/billing/entity/CostoTramo.java
==================================================
package com.transportes.billing.entity;

import jakarta.persistence.*;
import lombok.*;
import org.hibernate.annotations.CreationTimestamp;

import java.math.BigDecimal;
import java.time.LocalDateTime;

@Entity
@Table(name = "costo_tramo")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class CostoTramo {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = "tramo_id", nullable = false)
    private Long tramoId;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "costo_solicitud_id", nullable = false)
    private CostoSolicitud costoSolicitud;

    @Enumerated(EnumType.STRING)
    @Column(nullable = false, length = 20)
    private TipoCostoTramo tipo;

    // Costos del tramo
    @Column(name = "distancia_km", nullable = false, precision = 10, scale = 2)
    private BigDecimal distanciaKm;

    @Column(name = "costo_por_km", nullable = false, precision = 8, scale = 2)
    private BigDecimal costoPorKm;

    @Column(name = "costo_combustible", precision = 10, scale = 2)
    private BigDecimal costoCombustible;

    @Column(name = "costo_estadia", precision = 10, scale = 2)
    private BigDecimal costoEstadia;

    @Column(name = "horas_estadia", precision = 8, scale = 2)
    private BigDecimal horasEstadia;

    // Total del tramo
    @Column(name = "costo_total_tramo", nullable = false, precision = 10, scale = 2)
    private BigDecimal costoTotalTramo;

    @CreationTimestamp
    @Column(name = "fecha_calculo", updatable = false)
    private LocalDateTime fechaCalculo;

    public enum TipoCostoTramo {
        ESTIMADO, REAL
    }
}



==================================================
RUTH: billing-service/src/main/java/com/transportes/billing/entity/TarifaBase.java
==================================================
package com.transportes.billing.entity;

import jakarta.persistence.*;
import lombok.*;
import org.hibernate.annotations.CreationTimestamp;

import java.math.BigDecimal;
import java.time.LocalDate;
import java.time.LocalDateTime;

@Entity
@Table(name = "tarifa_base")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class TarifaBase {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false, length = 100)
    private String nombre;

    @Column(columnDefinition = "TEXT")
    private String descripcion;

    @Column(name = "costo_fijo_gestion", nullable = false, precision = 10, scale = 2)
    private BigDecimal costoFijoGestion;

    @Column(name = "costo_adicional_por_tramo", precision = 10, scale = 2)
    private BigDecimal costoAdicionalPorTramo;

    @Column(name = "fecha_vigencia_desde", nullable = false)
    private LocalDate fechaVigenciaDesde;

    @Column(name = "fecha_vigencia_hasta")
    private LocalDate fechaVigenciaHasta;

    @Column(nullable = false)
    private Boolean activa = true;

    @CreationTimestamp
    @Column(name = "fecha_creacion", updatable = false)
    private LocalDateTime fechaCreacion;
}



==================================================
RUTH: billing-service/src/main/java/com/transportes/billing/entity/TarifaCombustible.java
==================================================
package com.transportes.billing.entity;

import jakarta.persistence.*;
import lombok.*;
import org.hibernate.annotations.CreationTimestamp;

import java.math.BigDecimal;
import java.time.LocalDate;
import java.time.LocalDateTime;

@Entity
@Table(name = "tarifa_combustible")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class TarifaCombustible {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = "precio_por_litro", nullable = false, precision = 8, scale = 2)
    private BigDecimal precioPorLitro;

    @Column(name = "fecha_vigencia_desde", nullable = false)
    private LocalDate fechaVigenciaDesde;

    @Column(name = "fecha_vigencia_hasta")
    private LocalDate fechaVigenciaHasta;

    @Column(nullable = false)
    private Boolean activa = true;

    @CreationTimestamp
    @Column(name = "fecha_creacion", updatable = false)
    private LocalDateTime fechaCreacion;
}



==================================================
RUTH: billing-service/src/main/java/com/transportes/billing/entity/TarifaEstadia.java
==================================================
package com.transportes.billing.entity;

import jakarta.persistence.*;
import lombok.*;
import org.hibernate.annotations.CreationTimestamp;

import java.math.BigDecimal;
import java.time.LocalDate;
import java.time.LocalDateTime;

@Entity
@Table(name = "tarifa_estadia")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class TarifaEstadia {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = "costo_por_dia", nullable = false, precision = 10, scale = 2)
    private BigDecimal costoPorDia;

    @Column(name = "costo_por_hora", nullable = false, precision = 8, scale = 2)
    private BigDecimal costoPorHora;

    @Column(name = "fecha_vigencia_desde", nullable = false)
    private LocalDate fechaVigenciaDesde;

    @Column(name = "fecha_vigencia_hasta")
    private LocalDate fechaVigenciaHasta;

    @Column(nullable = false)
    private Boolean activa = true;

    @CreationTimestamp
    @Column(name = "fecha_creacion", updatable = false)
    private LocalDateTime fechaCreacion;
}



==================================================
RUTH: billing-service/src/main/java/com/transportes/billing/entity/TarifaPesoVolumen.java
==================================================
package com.transportes.billing.entity;

import jakarta.persistence.*;
import lombok.*;
import org.hibernate.annotations.CreationTimestamp;

import java.math.BigDecimal;
import java.time.LocalDate;
import java.time.LocalDateTime;

@Entity
@Table(name = "tarifa_peso_volumen")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class TarifaPesoVolumen {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = "peso_minimo_kg", nullable = false, precision = 10, scale = 2)
    private BigDecimal pesoMinimoKg;

    @Column(name = "peso_maximo_kg", nullable = false, precision = 10, scale = 2)
    private BigDecimal pesoMaximoKg;

    @Column(name = "volumen_minimo_m3", nullable = false, precision = 10, scale = 2)
    private BigDecimal volumenMinimoM3;

    @Column(name = "volumen_maximo_m3", nullable = false, precision = 10, scale = 2)
    private BigDecimal volumenMaximoM3;

    @Column(name = "multiplicador_costo", precision = 5, scale = 2)
    private BigDecimal multiplicadorCosto;

    @Column(name = "fecha_vigencia_desde", nullable = false)
    private LocalDate fechaVigenciaDesde;

    @Column(name = "fecha_vigencia_hasta")
    private LocalDate fechaVigenciaHasta;

    @Column(nullable = false)
    private Boolean activa = true;

    @CreationTimestamp
    @Column(name = "fecha_creacion", updatable = false)
    private LocalDateTime fechaCreacion;
}



==================================================
RUTH: billing-service/src/main/java/com/transportes/billing/repository/CostoSolicitudRepository.java
==================================================
package com.transportes.billing.repository;

import com.transportes.billing.entity.CostoSolicitud;
import org.springframework.data.jpa.repository.JpaRepository;
import java.util.List;
import java.util.Optional;

public interface CostoSolicitudRepository extends JpaRepository<CostoSolicitud, Long> {
    List<CostoSolicitud> findBySolicitudIdOrderByFechaCalculoDesc(Long solicitudId);
    Optional<CostoSolicitud> findBySolicitudIdAndTipo(Long solicitudId, CostoSolicitud.TipoCosto tipo);
}



==================================================
RUTH: billing-service/src/main/java/com/transportes/billing/repository/CostoTramoRepository.java
==================================================
package com.transportes.billing.repository;

import com.transportes.billing.entity.CostoTramo;
import org.springframework.data.jpa.repository.JpaRepository;
import java.util.List;

public interface CostoTramoRepository extends JpaRepository<CostoTramo, Long> {
    List<CostoTramo> findByTramoIdOrderByFechaCalculoDesc(Long tramoId);
}



==================================================
RUTH: billing-service/src/main/java/com/transportes/billing/repository/TarifaBaseRepository.java
==================================================
package com.transportes.billing.repository;

import com.transportes.billing.entity.TarifaBase;
import org.springframework.data.jpa.repository.JpaRepository;
import java.util.Optional;

public interface TarifaBaseRepository extends JpaRepository<TarifaBase, Long> {
    Optional<TarifaBase> findFirstByActivaTrueOrderByFechaVigenciaDesdeDesc();
}



==================================================
RUTH: billing-service/src/main/java/com/transportes/billing/repository/TarifaCombustibleRepository.java
==================================================
package com.transportes.billing.repository;

import com.transportes.billing.entity.TarifaCombustible;
import org.springframework.data.jpa.repository.JpaRepository;
import java.util.Optional;

public interface TarifaCombustibleRepository extends JpaRepository<TarifaCombustible, Long> {
    Optional<TarifaCombustible> findFirstByActivaTrueOrderByFechaVigenciaDesdeDesc();
}



==================================================
RUTH: billing-service/src/main/java/com/transportes/billing/repository/TarifaEstadiaRepository.java
==================================================
package com.transportes.billing.repository;

import com.transportes.billing.entity.TarifaEstadia;
import org.springframework.data.jpa.repository.JpaRepository;
import java.util.Optional;

public interface TarifaEstadiaRepository extends JpaRepository<TarifaEstadia, Long> {
    Optional<TarifaEstadia> findFirstByActivaTrueOrderByFechaVigenciaDesdeDesc();
}



==================================================
RUTH: billing-service/src/main/java/com/transportes/billing/repository/TarifaPesoVolumenRepository.java
==================================================
package com.transportes.billing.repository;

import com.transportes.billing.entity.TarifaPesoVolumen;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import java.math.BigDecimal;
import java.util.Optional;

public interface TarifaPesoVolumenRepository extends JpaRepository<TarifaPesoVolumen, Long> {
    @Query("SELECT t FROM TarifaPesoVolumen t WHERE t.activa = true " +
           "AND :peso BETWEEN t.pesoMinimoKg AND t.pesoMaximoKg " +
           "AND :volumen BETWEEN t.volumenMinimoM3 AND t.volumenMaximoM3 " +
           "ORDER BY t.fechaVigenciaDesde DESC")
    Optional<TarifaPesoVolumen> findByPesoYVolumen(@Param("peso") BigDecimal peso,
                                                     @Param("volumen") BigDecimal volumen);
}



==================================================
RUTH: billing-service/src/main/java/com/transportes/billing/service/CostoService.java
==================================================
package com.transportes.billing.service;

import com.transportes.billing.entity.*;
import com.transportes.billing.repository.*;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import java.math.BigDecimal;
import java.math.RoundingMode;
import java.util.List;

@Slf4j
@Service
@RequiredArgsConstructor
public class CostoService {

    private final TarifaBaseRepository tarifaBaseRepository;
    private final TarifaCombustibleRepository tarifaCombustibleRepository;
    private final TarifaEstadiaRepository tarifaEstadiaRepository;
    private final TarifaPesoVolumenRepository tarifaPesoVolumenRepository;
    private final CostoSolicitudRepository costoSolicitudRepository;
    private final CostoTramoRepository costoTramoRepository;

    /**
     * Calcula el costo estimado de una solicitud y lo PERSISTE en la base de datos
     */
    @Transactional
    public CostoSolicitud calcularCostoEstimado(
            Long solicitudId,
            List<TramoInfo> tramos,
            BigDecimal pesoTotalKg,
            BigDecimal volumenTotalM3,
            Integer diasEstadiaEstimados) {

        log.info("Calculando costo ESTIMADO para solicitud {}", solicitudId);

        // Obtener tarifas vigentes
        TarifaBase tarifaBase = obtenerTarifaBaseVigente();
        TarifaCombustible tarifaCombustible = obtenerTarifaCombustibleVigente();
        TarifaEstadia tarifaEstadia = obtenerTarifaEstadiaVigente();

        // Obtener multiplicador por peso y volumen
        BigDecimal multiplicador = obtenerMultiplicadorPesoVolumen(pesoTotalKg, volumenTotalM3);

        // Crear entidad CostoSolicitud
        CostoSolicitud costoSolicitud = CostoSolicitud.builder()
                .solicitudId(solicitudId)
                .tipo(CostoSolicitud.TipoCosto.ESTIMADO)
                .tarifaBase(tarifaBase)
                .tarifaCombustible(tarifaCombustible)
                .tarifaEstadia(tarifaEstadia)
                .build();

        // Calcular costo de gesti√≥n
        BigDecimal costoGestion = tarifaBase.getCostoFijoGestion();

        // Calcular costos de tramos
        BigDecimal costoTransporte = BigDecimal.ZERO;
        BigDecimal costoCombustible = BigDecimal.ZERO;

        for (TramoInfo tramoInfo : tramos) {
            CostoTramo costoTramo = calcularCostoTramo(
                    tramoInfo,
                    tarifaBase,
                    tarifaCombustible,
                    multiplicador,
                    CostoTramo.TipoCostoTramo.ESTIMADO
            );

            costoSolicitud.agregarCostoTramo(costoTramo);
            costoTransporte = costoTransporte.add(costoTramo.getCostoPorKm().multiply(costoTramo.getDistanciaKm()));
            costoCombustible = costoCombustible.add(costoTramo.getCostoCombustible());
        }

        // Calcular costo de estad√≠a
        BigDecimal costoEstadia = calcularCostoEstadia(diasEstadiaEstimados, tarifaEstadia);

        // Asignar costos desglosados
        costoSolicitud.setCostoGestion(costoGestion);
        costoSolicitud.setCostoTransporte(costoTransporte);
        costoSolicitud.setCostoCombustible(costoCombustible);
        costoSolicitud.setCostoEstadia(costoEstadia);
        costoSolicitud.setCostoAdicionales(BigDecimal.ZERO);

        // Calcular costo total
        BigDecimal costoTotal = costoGestion
                .add(costoTransporte)
                .add(costoCombustible)
                .add(costoEstadia)
                .setScale(2, RoundingMode.HALF_UP);

        costoSolicitud.setCostoTotal(costoTotal);

        // PERSISTIR en base de datos
        CostoSolicitud costoGuardado = costoSolicitudRepository.save(costoSolicitud);

        log.info("Costo ESTIMADO guardado con ID: {} para solicitud {}", costoGuardado.getId(), solicitudId);

        return costoGuardado;
    }

    /**
     * Calcula el costo REAL/FINAL de una solicitud basado en datos reales y lo PERSISTE
     */
    @Transactional
    public CostoSolicitud calcularCostoReal(
            Long solicitudId,
            List<TramoInfo> tramosReales,
            BigDecimal pesoRealKg,
            BigDecimal volumenRealM3,
            BigDecimal horasEstadiaTotales,
            BigDecimal costosAdicionales) {

        log.info("Calculando costo REAL/FINAL para solicitud {}", solicitudId);

        // Obtener tarifas vigentes
        TarifaBase tarifaBase = obtenerTarifaBaseVigente();
        TarifaCombustible tarifaCombustible = obtenerTarifaCombustibleVigente();
        TarifaEstadia tarifaEstadia = obtenerTarifaEstadiaVigente();

        // Obtener multiplicador por peso y volumen
        BigDecimal multiplicador = obtenerMultiplicadorPesoVolumen(pesoRealKg, volumenRealM3);

        // Crear entidad CostoSolicitud FINAL
        CostoSolicitud costoSolicitud = CostoSolicitud.builder()
                .solicitudId(solicitudId)
                .tipo(CostoSolicitud.TipoCosto.FINAL)
                .tarifaBase(tarifaBase)
                .tarifaCombustible(tarifaCombustible)
                .tarifaEstadia(tarifaEstadia)
                .build();

        // Calcular costo de gesti√≥n
        BigDecimal costoGestion = tarifaBase.getCostoFijoGestion();

        // Calcular costos de tramos REALES
        BigDecimal costoTransporte = BigDecimal.ZERO;
        BigDecimal costoCombustible = BigDecimal.ZERO;

        for (TramoInfo tramoInfo : tramosReales) {
            CostoTramo costoTramo = calcularCostoTramo(
                    tramoInfo,
                    tarifaBase,
                    tarifaCombustible,
                    multiplicador,
                    CostoTramo.TipoCostoTramo.REAL
            );

            costoSolicitud.agregarCostoTramo(costoTramo);
            costoTransporte = costoTransporte.add(costoTramo.getCostoPorKm().multiply(costoTramo.getDistanciaKm()));
            costoCombustible = costoCombustible.add(costoTramo.getCostoCombustible());
        }

        // Calcular costo de estad√≠a REAL basado en horas
        BigDecimal costoEstadia = BigDecimal.ZERO;
        if (horasEstadiaTotales != null && horasEstadiaTotales.compareTo(BigDecimal.ZERO) > 0) {
            costoEstadia = tarifaEstadia.getCostoPorHora()
                    .multiply(horasEstadiaTotales)
                    .setScale(2, RoundingMode.HALF_UP);
        }

        // Asignar costos desglosados
        costoSolicitud.setCostoGestion(costoGestion);
        costoSolicitud.setCostoTransporte(costoTransporte);
        costoSolicitud.setCostoCombustible(costoCombustible);
        costoSolicitud.setCostoEstadia(costoEstadia);
        costoSolicitud.setCostoAdicionales(costosAdicionales != null ? costosAdicionales : BigDecimal.ZERO);

        // Calcular costo total
        BigDecimal costoTotal = costoGestion
                .add(costoTransporte)
                .add(costoCombustible)
                .add(costoEstadia)
                .add(costoSolicitud.getCostoAdicionales())
                .setScale(2, RoundingMode.HALF_UP);

        costoSolicitud.setCostoTotal(costoTotal);

        // PERSISTIR en base de datos
        CostoSolicitud costoGuardado = costoSolicitudRepository.save(costoSolicitud);

        log.info("Costo FINAL guardado con ID: {} para solicitud {}", costoGuardado.getId(), solicitudId);

        return costoGuardado;
    }

    /**
     * Obtiene el costo estimado de una solicitud
     */
    public CostoSolicitud obtenerCostoEstimado(Long solicitudId) {
        return costoSolicitudRepository.findBySolicitudIdAndTipo(solicitudId, CostoSolicitud.TipoCosto.ESTIMADO)
                .orElseThrow(() -> new RuntimeException("No se encontr√≥ costo estimado para la solicitud " + solicitudId));
    }

    /**
     * Obtiene el costo final de una solicitud
     */
    public CostoSolicitud obtenerCostoFinal(Long solicitudId) {
        return costoSolicitudRepository.findBySolicitudIdAndTipo(solicitudId, CostoSolicitud.TipoCosto.FINAL)
                .orElseThrow(() -> new RuntimeException("No se encontr√≥ costo final para la solicitud " + solicitudId));
    }

    /**
     * Obtiene todos los costos de una solicitud
     */
    public List<CostoSolicitud> obtenerCostosSolicitud(Long solicitudId) {
        return costoSolicitudRepository.findBySolicitudIdOrderByFechaCalculoDesc(solicitudId);
    }

    // ============= METODOS PRIVADOS AUXILIARES =============

    private CostoTramo calcularCostoTramo(
            TramoInfo tramoInfo,
            TarifaBase tarifaBase,
            TarifaCombustible tarifaCombustible,
            BigDecimal multiplicador,
            CostoTramo.TipoCostoTramo tipo) {

        // Calcular costo por km del tramo (con multiplicador)
        BigDecimal costoPorKm = tramoInfo.getCostoBasePorKm().multiply(multiplicador);

        // Calcular costo de combustible del tramo
        BigDecimal litrosNecesarios = tramoInfo.getDistanciaKm()
                .divide(tramoInfo.getConsumoKmLitro(), 2, RoundingMode.HALF_UP);
        BigDecimal costoCombustible = litrosNecesarios.multiply(tarifaCombustible.getPrecioPorLitro());

        // Calcular costo adicional por tramo
        BigDecimal costoAdicionalTramo = tarifaBase.getCostoAdicionalPorTramo() != null
                ? tarifaBase.getCostoAdicionalPorTramo()
                : BigDecimal.ZERO;

        // Calcular costo total del tramo
        BigDecimal costoTotalTramo = costoPorKm.multiply(tramoInfo.getDistanciaKm())
                .add(costoCombustible)
                .add(costoAdicionalTramo)
                .setScale(2, RoundingMode.HALF_UP);

        return CostoTramo.builder()
                .tramoId(tramoInfo.getTramoId())
                .tipo(tipo)
                .distanciaKm(tramoInfo.getDistanciaKm())
                .costoPorKm(costoPorKm)
                .costoCombustible(costoCombustible)
                .costoEstadia(BigDecimal.ZERO)
                .horasEstadia(BigDecimal.ZERO)
                .costoTotalTramo(costoTotalTramo)
                .build();
    }

    private BigDecimal calcularCostoEstadia(Integer diasEstimados, TarifaEstadia tarifaEstadia) {
        if (diasEstimados == null || diasEstimados <= 0) {
            return BigDecimal.ZERO;
        }

        return tarifaEstadia.getCostoPorDia()
                .multiply(BigDecimal.valueOf(diasEstimados))
                .setScale(2, RoundingMode.HALF_UP);
    }

    private BigDecimal obtenerMultiplicadorPesoVolumen(BigDecimal peso, BigDecimal volumen) {
        if (peso == null || volumen == null) {
            return BigDecimal.ONE;
        }

        return tarifaPesoVolumenRepository.findByPesoYVolumen(peso, volumen)
                .map(TarifaPesoVolumen::getMultiplicadorCosto)
                .orElse(BigDecimal.ONE);
    }

    private TarifaBase obtenerTarifaBaseVigente() {
        return tarifaBaseRepository.findFirstByActivaTrueOrderByFechaVigenciaDesdeDesc()
                .orElseThrow(() -> new RuntimeException("No hay tarifa base vigente"));
    }

    private TarifaCombustible obtenerTarifaCombustibleVigente() {
        return tarifaCombustibleRepository.findFirstByActivaTrueOrderByFechaVigenciaDesdeDesc()
                .orElseThrow(() -> new RuntimeException("No hay tarifa de combustible vigente"));
    }

    private TarifaEstadia obtenerTarifaEstadiaVigente() {
        return tarifaEstadiaRepository.findFirstByActivaTrueOrderByFechaVigenciaDesdeDesc()
                .orElseThrow(() -> new RuntimeException("No hay tarifa de estad√≠a vigente"));
    }

    // ============= CLASE AUXILIAR =============

    /**
     * Informaci√≥n de un tramo para calcular su costo
     */
    public static class TramoInfo {
        private Long tramoId;
        private BigDecimal distanciaKm;
        private BigDecimal costoBasePorKm;
        private BigDecimal consumoKmLitro;

        public TramoInfo(Long tramoId, BigDecimal distanciaKm, BigDecimal costoBasePorKm, BigDecimal consumoKmLitro) {
            this.tramoId = tramoId;
            this.distanciaKm = distanciaKm;
            this.costoBasePorKm = costoBasePorKm;
            this.consumoKmLitro = consumoKmLitro;
        }

        public Long getTramoId() {
            return tramoId;
        }

        public BigDecimal getDistanciaKm() {
            return distanciaKm;
        }

        public BigDecimal getCostoBasePorKm() {
            return costoBasePorKm;
        }

        public BigDecimal getConsumoKmLitro() {
            return consumoKmLitro;
        }
    }
}



==================================================
RUTH: billing-service/src/main/resources/application-docker.yml
==================================================
spring:
  datasource:
    url: jdbc:postgresql://postgres-billing:5432/billing_db
    username: billing_user
    password: billing_pass

  security:
    oauth2:
      resourceserver:
        jwt:
          jwk-set-uri: http://keycloak:8080/realms/transportes-realm/protocol/openid-connect/certs

keycloak:
  auth-server-url: http://keycloak:8080



==================================================
RUTH: billing-service/src/main/resources/application.yml
==================================================
spring:
  application:
    name: billing-service
  
  datasource:
    url: jdbc:postgresql://localhost:5434/billing_db
    username: billing_user
    password: billing_pass
    driver-class-name: org.postgresql.Driver
  
  jpa:
    hibernate:
      ddl-auto: validate
    show-sql: true
    properties:
      hibernate:
        format_sql: true
        dialect: org.hibernate.dialect.PostgreSQLDialect
  
  security:
    oauth2:
      resourceserver:
        jwt:
          jwk-set-uri: http://localhost:8180/realms/transportes-realm/protocol/openid-connect/certs

server:
  port: 8083

management:
  endpoints:
    web:
      exposure:
        include: health,info,metrics

springdoc:
  api-docs:
    path: /v3/api-docs
  swagger-ui:
    path: /swagger-ui.html

logging:
  level:
    com.transportes.billing: DEBUG



==================================================
RUTH: clients-service/Dockerfile
==================================================
# Usamos solo una etapa - esperamos que el JAR ya est√© compilado
FROM eclipse-temurin:17-jre-alpine
WORKDIR /app

# Copiamos el JAR ya compilado desde el host
COPY target/clients-service-1.0.0.jar app.jar

EXPOSE 8081

ENTRYPOINT ["java", "-jar", "app.jar"]



==================================================
RUTH: clients-service/pom.xml
==================================================
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 
         http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <parent>
        <groupId>com.transportes</groupId>
        <artifactId>tpi-transportes</artifactId>
        <version>1.0.0</version>
    </parent>

    <artifactId>clients-service</artifactId>
    <name>Clients Service</name>
    <description>Microservicio para gesti√≥n de clientes, contenedores y solicitudes</description>

    <dependencies>
        <!-- Spring Boot Starters -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-jpa</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-validation</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-actuator</artifactId>
        </dependency>

        <!-- Spring Security + OAuth2 Resource Server -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-security</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-oauth2-resource-server</artifactId>
        </dependency>

        <!-- Spring Cloud OpenFeign -->
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-openfeign</artifactId>
        </dependency>

        <!-- Database -->
        <dependency>
            <groupId>org.postgresql</groupId>
            <artifactId>postgresql</artifactId>
            <scope>runtime</scope>
        </dependency>

        <!-- Lombok -->
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <optional>true</optional>
        </dependency>

        <!-- MapStruct -->
        <dependency>
            <groupId>org.mapstruct</groupId>
            <artifactId>mapstruct</artifactId>
        </dependency>

        <!-- Springdoc OpenAPI -->
        <dependency>
            <groupId>org.springdoc</groupId>
            <artifactId>springdoc-openapi-starter-webmvc-ui</artifactId>
        </dependency>

        <!-- Keycloak Admin Client (para registro de usuarios) -->
        <dependency>
            <groupId>org.keycloak</groupId>
            <artifactId>keycloak-admin-client</artifactId>
            <version>23.0.0</version>
        </dependency>

        <!-- Test -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>

        <dependency>
            <groupId>org.springframework.security</groupId>
            <artifactId>spring-security-test</artifactId>
            <scope>test</scope>
        </dependency>

        <dependency>
            <groupId>com.h2database</groupId>
            <artifactId>h2</artifactId>
            <scope>test</scope>
        </dependency>
    </dependencies>

    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
                <executions>
                    <execution>
                        <goals>
                            <goal>repackage</goal>
                        </goals>
                    </execution>
                </executions>
            </plugin>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
            </plugin>
        </plugins>
    </build>

</project>



==================================================
RUTH: clients-service/src/main/java/com/transportes/clients/ClientsServiceApplication.java
==================================================
package com.transportes.clients;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.openfeign.EnableFeignClients;
import com.transportes.clients.config.FeignClientConfig;

@SpringBootApplication

@EnableFeignClients(defaultConfiguration = FeignClientConfig.class)
public class ClientsServiceApplication {

    public static void main(String[] args) {
        SpringApplication.run(ClientsServiceApplication.class, args);
    }
}



==================================================
RUTH: clients-service/src/main/java/com/transportes/clients/client/LogisticsClient.java
==================================================
package com.transportes.clients.client;

import org.springframework.cloud.openfeign.FeignClient;
import org.springframework.web.bind.annotation.*;

import java.math.BigDecimal;
import java.util.List;

@FeignClient(name = "logistics-service", url = "${logistics.service.url}")
public interface LogisticsClient {

    @GetMapping("/api/rutas/alternativas/{solicitudId}")
    List<RutaDTO> generarRutasAlternativas(@PathVariable("solicitudId") Long solicitudId);

    record RutaDTO(
        Long id,
        Long solicitudId,
        String tipo,
        Integer cantidadTramos,
        Integer cantidadDepositos,
        BigDecimal distanciaTotalKm,
        Integer tiempoEstimadoHoras,
        BigDecimal costoEstimadoTotal,
        List<TramoDTO> tramos
    ) {}

    record TramoDTO(
        Long id,
        String tipoTramo,
        BigDecimal distanciaKm,
        String estado
    ) {}
}



==================================================
RUTH: clients-service/src/main/java/com/transportes/clients/config/FeignClientConfig.java
==================================================
package com.transportes.clients.config;

import feign.RequestInterceptor;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.http.HttpHeaders;
import org.springframework.web.context.request.RequestContextHolder;
import org.springframework.web.context.request.ServletRequestAttributes;

@Configuration
public class FeignClientConfig {
    @Bean
    public RequestInterceptor requestInterceptor() {
        return template -> {
            ServletRequestAttributes attributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();
            if (attributes != null) {
                String authHeader = attributes.getRequest().getHeader(HttpHeaders.AUTHORIZATION);
                if (authHeader != null) {
                    template.header(HttpHeaders.AUTHORIZATION, authHeader);
                }
            }
        };
    }
}


==================================================
RUTH: clients-service/src/main/java/com/transportes/clients/config/OpenApiConfig.java
==================================================
package com.transportes.clients.config;

import io.swagger.v3.oas.annotations.OpenAPIDefinition;
import io.swagger.v3.oas.annotations.enums.SecuritySchemeType;
import io.swagger.v3.oas.annotations.info.Contact;
import io.swagger.v3.oas.annotations.info.Info;
import io.swagger.v3.oas.annotations.security.SecurityScheme;
import io.swagger.v3.oas.annotations.servers.Server;
import org.springframework.context.annotation.Configuration;

@Configuration
@OpenAPIDefinition(
        info = @Info(
                title = "Clients Service API",
                version = "1.0.0",
                description = "API para gesti√≥n de clientes, contenedores y solicitudes de transporte",
                contact = @Contact(
                        name = "TPI Transportes",
                        email = "support@transportes.com"
                )
        ),
        servers = {
                @Server(url = "http://localhost:8081", description = "Local Server"),
                @Server(url = "http://localhost:8080", description = "Gateway")
        }
)
@SecurityScheme(
        name = "bearer-jwt",
        type = SecuritySchemeType.HTTP,
        scheme = "bearer",
        bearerFormat = "JWT"
)
public class OpenApiConfig {
}



==================================================
RUTH: clients-service/src/main/java/com/transportes/clients/config/SecurityConfig.java
==================================================
package com.transportes.clients.config;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.oauth2.jwt.JwtDecoder;
import org.springframework.security.oauth2.jwt.NimbusJwtDecoder;
import org.springframework.security.oauth2.server.resource.authentication.JwtAuthenticationConverter;
import org.springframework.security.oauth2.server.resource.authentication.JwtGrantedAuthoritiesConverter;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.core.convert.converter.Converter;
import org.springframework.security.oauth2.jwt.Jwt;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import java.util.Collection;
import java.util.Map;
import java.util.List;
import java.util.stream.Collectors;

@Configuration
@EnableWebSecurity
@EnableMethodSecurity
public class SecurityConfig {

    @Value("${spring.security.oauth2.resourceserver.jwt.jwk-set-uri}")
    private String jwkSetUri;

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
                .csrf(csrf -> csrf.disable())
                .authorizeHttpRequests(auth -> auth
                        // Endpoints p√∫blicos
                        .requestMatchers("/api/clientes/registro").permitAll()
                        .requestMatchers("/actuator/**").permitAll()
                        .requestMatchers("/swagger-ui/**", "/v3/api-docs/**").permitAll()
                        // Permitir crear solicitudes sin autenticaci√≥n
                        .requestMatchers("POST", "/api/solicitudes").permitAll()
                        // Endpoints internos para comunicaci√≥n entre microservicios
                        .requestMatchers("/api/solicitudes/internal/**").permitAll()
                        // Todos los dem√°s requieren autenticaci√≥n
                        .anyRequest().authenticated()
                )
                .oauth2ResourceServer(oauth2 -> oauth2
                        .jwt(jwt -> jwt
                                .decoder(jwtDecoder())
                                .jwtAuthenticationConverter(jwtAuthenticationConverter())
                        )
                )
                .sessionManagement(session -> session
                        .sessionCreationPolicy(SessionCreationPolicy.STATELESS)
                );

        return http.build();
    }

    @Bean
    public JwtDecoder jwtDecoder() {
        return NimbusJwtDecoder.withJwkSetUri(jwkSetUri).build();
    }

    @Bean
    public JwtAuthenticationConverter jwtAuthenticationConverter() {
        JwtAuthenticationConverter converter = new JwtAuthenticationConverter();
        converter.setJwtGrantedAuthoritiesConverter(new Converter<Jwt, Collection<GrantedAuthority>>() {
            @Override
            public Collection<GrantedAuthority> convert(Jwt jwt) {
                Map<String, Object> realmAccess = jwt.getClaim("realm_access");
                if (realmAccess == null || realmAccess.isEmpty()) {
                    return List.of();
                }

                @SuppressWarnings("unchecked")
                Collection<String> roles = (Collection<String>) realmAccess.get("roles");
                if (roles == null) {
                    return List.of();
                }

                return roles.stream()
                        .map(role -> new SimpleGrantedAuthority("ROLE_" + role))
                        .collect(Collectors.toList());
            }
        });
        return converter;
    }
}



==================================================
RUTH: clients-service/src/main/java/com/transportes/clients/controller/ClienteController.java
==================================================
package com.transportes.clients.controller;

import com.transportes.clients.dto.ClienteDTO;
import com.transportes.clients.dto.RegistroClienteRequest;
import com.transportes.clients.service.ClienteService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

@Tag(name = "Clientes", description = "API para gesti√≥n de clientes")
@RestController
@RequestMapping("/api/clientes")
@RequiredArgsConstructor
public class ClienteController {

    private final ClienteService clienteService;

    @Operation(summary = "Registrar nuevo cliente", description = "Registra un nuevo cliente en el sistema y en Keycloak")
    @PostMapping("/registro")
    public ResponseEntity<ClienteDTO> registrarCliente(@Valid @RequestBody RegistroClienteRequest request) {
        ClienteDTO cliente = clienteService.registrarCliente(request);
        return ResponseEntity.status(HttpStatus.CREATED).body(cliente);
    }

    @Operation(summary = "Obtener cliente por ID")
    @GetMapping("/{id}")
    public ResponseEntity<ClienteDTO> obtenerCliente(@PathVariable Long id) {
        ClienteDTO cliente = clienteService.obtenerPorId(id);
        return ResponseEntity.ok(cliente);
    }

    @Operation(summary = "Obtener cliente por email")
    @GetMapping("/email/{email}")
    public ResponseEntity<ClienteDTO> obtenerClientePorEmail(@PathVariable String email) {
        ClienteDTO cliente = clienteService.obtenerPorEmail(email);
        return ResponseEntity.ok(cliente);
    }
}



==================================================
RUTH: clients-service/src/main/java/com/transportes/clients/controller/ContenedorController.java
==================================================
package com.transportes.clients.controller;

import com.transportes.clients.dto.ContenedorDTO;
import com.transportes.clients.entity.Contenedor;
import com.transportes.clients.entity.Solicitud;
import com.transportes.clients.repository.SolicitudRepository;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.tags.Tag;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

import java.util.List;
import java.util.stream.Collectors;

@RestController
@RequestMapping("/api/contenedores")
@RequiredArgsConstructor
@PreAuthorize("hasRole('OPERADOR')")
@Tag(name = "Contenedores", description = "Gesti√≥n de contenedores")
public class ContenedorController {

    private final SolicitudRepository solicitudRepository;

    @GetMapping("/pendientes")
    @Operation(summary = "Consultar contenedores pendientes con filtros")
    public ResponseEntity<List<ContenedorDTO>> obtenerPendientes(
            @RequestParam(required = false) String estado,
            @RequestParam(required = false) Long depositoId) {

        List<Solicitud> solicitudes;

        if (estado != null) {
            try {
                Solicitud.EstadoSolicitud estadoEnum = Solicitud.EstadoSolicitud.valueOf(estado.toUpperCase());
                solicitudes = solicitudRepository.findByEstado(estadoEnum);
            } catch (IllegalArgumentException e) {
                return ResponseEntity.badRequest().build();
            }
        } else {
            // Estados pendientes: PROGRAMADA, EN_TRANSITO
            solicitudes = solicitudRepository.findPendientes();
        }

        List<ContenedorDTO> contenedores = solicitudes.stream()
                .map(Solicitud::getContenedor)
                .map(this::convertirADTO)
                .collect(Collectors.toList());

        return ResponseEntity.ok(contenedores);
    }

    @GetMapping("/{id}")
    @Operation(summary = "Obtener contenedor por ID")
    public ResponseEntity<ContenedorDTO> obtenerPorId(@PathVariable Long id) {
        return solicitudRepository.findByContenedorId(id)
                .map(Solicitud::getContenedor)
                .map(this::convertirADTO)
                .map(ResponseEntity::ok)
                .orElse(ResponseEntity.notFound().build());
    }

    private ContenedorDTO convertirADTO(Contenedor contenedor) {
        return ContenedorDTO.builder()
                .id(contenedor.getId())
                .codigo(contenedor.getCodigo())
                .pesoKg(contenedor.getPesoKg())
                .volumenM3(contenedor.getVolumenM3())
                .altoM(contenedor.getAltoM())
                .anchoM(contenedor.getAnchoM())
                .largoM(contenedor.getLargoM())
                .descripcion(contenedor.getDescripcion())
                .clienteId(contenedor.getCliente().getId())
                .build();
    }
}



==================================================
RUTH: clients-service/src/main/java/com/transportes/clients/controller/SolicitudController.java
==================================================
package com.transportes.clients.controller;

import com.transportes.clients.client.LogisticsClient;
import com.transportes.clients.dto.CrearSolicitudRequest;
import com.transportes.clients.dto.SeguimientoDTO;
import com.transportes.clients.dto.SolicitudDTO;
import com.transportes.clients.entity.Solicitud;
import com.transportes.clients.service.SolicitudService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.security.SecurityRequirement;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.security.core.Authentication;
import org.springframework.security.oauth2.jwt.Jwt;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@Tag(name = "Solicitudes", description = "API para gesti√≥n de solicitudes de transporte")
@RestController
@RequestMapping("/api/solicitudes")
@RequiredArgsConstructor
@SecurityRequirement(name = "bearer-jwt")
public class SolicitudController {

    private final SolicitudService solicitudService;
    private final LogisticsClient logisticsClient;

    @Operation(summary = "Crear nueva solicitud (con o sin autenticaci√≥n)")
    @PostMapping
    public ResponseEntity<SolicitudDTO> crearSolicitud(
            @Valid @RequestBody CrearSolicitudRequest request,
            Authentication authentication) {

        String userEmail = null;

        // Si est√° autenticado, obtener email del token
        if (authentication != null) {
            if (authentication.getPrincipal() instanceof Jwt) {
                Jwt jwt = (Jwt) authentication.getPrincipal();
                userEmail = jwt.getClaimAsString("email");
                if (userEmail == null) userEmail = authentication.getName();
            } else {
                userEmail = authentication.getName();
            }
        }

        SolicitudDTO solicitud = solicitudService.crearSolicitud(request, userEmail);
        return ResponseEntity.status(HttpStatus.CREATED).body(solicitud);
    }

    @Operation(summary = "Obtener solicitud por ID")
    @PreAuthorize("hasAnyRole('CLIENTE', 'OPERADOR')")
    @GetMapping("/{id}")
    public ResponseEntity<SolicitudDTO> obtenerSolicitud(
            @PathVariable("id") Long id,
            Authentication authentication) {

        String userEmail;
        if (authentication.getPrincipal() instanceof Jwt) {
            Jwt jwt = (Jwt) authentication.getPrincipal();
            userEmail = jwt.getClaimAsString("email");
            if (userEmail == null) userEmail = authentication.getName();
        } else {
            userEmail = authentication.getName();
        }

        SolicitudDTO solicitud = solicitudService.obtenerPorId(id, userEmail);
        return ResponseEntity.ok(solicitud);
    }


    @Operation(summary = "Obtener solicitud por ID (uso interno)")
    @GetMapping("/internal/{id}")
    public ResponseEntity<SolicitudDTO> obtenerSolicitudInternal(@PathVariable("id") Long id) {
        SolicitudDTO solicitud = solicitudService.obtenerPorIdInternal(id);
        return ResponseEntity.ok(solicitud);
    }


    @Operation(summary = "Obtener mis solicitudes")
    @PreAuthorize("hasRole('CLIENTE')")
    @GetMapping("/mis-solicitudes")
    public ResponseEntity<List<SolicitudDTO>> obtenerMisSolicitudes(Authentication authentication) {
        String userEmail;
        if (authentication.getPrincipal() instanceof Jwt) {
            Jwt jwt = (Jwt) authentication.getPrincipal();
            userEmail = jwt.getClaimAsString("email");
            if (userEmail == null) userEmail = authentication.getName();
        } else {
            userEmail = authentication.getName();
        }
        List<SolicitudDTO> solicitudes = solicitudService.obtenerSolicitudesDelCliente(userEmail);
        return ResponseEntity.ok(solicitudes);
    }

    @Operation(summary = "Obtener todas las solicitudes")
    @PreAuthorize("hasRole('OPERADOR')")
    @GetMapping
    public ResponseEntity<List<SolicitudDTO>> obtenerTodasLasSolicitudes() {
        return ResponseEntity.ok(solicitudService.obtenerTodasLasSolicitudes());
    }

    @Operation(summary = "Obtener solicitudes pendientes")
    @PreAuthorize("hasRole('OPERADOR')")
    @GetMapping("/pendientes")
    public ResponseEntity<List<SolicitudDTO>> obtenerSolicitudesPendientes() {
        return ResponseEntity.ok(solicitudService.obtenerSolicitudesPendientes());
    }

    @Operation(summary = "Obtener seguimiento de solicitud")
    @PreAuthorize("hasAnyRole('CLIENTE', 'OPERADOR')")
    @GetMapping("/{id}/seguimiento")
    public ResponseEntity<SeguimientoDTO> obtenerSeguimiento(
            @PathVariable("id") Long id,
            Authentication authentication) {

        String userEmail;
        if (authentication.getPrincipal() instanceof Jwt) {
            Jwt jwt = (Jwt) authentication.getPrincipal();
            userEmail = jwt.getClaimAsString("email");
            if (userEmail == null) userEmail = authentication.getName();
        } else {
            userEmail = authentication.getName();
        }

        SeguimientoDTO seguimiento = solicitudService.obtenerSeguimiento(id, userEmail);
        return ResponseEntity.ok(seguimiento);
    }

    @GetMapping("/{id}/rutas-alternativas")
    @PreAuthorize("hasAnyRole('CLIENTE', 'OPERADOR')")
    @Operation(summary = "Obtener rutas alternativas para solicitud")
    public ResponseEntity<List<LogisticsClient.RutaDTO>> obtenerRutasAlternativas(@PathVariable("id") Long id) {
        return ResponseEntity.ok(logisticsClient.generarRutasAlternativas(id));
    }

    @PutMapping("/{id}/estado")
    @PreAuthorize("hasRole('OPERADOR')")
    @Operation(summary = "Actualizar estado de solicitud")
    public ResponseEntity<Void> actualizarEstado(
            @PathVariable("id") Long id,
            @RequestBody ActualizarEstadoRequest request,
            Authentication authentication) {

        String userEmail = authentication.getName();
        Solicitud.EstadoSolicitud estado = Solicitud.EstadoSolicitud.valueOf(request.estado());
        solicitudService.actualizarEstado(id, estado, request.observacion(), userEmail);
        return ResponseEntity.ok().build();
    }

    record ActualizarEstadoRequest(String estado, String observacion) {}
}


==================================================
RUTH: clients-service/src/main/java/com/transportes/clients/dto/ClienteDTO.java
==================================================
package com.transportes.clients.dto;

import lombok.*;
import java.time.LocalDateTime;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class ClienteDTO {
    private Long id;
    private String nombre;
    private String apellido;
    private String email;
    private String telefono;
    private String direccion;
    private LocalDateTime fechaRegistro;
    private Boolean activo;
}



==================================================
RUTH: clients-service/src/main/java/com/transportes/clients/dto/ContenedorDTO.java
==================================================
package com.transportes.clients.dto;

import lombok.*;
import java.math.BigDecimal;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class ContenedorDTO {
    private Long id;
    private String codigo;
    private BigDecimal pesoKg;
    private BigDecimal volumenM3;
    private BigDecimal altoM;
    private BigDecimal anchoM;
    private BigDecimal largoM;
    private String descripcion;
    private Long clienteId;
}



==================================================
RUTH: clients-service/src/main/java/com/transportes/clients/dto/CrearSolicitudRequest.java
==================================================
package com.transportes.clients.dto;

import jakarta.validation.Valid;
import jakarta.validation.constraints.DecimalMin;
import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotNull;
import lombok.*;
import java.math.BigDecimal;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class CrearSolicitudRequest {

    @Valid
    @NotNull(message = "Los datos del contenedor son obligatorios")
    private ContenedorRequest contenedor;

    @Valid
    @NotNull(message = "El origen es obligatorio")
    private UbicacionDTO origen;

    @Valid
    @NotNull(message = "El destino es obligatorio")
    private UbicacionDTO destino;

    private String observaciones;

    // Datos del cliente (opcionales si ya est√° autenticado)
    private String nombre;
    private String apellido;

    @Email(message = "El email debe ser v√°lido")
    private String email;

    private String password;
    private String telefono;
    private String direccion;
    
    @Data
    @NoArgsConstructor
    @AllArgsConstructor
    @Builder
    public static class ContenedorRequest {
        
        @NotNull(message = "El peso es obligatorio")
        @DecimalMin(value = "0.01", message = "El peso debe ser mayor a 0")
        private BigDecimal pesoKg;
        
        @NotNull(message = "El volumen es obligatorio")
        @DecimalMin(value = "0.01", message = "El volumen debe ser mayor a 0")
        private BigDecimal volumenM3;
        
        private BigDecimal altoM;
        private BigDecimal anchoM;
        private BigDecimal largoM;
        private String descripcion;
    }
}



==================================================
RUTH: clients-service/src/main/java/com/transportes/clients/dto/RegistroClienteRequest.java
==================================================
package com.transportes.clients.dto;

import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Pattern;
import jakarta.validation.constraints.Size;
import lombok.*;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class RegistroClienteRequest {

    @NotBlank(message = "El nombre es obligatorio")
    @Size(min = 2, max = 100, message = "El nombre debe tener entre 2 y 100 caracteres")
    private String nombre;

    @NotBlank(message = "El apellido es obligatorio")
    @Size(min = 2, max = 100, message = "El apellido debe tener entre 2 y 100 caracteres")
    private String apellido;

    @NotBlank(message = "El email es obligatorio")
    @Email(message = "Email inv√°lido")
    @Size(max = 150, message = "El email no puede exceder 150 caracteres")
    private String email;

    @NotBlank(message = "La contrase√±a es obligatoria")
    @Size(min = 8, message = "La contrase√±a debe tener al menos 8 caracteres")
    @Pattern(regexp = "^(?=.*[A-Za-z])(?=.*\\d)(?=.*[@$!%*#?&])[A-Za-z\\d@$!%*#?&]{8,}$",
            message = "La contrase√±a debe contener al menos una letra, un n√∫mero y un car√°cter especial")
    private String password;

    @Pattern(regexp = "^\\+?[1-9]\\d{1,14}$", message = "Tel√©fono inv√°lido")
    @Size(max = 20, message = "El tel√©fono no puede exceder 20 caracteres")
    private String telefono;

    @Size(max = 255, message = "La direcci√≥n no puede exceder 255 caracteres")
    private String direccion;
}



==================================================
RUTH: clients-service/src/main/java/com/transportes/clients/dto/SeguimientoDTO.java
==================================================
package com.transportes.clients.dto;

import lombok.*;
import java.time.LocalDateTime;
import java.util.List;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class SeguimientoDTO {
    private Long solicitudId;
    private String numeroSolicitud;
    private String estadoActual;
    private List<EstadoHistorialDTO> historial;
    private UbicacionActualDTO ubicacionActual;
    
    @Data
    @NoArgsConstructor
    @AllArgsConstructor
    @Builder
    public static class EstadoHistorialDTO {
        private String estado;
        private LocalDateTime fechaHora;
        private String observacion;
    }
    
    @Data
    @NoArgsConstructor
    @AllArgsConstructor
    @Builder
    public static class UbicacionActualDTO {
        private String descripcion;
        private String tipo;
    }
}



==================================================
RUTH: clients-service/src/main/java/com/transportes/clients/dto/SolicitudDTO.java
==================================================
package com.transportes.clients.dto;

import com.transportes.clients.entity.Solicitud;
import lombok.*;
import java.math.BigDecimal;
import java.time.LocalDateTime;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class SolicitudDTO {
    private Long id;
    private String numeroSolicitud;
    private ContenedorDTO contenedor;
    private ClienteDTO cliente;
    private UbicacionDTO origen;
    private UbicacionDTO destino;
    private Solicitud.EstadoSolicitud estado;
    private BigDecimal costoEstimado;
    private Integer tiempoEstimadoHoras;
    private BigDecimal costoFinal;
    private Integer tiempoRealHoras;
    private Long rutaId;
    private LocalDateTime fechaCreacion;
    private LocalDateTime fechaUltimaActualizacion;
    private String observaciones;
}



==================================================
RUTH: clients-service/src/main/java/com/transportes/clients/dto/UbicacionDTO.java
==================================================
package com.transportes.clients.dto;

import jakarta.validation.constraints.DecimalMax;
import jakarta.validation.constraints.DecimalMin;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import lombok.*;
import java.math.BigDecimal;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class UbicacionDTO {
    
    private Long id;
    
    @NotBlank(message = "La direcci√≥n es obligatoria")
    private String direccion;
    
    @NotNull(message = "La latitud es obligatoria")
    @DecimalMin(value = "-90.0", message = "Latitud inv√°lida")
    @DecimalMax(value = "90.0", message = "Latitud inv√°lida")
    private BigDecimal latitud;
    
    @NotNull(message = "La longitud es obligatoria")
    @DecimalMin(value = "-180.0", message = "Longitud inv√°lida")
    @DecimalMax(value = "180.0", message = "Longitud inv√°lida")
    private BigDecimal longitud;
    
    private String descripcion;
}



==================================================
RUTH: clients-service/src/main/java/com/transportes/clients/entity/Cliente.java
==================================================
package com.transportes.clients.entity;

import jakarta.persistence.*;
import lombok.*;
import java.time.LocalDateTime;

@Entity
@Table(name = "cliente")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class Cliente {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false, length = 100)
    private String nombre;

    @Column(nullable = false, length = 100)
    private String apellido;

    @Column(nullable = false, unique = true, length = 150)
    private String email;

    @Column(length = 20)
    private String telefono;

    @Column(length = 255)
    private String direccion;

    @Column(name = "keycloak_user_id", unique = true, length = 100)
    private String keycloakUserId;

    @Column(name = "fecha_registro")
    private LocalDateTime fechaRegistro;

    @Column(nullable = false)
    private Boolean activo = true;

    @PrePersist
    protected void onCreate() {
        fechaRegistro = LocalDateTime.now();
        if (activo == null) {
            activo = true;
        }
    }
}



==================================================
RUTH: clients-service/src/main/java/com/transportes/clients/entity/Contenedor.java
==================================================
package com.transportes.clients.entity;

import jakarta.persistence.*;
import lombok.*;
import java.math.BigDecimal;
import java.time.LocalDateTime;

@Entity
@Table(name = "contenedor")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class Contenedor {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false, unique = true, length = 50)
    private String codigo;

    @Column(name = "peso_kg", nullable = false, precision = 10, scale = 2)
    private BigDecimal pesoKg;

    @Column(name = "volumen_m3", nullable = false, precision = 10, scale = 2)
    private BigDecimal volumenM3;

    @Column(name = "alto_m", precision = 5, scale = 2)
    private BigDecimal altoM;

    @Column(name = "ancho_m", precision = 5, scale = 2)
    private BigDecimal anchoM;

    @Column(name = "largo_m", precision = 5, scale = 2)
    private BigDecimal largoM;

    @Column(columnDefinition = "TEXT")
    private String descripcion;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "cliente_id", nullable = false)
    private Cliente cliente;

    @Column(name = "fecha_creacion")
    private LocalDateTime fechaCreacion;

    @PrePersist
    protected void onCreate() {
        fechaCreacion = LocalDateTime.now();
        if (codigo == null || codigo.isEmpty()) {
            codigo = generarCodigo();
        }
    }

    private String generarCodigo() {
        return "CONT-" + System.currentTimeMillis();
    }
}



==================================================
RUTH: clients-service/src/main/java/com/transportes/clients/entity/EstadoSolicitudHistorial.java
==================================================
package com.transportes.clients.entity;

import jakarta.persistence.*;
import lombok.*;
import java.time.LocalDateTime;

@Entity
@Table(name = "estado_solicitud")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class EstadoSolicitudHistorial {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "solicitud_id", nullable = false)
    private Solicitud solicitud;

    @Column(nullable = false, length = 30)
    @Enumerated(EnumType.STRING)
    private Solicitud.EstadoSolicitud estado;

    @Column(name = "fecha_hora")
    private LocalDateTime fechaHora;

    @Column(columnDefinition = "TEXT")
    private String observacion;

    @Column(length = 100)
    private String usuario;

    @PrePersist
    protected void onCreate() {
        if (fechaHora == null) {
            fechaHora = LocalDateTime.now();
        }
    }
}



==================================================
RUTH: clients-service/src/main/java/com/transportes/clients/entity/Solicitud.java
==================================================
package com.transportes.clients.entity;

import jakarta.persistence.*;
import lombok.*;
import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;

@Entity
@Table(name = "solicitud")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class Solicitud {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = "numero_solicitud", nullable = false, unique = true, length = 50)
    private String numeroSolicitud;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "contenedor_id", nullable = false)
    private Contenedor contenedor;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "cliente_id", nullable = false)
    private Cliente cliente;

    @ManyToOne(fetch = FetchType.LAZY, cascade = CascadeType.ALL)
    @JoinColumn(name = "ubicacion_origen_id", nullable = false)
    private Ubicacion ubicacionOrigen;

    @ManyToOne(fetch = FetchType.LAZY, cascade = CascadeType.ALL)
    @JoinColumn(name = "ubicacion_destino_id", nullable = false)
    private Ubicacion ubicacionDestino;

    @Column(nullable = false, length = 30)
    @Enumerated(EnumType.STRING)
    private EstadoSolicitud estado;

    @Column(name = "costo_estimado", precision = 12, scale = 2)
    private BigDecimal costoEstimado;

    @Column(name = "tiempo_estimado_horas")
    private Integer tiempoEstimadoHoras;

    @Column(name = "costo_final", precision = 12, scale = 2)
    private BigDecimal costoFinal;

    @Column(name = "tiempo_real_horas")
    private Integer tiempoRealHoras;

    @Column(name = "ruta_id")
    private Long rutaId;

    @Column(name = "fecha_creacion")
    private LocalDateTime fechaCreacion;

    @Column(name = "fecha_ultima_actualizacion")
    private LocalDateTime fechaUltimaActualizacion;

    @Column(columnDefinition = "TEXT")
    private String observaciones;

    @OneToMany(mappedBy = "solicitud", cascade = CascadeType.ALL, orphanRemoval = true)
    @Builder.Default
    private List<EstadoSolicitudHistorial> historialEstados = new ArrayList<>();

    @PrePersist
    protected void onCreate() {
        fechaCreacion = LocalDateTime.now();
        fechaUltimaActualizacion = LocalDateTime.now();
        if (numeroSolicitud == null || numeroSolicitud.isEmpty()) {
            numeroSolicitud = generarNumeroSolicitud();
        }
        if (estado == null) {
            estado = EstadoSolicitud.BORRADOR;
        }
    }

    @PreUpdate
    protected void onUpdate() {
        fechaUltimaActualizacion = LocalDateTime.now();
    }

    private String generarNumeroSolicitud() {
        return "SOL-" + java.time.Year.now().getValue() + "-" + 
               String.format("%05d", System.currentTimeMillis() % 100000);
    }

    public void agregarEstadoHistorial(EstadoSolicitud nuevoEstado, String observacion, String usuario) {
        EstadoSolicitudHistorial historial = EstadoSolicitudHistorial.builder()
                .solicitud(this)
                .estado(nuevoEstado)
                .observacion(observacion)
                .usuario(usuario)
                .build();
        historialEstados.add(historial);
        this.estado = nuevoEstado;
    }

    public enum EstadoSolicitud {
        BORRADOR,
        PROGRAMADA,
        EN_TRANSITO,
        ENTREGADA,
        CANCELADA
    }
}



==================================================
RUTH: clients-service/src/main/java/com/transportes/clients/entity/Ubicacion.java
==================================================
package com.transportes.clients.entity;

import jakarta.persistence.*;
import lombok.*;
import java.math.BigDecimal;

@Entity
@Table(name = "ubicacion")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class Ubicacion {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false, length = 20)
    @Enumerated(EnumType.STRING)
    private TipoUbicacion tipo;

    @Column(nullable = false, columnDefinition = "TEXT")
    private String direccion;

    @Column(nullable = false, precision = 10, scale = 8)
    private BigDecimal latitud;

    @Column(nullable = false, precision = 11, scale = 8)
    private BigDecimal longitud;

    @Column(columnDefinition = "TEXT")
    private String descripcion;

    @Column(name = "deposito_id")
    private Long depositoId;

    public enum TipoUbicacion {
        ORIGEN,
        DESTINO,
        DEPOSITO
    }
}



==================================================
RUTH: clients-service/src/main/java/com/transportes/clients/exception/BusinessException.java
==================================================
package com.transportes.clients.exception;

public class BusinessException extends RuntimeException {
    public BusinessException(String message) {
        super(message);
    }
    
    public BusinessException(String message, Throwable cause) {
        super(message, cause);
    }
}



==================================================
RUTH: clients-service/src/main/java/com/transportes/clients/exception/GlobalExceptionHandler.java
==================================================
package com.transportes.clients.exception;

import lombok.extern.slf4j.Slf4j;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.validation.FieldError;
import org.springframework.web.bind.MethodArgumentNotValidException;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice;
import java.time.LocalDateTime;
import java.util.HashMap;
import java.util.Map;

@Slf4j
@RestControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(ResourceNotFoundException.class)
    public ResponseEntity<ErrorResponse> handleResourceNotFound(ResourceNotFoundException ex) {
        log.error("Resource not found: {}", ex.getMessage());
        ErrorResponse error = ErrorResponse.builder()
                .timestamp(LocalDateTime.now())
                .status(HttpStatus.NOT_FOUND.value())
                .error("Not Found")
                .message(ex.getMessage())
                .build();
        return ResponseEntity.status(HttpStatus.NOT_FOUND).body(error);
    }

    @ExceptionHandler(BusinessException.class)
    public ResponseEntity<ErrorResponse> handleBusinessException(BusinessException ex) {
        log.error("Business exception: {}", ex.getMessage());
        ErrorResponse error = ErrorResponse.builder()
                .timestamp(LocalDateTime.now())
                .status(HttpStatus.BAD_REQUEST.value())
                .error("Business Error")
                .message(ex.getMessage())
                .build();
        return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(error);
    }

    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<ErrorResponse> handleValidationExceptions(MethodArgumentNotValidException ex) {
        Map<String, String> errors = new HashMap<>();
        ex.getBindingResult().getAllErrors().forEach((error) -> {
            String fieldName = ((FieldError) error).getField();
            String errorMessage = error.getDefaultMessage();
            errors.put(fieldName, errorMessage);
        });
        
        ErrorResponse error = ErrorResponse.builder()
                .timestamp(LocalDateTime.now())
                .status(HttpStatus.BAD_REQUEST.value())
                .error("Validation Error")
                .message("Error de validaci√≥n en los datos")
                .details(errors)
                .build();
        return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(error);
    }

    @ExceptionHandler(Exception.class)
    public ResponseEntity<ErrorResponse> handleGlobalException(Exception ex) {
        log.error("Unexpected error", ex);
        ErrorResponse error = ErrorResponse.builder()
                .timestamp(LocalDateTime.now())
                .status(HttpStatus.INTERNAL_SERVER_ERROR.value())
                .error("Internal Server Error")
                .message("Ha ocurrido un error inesperado")
                .build();
        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(error);
    }

    @lombok.Data
    @lombok.Builder
    public static class ErrorResponse {
        private LocalDateTime timestamp;
        private int status;
        private String error;
        private String message;
        private Map<String, String> details;
    }
}



==================================================
RUTH: clients-service/src/main/java/com/transportes/clients/exception/ResourceNotFoundException.java
==================================================
package com.transportes.clients.exception;

public class ResourceNotFoundException extends RuntimeException {
    public ResourceNotFoundException(String message) {
        super(message);
    }
}



==================================================
RUTH: clients-service/src/main/java/com/transportes/clients/mapper/ClienteMapper.java
==================================================
package com.transportes.clients.mapper;

import com.transportes.clients.dto.ClienteDTO;
import com.transportes.clients.dto.RegistroClienteRequest;
import com.transportes.clients.entity.Cliente;
import org.mapstruct.Mapper;
import org.mapstruct.Mapping;

@Mapper(componentModel = "spring")
public interface ClienteMapper {
    
    ClienteDTO toDTO(Cliente cliente);
    
    @Mapping(target = "id", ignore = true)
    @Mapping(target = "keycloakUserId", ignore = true)
    @Mapping(target = "fechaRegistro", ignore = true)
    @Mapping(target = "activo", constant = "true")
    Cliente toEntity(RegistroClienteRequest request);
}



==================================================
RUTH: clients-service/src/main/java/com/transportes/clients/mapper/ContenedorMapper.java
==================================================
package com.transportes.clients.mapper;

import com.transportes.clients.dto.ContenedorDTO;
import com.transportes.clients.entity.Contenedor;
import org.mapstruct.Mapper;
import org.mapstruct.Mapping;

@Mapper(componentModel = "spring")
public interface ContenedorMapper {
    
    @Mapping(target = "clienteId", source = "cliente.id")
    ContenedorDTO toDTO(Contenedor contenedor);
    
    @Mapping(target = "cliente", ignore = true)
    @Mapping(target = "fechaCreacion", ignore = true)
    Contenedor toEntity(ContenedorDTO dto);
}



==================================================
RUTH: clients-service/src/main/java/com/transportes/clients/mapper/SolicitudMapper.java
==================================================
package com.transportes.clients.mapper;

import com.transportes.clients.dto.SolicitudDTO;
import com.transportes.clients.entity.Solicitud;
import org.mapstruct.Mapper;
import org.mapstruct.Mapping;

@Mapper(componentModel = "spring", uses = {ClienteMapper.class, ContenedorMapper.class, UbicacionMapper.class})
public interface SolicitudMapper {

    @Mapping(target = "contenedor", source = "contenedor")
    @Mapping(target = "cliente", source = "cliente")
    @Mapping(target = "origen", source = "ubicacionOrigen")
    @Mapping(target = "destino", source = "ubicacionDestino")
    SolicitudDTO toDTO(Solicitud solicitud);
}



==================================================
RUTH: clients-service/src/main/java/com/transportes/clients/mapper/UbicacionMapper.java
==================================================
package com.transportes.clients.mapper;

import com.transportes.clients.dto.UbicacionDTO;
import com.transportes.clients.entity.Ubicacion;
import org.mapstruct.Mapper;
import org.mapstruct.Mapping;

@Mapper(componentModel = "spring")
public interface UbicacionMapper {
    
    UbicacionDTO toDTO(Ubicacion ubicacion);
    
    Ubicacion toEntity(UbicacionDTO dto);
}



==================================================
RUTH: clients-service/src/main/java/com/transportes/clients/repository/ClienteRepository.java
==================================================
package com.transportes.clients.repository;

import com.transportes.clients.entity.Cliente;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;
import java.util.Optional;

@Repository
public interface ClienteRepository extends JpaRepository<Cliente, Long> {
    
    Optional<Cliente> findByEmail(String email);
    
    Optional<Cliente> findByKeycloakUserId(String keycloakUserId);
    
    boolean existsByEmail(String email);
}



==================================================
RUTH: clients-service/src/main/java/com/transportes/clients/repository/ContenedorRepository.java
==================================================
package com.transportes.clients.repository;

import com.transportes.clients.entity.Contenedor;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;
import java.util.List;
import java.util.Optional;

@Repository
public interface ContenedorRepository extends JpaRepository<Contenedor, Long> {
    
    Optional<Contenedor> findByCodigo(String codigo);
    
    List<Contenedor> findByClienteId(Long clienteId);
    
    boolean existsByCodigo(String codigo);
}



==================================================
RUTH: clients-service/src/main/java/com/transportes/clients/repository/EstadoSolicitudHistorialRepository.java
==================================================
package com.transportes.clients.repository;

import com.transportes.clients.entity.EstadoSolicitudHistorial;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;
import java.util.List;

@Repository
public interface EstadoSolicitudHistorialRepository extends JpaRepository<EstadoSolicitudHistorial, Long> {
    
    List<EstadoSolicitudHistorial> findBySolicitudIdOrderByFechaHoraAsc(Long solicitudId);
}



==================================================
RUTH: clients-service/src/main/java/com/transportes/clients/repository/SolicitudRepository.java
==================================================
package com.transportes.clients.repository;

import com.transportes.clients.entity.Solicitud;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;
import java.util.List;
import java.util.Optional;

@Repository
public interface SolicitudRepository extends JpaRepository<Solicitud, Long> {

    Optional<Solicitud> findByNumeroSolicitud(String numeroSolicitud);

    List<Solicitud> findByClienteId(Long clienteId);

    List<Solicitud> findByEstado(Solicitud.EstadoSolicitud estado);

    Optional<Solicitud> findByContenedorId(Long contenedorId);

    @Query("SELECT s FROM Solicitud s WHERE s.cliente.id = :clienteId ORDER BY s.fechaCreacion DESC")
    List<Solicitud> findByClienteIdOrderByFechaCreacionDesc(@Param("clienteId") Long clienteId);

    @Query("SELECT s FROM Solicitud s WHERE s.estado IN :estados ORDER BY s.fechaCreacion DESC")
    List<Solicitud> findByEstadoInOrderByFechaCreacionDesc(@Param("estados") List<Solicitud.EstadoSolicitud> estados);

    @Query("SELECT s FROM Solicitud s WHERE s.estado <> 'ENTREGADA' AND s.estado <> 'CANCELADA' ORDER BY s.fechaCreacion DESC")
    List<Solicitud> findPendientes();
}



==================================================
RUTH: clients-service/src/main/java/com/transportes/clients/repository/UbicacionRepository.java
==================================================
package com.transportes.clients.repository;

import com.transportes.clients.entity.Ubicacion;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

@Repository
public interface UbicacionRepository extends JpaRepository<Ubicacion, Long> {
}



==================================================
RUTH: clients-service/src/main/java/com/transportes/clients/service/ClienteService.java
==================================================
package com.transportes.clients.service;

import com.transportes.clients.dto.ClienteDTO;
import com.transportes.clients.dto.RegistroClienteRequest;
import com.transportes.clients.entity.Cliente;
import com.transportes.clients.exception.BusinessException;
import com.transportes.clients.exception.ResourceNotFoundException;
import com.transportes.clients.mapper.ClienteMapper;
import com.transportes.clients.repository.ClienteRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

@Slf4j
@Service
@RequiredArgsConstructor
public class ClienteService {

    private final ClienteRepository clienteRepository;
    private final ClienteMapper clienteMapper;
    private final KeycloakService keycloakService;

    @Transactional
    public ClienteDTO registrarCliente(RegistroClienteRequest request) {
        log.info("Procesando registro de cliente: {}", request.getEmail());

        // 1. Verificar si ya existe en la BD local
        if (clienteRepository.existsByEmail(request.getEmail())) {
            // Si ya existe en BD, simplemente lo devolvemos (Idempotencia)
            return obtenerPorEmail(request.getEmail());
        }

        // 2. Crear o Recuperar usuario de Keycloak
        String keycloakUserId = keycloakService.crearUsuarioCliente(request);

        // 3. Crear cliente en base de datos local
        Cliente cliente = clienteMapper.toEntity(request);
        cliente.setKeycloakUserId(keycloakUserId);

        Cliente clienteGuardado = clienteRepository.save(cliente);
        log.info("Cliente sincronizado/registrado exitosamente con ID: {}", clienteGuardado.getId());

        return clienteMapper.toDTO(clienteGuardado);
    }

    @Transactional(readOnly = true)
    public ClienteDTO obtenerPorId(Long id) {
        Cliente cliente = clienteRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("Cliente no encontrado con ID: " + id));
        return clienteMapper.toDTO(cliente);
    }

    @Transactional(readOnly = true)
    public ClienteDTO obtenerPorEmail(String email) {
        Cliente cliente = clienteRepository.findByEmail(email)
                .orElseThrow(() -> new ResourceNotFoundException("Cliente no encontrado con email: " + email));
        return clienteMapper.toDTO(cliente);
    }

    @Transactional(readOnly = true)
    public Cliente obtenerClienteEntity(Long id) {
        return clienteRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("Cliente no encontrado con ID: " + id));
    }

    @Transactional(readOnly = true)
    public Cliente obtenerClientePorKeycloakUserId(String keycloakUserId) {
        return clienteRepository.findByKeycloakUserId(keycloakUserId)
                .orElseThrow(() -> new ResourceNotFoundException("Cliente no encontrado para el usuario"));
    }

    /**
     * Registra autom√°ticamente un cliente desde Keycloak si no existe en la BD local
     */
    @Transactional
    public Cliente registrarClienteAutomaticamente(String email) {
        log.info("Registrando autom√°ticamente cliente desde Keycloak: {}", email);

        // Verificar si ya existe
        if (clienteRepository.existsByEmail(email)) {
            return clienteRepository.findByEmail(email).orElseThrow();
        }

        // Obtener datos del usuario desde Keycloak
        var keycloakUser = keycloakService.obtenerUsuarioPorEmail(email);
        if (keycloakUser == null) {
            throw new BusinessException("No se pudo obtener informaci√≥n del usuario desde Keycloak");
        }

        // Crear cliente con datos disponibles de Keycloak
        Cliente cliente = Cliente.builder()
                .nombre(keycloakUser.getFirstName() != null ? keycloakUser.getFirstName() : "Sin nombre")
                .apellido(keycloakUser.getLastName() != null ? keycloakUser.getLastName() : "Sin apellido")
                .email(email)
                .keycloakUserId(keycloakUser.getId())
                .activo(true)
                .build();

        Cliente clienteGuardado = clienteRepository.save(cliente);
        log.info("Cliente registrado autom√°ticamente con ID: {}", clienteGuardado.getId());

        return clienteGuardado;
    }

    /**
     * Registra un cliente con datos proporcionados (para solicitudes sin autenticaci√≥n)
     */
    @Transactional
    public Cliente registrarClienteConDatos(String nombre, String apellido, String email,
                                            String password, String telefono, String direccion) {
        log.info("Registrando nuevo cliente con datos proporcionados: {}", email);

        // Verificar si ya existe
        if (clienteRepository.existsByEmail(email)) {
            log.info("Cliente ya existe con email: {}", email);
            return clienteRepository.findByEmail(email).orElseThrow();
        }

        // Crear request para registrar en Keycloak
        RegistroClienteRequest request = RegistroClienteRequest.builder()
                .nombre(nombre)
                .apellido(apellido)
                .email(email)
                .password(password)
                .telefono(telefono)
                .direccion(direccion)
                .build();

        // Crear usuario en Keycloak
        String keycloakUserId = keycloakService.crearUsuarioCliente(request);

        // Crear cliente en BD local
        Cliente cliente = Cliente.builder()
                .nombre(nombre)
                .apellido(apellido)
                .email(email)
                .telefono(telefono)
                .direccion(direccion)
                .keycloakUserId(keycloakUserId)
                .activo(true)
                .build();

        Cliente clienteGuardado = clienteRepository.save(cliente);
        log.info("Cliente registrado con ID: {}", clienteGuardado.getId());

        return clienteGuardado;
    }
}



==================================================
RUTH: clients-service/src/main/java/com/transportes/clients/service/KeycloakService.java
==================================================
package com.transportes.clients.service;

import com.transportes.clients.dto.RegistroClienteRequest;
import com.transportes.clients.exception.BusinessException;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.keycloak.admin.client.Keycloak;
import org.keycloak.admin.client.KeycloakBuilder;
import org.keycloak.admin.client.resource.RealmResource;
import org.keycloak.admin.client.resource.UsersResource;
import org.keycloak.representations.idm.CredentialRepresentation;
import org.keycloak.representations.idm.UserRepresentation;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;

import jakarta.annotation.PostConstruct;
import jakarta.ws.rs.core.Response;
import java.util.Collections;
import java.util.List;

@Slf4j
@Service
@RequiredArgsConstructor
public class KeycloakService {

    @Value("${keycloak.auth-server-url}")
    private String authServerUrl;

    @Value("${keycloak.realm}")
    private String realm;

    @Value("${keycloak.admin.username:admin}")
    private String adminUsername;

    @Value("${keycloak.admin.password:admin}")
    private String adminPassword;

    @Value("${keycloak.admin.client-id:admin-cli}")
    private String adminClientId;

    private Keycloak keycloak;

    @PostConstruct
    public void init() {
        try {
            this.keycloak = KeycloakBuilder.builder()
                    .serverUrl(authServerUrl)
                    .realm("master")
                    .clientId(adminClientId)
                    .username(adminUsername)
                    .password(adminPassword)
                    .build();
            log.info("Keycloak admin client initialized successfully");
        } catch (Exception e) {
            log.error("Error initializing Keycloak admin client", e);
        }
    }

    public String crearUsuarioCliente(RegistroClienteRequest request) {
        try {
            RealmResource realmResource = keycloak.realm(realm);
            UsersResource usersResource = realmResource.users();

            // Verificar si el usuario ya existe
            List<UserRepresentation> existingUsers = usersResource.search(request.getEmail());
            if (!existingUsers.isEmpty()) {
                // CORRECCI√ìN: Si existe en Keycloak, devolvemos su ID para permitir
                // que el ClienteService lo guarde en la BD local.
                log.info("El usuario ya existe en Keycloak. Recuperando ID para sincronizaci√≥n.");
                return existingUsers.get(0).getId();
            }

            // Crear usuario
            UserRepresentation user = new UserRepresentation();
            user.setUsername(request.getEmail());
            user.setEmail(request.getEmail());
            user.setFirstName(request.getNombre());
            user.setLastName(request.getApellido());
            user.setEnabled(true);
            user.setEmailVerified(true);

            // Crear credencial
            CredentialRepresentation credential = new CredentialRepresentation();
            credential.setType(CredentialRepresentation.PASSWORD);
            credential.setValue(request.getPassword());
            credential.setTemporary(false);
            user.setCredentials(Collections.singletonList(credential));

            // Crear usuario en Keycloak
            Response response = usersResource.create(user);

            if (response.getStatus() == 201) {
                String userId = extractUserIdFromResponse(response);
                
                // Asignar rol CLIENTE
                asignarRolCliente(userId);
                
                log.info("Usuario cliente creado en Keycloak: {}", request.getEmail());
                return userId;
            } else {
                String errorMsg = response.readEntity(String.class);
                log.error("Error creating user in Keycloak. Status: {}, Error: {}", response.getStatus(), errorMsg);
                throw new BusinessException("Error al crear usuario en Keycloak: " + errorMsg);
            }

        } catch (BusinessException e) {
            throw e;
        } catch (Exception e) {
            log.error("Error al crear usuario en Keycloak", e);
            throw new BusinessException("Error al crear usuario en Keycloak", e);
        }
    }

    private String extractUserIdFromResponse(Response response) {
        String location = response.getHeaderString("Location");
        if (location != null) {
            return location.substring(location.lastIndexOf('/') + 1);
        }
        throw new BusinessException("No se pudo obtener el ID del usuario creado");
    }

    private void asignarRolCliente(String userId) {
        try {
            RealmResource realmResource = keycloak.realm(realm);
            
            // Buscar rol CLIENTE
            var roleRepresentation = realmResource.roles().get("CLIENTE").toRepresentation();
            
            // Asignar rol al usuario
            realmResource.users().get(userId).roles().realmLevel()
                    .add(Collections.singletonList(roleRepresentation));
            
            log.info("Rol CLIENTE asignado al usuario {}", userId);
        } catch (Exception e) {
            log.error("Error al asignar rol CLIENTE", e);
            // No lanzamos excepci√≥n para no interrumpir el flujo
        }
    }

    public void eliminarUsuario(String keycloakUserId) {
        try {
            RealmResource realmResource = keycloak.realm(realm);
            realmResource.users().get(keycloakUserId).remove();
            log.info("Usuario eliminado de Keycloak: {}", keycloakUserId);
        } catch (Exception e) {
            log.error("Error al eliminar usuario de Keycloak", e);
        }
    }

    /**
     * Obtiene informaci√≥n de un usuario desde Keycloak por su email
     */
    public UserRepresentation obtenerUsuarioPorEmail(String email) {
        try {
            RealmResource realmResource = keycloak.realm(realm);
            List<UserRepresentation> users = realmResource.users().search(email, true);

            if (users.isEmpty()) {
                log.warn("Usuario no encontrado en Keycloak con email: {}", email);
                return null;
            }

            return users.get(0);
        } catch (Exception e) {
            log.error("Error al obtener usuario de Keycloak por email", e);
            return null;
        }
    }
}



==================================================
RUTH: clients-service/src/main/java/com/transportes/clients/service/SolicitudService.java
==================================================
package com.transportes.clients.service;

import com.transportes.clients.dto.*;
import com.transportes.clients.entity.*;
import com.transportes.clients.exception.BusinessException;
import com.transportes.clients.exception.ResourceNotFoundException;
import com.transportes.clients.mapper.SolicitudMapper;
import com.transportes.clients.mapper.UbicacionMapper;
import com.transportes.clients.repository.ContenedorRepository;
import com.transportes.clients.repository.EstadoSolicitudHistorialRepository;
import com.transportes.clients.repository.SolicitudRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;
import java.util.stream.Collectors;

@Slf4j
@Service
@RequiredArgsConstructor
public class SolicitudService {

    private final SolicitudRepository solicitudRepository;
    private final ContenedorRepository contenedorRepository;
    private final EstadoSolicitudHistorialRepository historialRepository;
    private final ClienteService clienteService;
    private final SolicitudMapper solicitudMapper;
    private final UbicacionMapper ubicacionMapper;
    private final com.transportes.clients.repository.ClienteRepository clienteRepository;

    @Transactional
    public SolicitudDTO crearSolicitud(CrearSolicitudRequest request, String userEmail) {
        Cliente cliente;
        String emailParaHistorial;

        // Caso 1: Usuario autenticado - usar su email
        if (userEmail != null && !userEmail.isBlank()) {
            log.info("Creando solicitud para usuario autenticado: {}", userEmail);
            cliente = obtenerORegistrarCliente(userEmail);
            emailParaHistorial = userEmail;
        }
        // Caso 2: Usuario NO autenticado - usar datos del request y registrar
        else {
            if (request.getEmail() == null || request.getEmail().isBlank()) {
                throw new BusinessException("Debe proporcionar un email o estar autenticado para crear una solicitud");
            }
            if (request.getPassword() == null || request.getPassword().isBlank()) {
                throw new BusinessException("Debe proporcionar una contrase√±a para registrarse");
            }
            if (request.getNombre() == null || request.getNombre().isBlank()) {
                throw new BusinessException("Debe proporcionar un nombre para registrarse");
            }
            if (request.getApellido() == null || request.getApellido().isBlank()) {
                throw new BusinessException("Debe proporcionar un apellido para registrarse");
            }

            log.info("Creando solicitud para nuevo usuario: {}", request.getEmail());

            // Registrar cliente con los datos del request
            cliente = clienteService.registrarClienteConDatos(
                    request.getNombre(),
                    request.getApellido(),
                    request.getEmail(),
                    request.getPassword(),
                    request.getTelefono(),
                    request.getDireccion()
            );
            emailParaHistorial = request.getEmail();
        }

        // Crear contenedor
        Contenedor contenedor = crearContenedor(request.getContenedor(), cliente);

        // Crear ubicaciones
        Ubicacion origen = crearUbicacion(request.getOrigen(), Ubicacion.TipoUbicacion.ORIGEN);
        Ubicacion destino = crearUbicacion(request.getDestino(), Ubicacion.TipoUbicacion.DESTINO);

        // Crear solicitud
        Solicitud solicitud = Solicitud.builder()
                .contenedor(contenedor)
                .cliente(cliente)
                .ubicacionOrigen(origen)
                .ubicacionDestino(destino)
                .estado(Solicitud.EstadoSolicitud.BORRADOR)
                .observaciones(request.getObservaciones())
                .build();

        // Agregar estado inicial al historial
        solicitud.agregarEstadoHistorial(
                Solicitud.EstadoSolicitud.BORRADOR,
                "Solicitud creada",
                emailParaHistorial
        );

        Solicitud solicitudGuardada = solicitudRepository.save(solicitud);
        log.info("Solicitud creada con n√∫mero: {}", solicitudGuardada.getNumeroSolicitud());

        return solicitudMapper.toDTO(solicitudGuardada);
    }

    private Contenedor crearContenedor(CrearSolicitudRequest.ContenedorRequest request, Cliente cliente) {
        Contenedor contenedor = Contenedor.builder()
                .pesoKg(request.getPesoKg())
                .volumenM3(request.getVolumenM3())
                .altoM(request.getAltoM())
                .anchoM(request.getAnchoM())
                .largoM(request.getLargoM())
                .descripcion(request.getDescripcion())
                .cliente(cliente)
                .build();

        return contenedorRepository.save(contenedor);
    }

    private Ubicacion crearUbicacion(UbicacionDTO dto, Ubicacion.TipoUbicacion tipo) {
        Ubicacion ubicacion = ubicacionMapper.toEntity(dto);
        ubicacion.setTipo(tipo);
        return ubicacion;
    }

    /**
     * Obtiene un cliente existente o lo registra autom√°ticamente si no existe
     */
    private Cliente obtenerORegistrarCliente(String email) {
        return clienteRepository.findByEmail(email)
                .orElseGet(() -> clienteService.registrarClienteAutomaticamente(email));
    }

    @Transactional(readOnly = true)
    public SolicitudDTO obtenerPorId(Long id, String userEmail) {
        Solicitud solicitud = solicitudRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("Solicitud no encontrada con ID: " + id));

        // Verificar que el usuario tenga acceso a esta solicitud
        verificarAccesoSolicitud(solicitud, userEmail);

        return solicitudMapper.toDTO(solicitud);
    }

    @Transactional(readOnly = true)
    public List<SolicitudDTO> obtenerSolicitudesDelCliente(String userEmail) {
        Cliente cliente = clienteRepository.findByEmail(userEmail)
                .orElseThrow(() -> new ResourceNotFoundException("Cliente no encontrado con email: " + userEmail));

        List<Solicitud> solicitudes = solicitudRepository.findByClienteIdOrderByFechaCreacionDesc(cliente.getId());

        return solicitudes.stream()
                .map(solicitudMapper::toDTO)
                .collect(Collectors.toList());
    }

    @Transactional(readOnly = true)
    public List<SolicitudDTO> obtenerTodasLasSolicitudes() {
        return solicitudRepository.findAll().stream()
                .map(solicitudMapper::toDTO)
                .collect(Collectors.toList());
    }

    @Transactional(readOnly = true)
    public List<SolicitudDTO> obtenerSolicitudesPendientes() {
        return solicitudRepository.findPendientes().stream()
                .map(solicitudMapper::toDTO)
                .collect(Collectors.toList());
    }

    @Transactional(readOnly = true)
    public SeguimientoDTO obtenerSeguimiento(Long solicitudId, String userEmail) {
        Solicitud solicitud = solicitudRepository.findById(solicitudId)
                .orElseThrow(() -> new ResourceNotFoundException("Solicitud no encontrada con ID: " + solicitudId));

        // Verificar acceso
        verificarAccesoSolicitud(solicitud, userEmail);

        // Obtener historial
        List<EstadoSolicitudHistorial> historial = historialRepository
                .findBySolicitudIdOrderByFechaHoraAsc(solicitudId);

        List<SeguimientoDTO.EstadoHistorialDTO> historialDTO = historial.stream()
                .map(h -> SeguimientoDTO.EstadoHistorialDTO.builder()
                        .estado(h.getEstado().name())
                        .fechaHora(h.getFechaHora())
                        .observacion(h.getObservacion())
                        .build())
                .collect(Collectors.toList());

        return SeguimientoDTO.builder()
                .solicitudId(solicitud.getId())
                .numeroSolicitud(solicitud.getNumeroSolicitud())
                .estadoActual(solicitud.getEstado().name())
                .historial(historialDTO)
                .ubicacionActual(determinarUbicacionActual(solicitud))
                .build();
    }

    private SeguimientoDTO.UbicacionActualDTO determinarUbicacionActual(Solicitud solicitud) {
        switch (solicitud.getEstado()) {
            case BORRADOR:
            case PROGRAMADA:
                return SeguimientoDTO.UbicacionActualDTO.builder()
                        .tipo("ORIGEN")
                        .descripcion("En origen: " + solicitud.getUbicacionOrigen().getDireccion())
                        .build();
            case EN_TRANSITO:
                return SeguimientoDTO.UbicacionActualDTO.builder()
                        .tipo("EN_TRANSITO")
                        .descripcion("En tr√°nsito")
                        .build();
            case ENTREGADA:
                return SeguimientoDTO.UbicacionActualDTO.builder()
                        .tipo("DESTINO")
                        .descripcion("Entregado en: " + solicitud.getUbicacionDestino().getDireccion())
                        .build();
            default:
                return null;
        }
    }

    private void verificarAccesoSolicitud(Solicitud solicitud, String userEmail) {
        // En producci√≥n, verificar contra el token JWT
        // Por ahora, verificamos que el email coincida con el del cliente
        if (!solicitud.getCliente().getEmail().equals(userEmail)) {
            throw new BusinessException("No tiene permisos para acceder a esta solicitud");
        }
    }

    @Transactional
    public void actualizarEstado(Long solicitudId, Solicitud.EstadoSolicitud nuevoEstado, String observacion, String usuario) {
        Solicitud solicitud = solicitudRepository.findById(solicitudId)
                .orElseThrow(() -> new ResourceNotFoundException("Solicitud no encontrada"));

        solicitud.agregarEstadoHistorial(nuevoEstado, observacion, usuario);
        solicitudRepository.save(solicitud);

        log.info("Estado de solicitud {} actualizado a {}", solicitudId, nuevoEstado);
    }

    @Transactional(readOnly = true)
    public SolicitudDTO obtenerPorIdInternal(Long id) {
        Solicitud solicitud = solicitudRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("Solicitud no encontrada con ID: " + id));
        return solicitudMapper.toDTO(solicitud);
    }
}



==================================================
RUTH: clients-service/src/main/resources/application-docker.yml
==================================================
spring:
  datasource:
    url: ${SPRING_DATASOURCE_URL:jdbc:postgresql://postgres-clients:5432/clients_db}
    username: ${SPRING_DATASOURCE_USERNAME:clients_user}
    password: ${SPRING_DATASOURCE_PASSWORD:clients_pass}
  
  security:
    oauth2:
      resourceserver:
        jwt:
          jwk-set-uri: ${KEYCLOAK_AUTH_SERVER_URL:http://keycloak:8080}/realms/${KEYCLOAK_REALM:transportes-realm}/protocol/openid-connect/certs

keycloak:
  auth-server-url: ${KEYCLOAK_AUTH_SERVER_URL:http://keycloak:8080}
  realm: ${KEYCLOAK_REALM:transportes-realm}

logging:
  level:
    com.transportes.clients: INFO
    org.springframework.security: INFO
    org.hibernate.SQL: INFO

logistics:
  service:
    url: http://logistics-service:8082

billing:
  service:
    url: http://billing-service:8083



==================================================
RUTH: clients-service/src/main/resources/application.yml
==================================================
spring:
  application:
    name: clients-service
  
  datasource:
    url: jdbc:postgresql://localhost:5432/clients_db
    username: clients_user
    password: clients_pass
    driver-class-name: org.postgresql.Driver
  
  jpa:
    hibernate:
      ddl-auto: validate
    show-sql: true
    properties:
      hibernate:
        format_sql: true
        dialect: org.hibernate.dialect.PostgreSQLDialect
  
  security:
    oauth2:
      resourceserver:
        jwt:
          jwk-set-uri: http://localhost:8180/realms/transportes-realm/protocol/openid-connect/certs

server:
  port: 8081

keycloak:
  auth-server-url: http://localhost:8180
  realm: transportes-realm
  admin:
    username: admin
    password: admin
    client-id: admin-cli

management:
  endpoints:
    web:
      exposure:
        include: health,info,metrics
  endpoint:
    health:
      show-details: always

springdoc:
  api-docs:
    path: /v3/api-docs
  swagger-ui:
    path: /swagger-ui.html
    enabled: true

logging:
  level:
    com.transportes.clients: DEBUG
    org.springframework.security: DEBUG
    org.hibernate.SQL: DEBUG

logistics:
  service:
    url: http://localhost:8082

billing:
  service:
    url: http://localhost:8083



==================================================
RUTH: docker-compose.yml
==================================================
services:
  # ==================== BASES DE DATOS ====================
  
  postgres-clients:
    image: postgres:15-alpine
    container_name: postgres-clients
    environment:
      POSTGRES_DB: clients_db
      POSTGRES_USER: clients_user
      POSTGRES_PASSWORD: clients_pass
    ports:
      - "5434:5432"
    volumes:
      - postgres-clients-data:/var/lib/postgresql/data
      - ./infrastructure/init-scripts/clients-init.sql:/docker-entrypoint-initdb.d/init.sql
    networks:
      - transportes-network
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U clients_user -d clients_db"]
      interval: 10s
      timeout: 5s
      retries: 5

  postgres-logistics:
    image: postgres:15-alpine
    container_name: postgres-logistics
    environment:
      POSTGRES_DB: logistics_db
      POSTGRES_USER: logistics_user
      POSTGRES_PASSWORD: logistics_pass
    ports:
      - "5433:5432"
    volumes:
      - postgres-logistics-data:/var/lib/postgresql/data
      - ./infrastructure/init-scripts/logistics-init.sql:/docker-entrypoint-initdb.d/init.sql
    networks:
      - transportes-network
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U logistics_user -d logistics_db"]
      interval: 10s
      timeout: 5s
      retries: 5

  postgres-billing:
    image: postgres:15-alpine
    container_name: postgres-billing
    environment:
      POSTGRES_DB: billing_db
      POSTGRES_USER: billing_user
      POSTGRES_PASSWORD: billing_pass
    ports:
      - "5435:5432"
    volumes:
      - postgres-billing-data:/var/lib/postgresql/data
      - ./infrastructure/init-scripts/billing-init.sql:/docker-entrypoint-initdb.d/init.sql
    networks:
      - transportes-network
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U billing_user -d billing_db"]
      interval: 10s
      timeout: 5s
      retries: 5

  postgres-keycloak:
    image: postgres:15-alpine
    container_name: postgres-keycloak
    environment:
      POSTGRES_DB: keycloak_db
      POSTGRES_USER: keycloak_user
      POSTGRES_PASSWORD: keycloak_pass
    ports:
      - "5436:5432"
    volumes:
      - postgres-keycloak-data:/var/lib/postgresql/data
    networks:
      - transportes-network
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U keycloak_user -d keycloak_db"]
      interval: 10s
      timeout: 5s
      retries: 5

  # ==================== KEYCLOAK ====================
  
  keycloak:
    image: quay.io/keycloak/keycloak:23.0
    container_name: keycloak
    environment:
      KC_DB: postgres
      KC_DB_URL: jdbc:postgresql://postgres-keycloak:5432/keycloak_db
      KC_DB_USERNAME: keycloak_user
      KC_DB_PASSWORD: keycloak_pass
      KEYCLOAK_ADMIN: admin
      KEYCLOAK_ADMIN_PASSWORD: admin
      KC_HOSTNAME_STRICT: false
      KC_HOSTNAME_STRICT_HTTPS: false
      KC_HTTP_ENABLED: true
      KC_HEALTH_ENABLED: true
    command:
      - start-dev
      - --import-realm
    ports:
      - "8180:8080"
    volumes:
      - ./infrastructure/keycloak/realm-export.json:/opt/keycloak/data/import/realm-export.json
    depends_on:
      postgres-keycloak:
        condition: service_healthy
    networks:
      - transportes-network
    # Healthcheck comentado temporalmente porque curl no est√° disponible en la imagen
    # healthcheck:
    #   test: ["CMD-SHELL", "curl -f http://localhost:8080/health/ready || exit 1"]
    #   interval: 30s
    #   timeout: 10s
    #   retries: 5
    #   start_period: 60s

  # ==================== OSRM (ROUTING) ====================
  
  osrm:
    image: ghcr.io/project-osrm/osrm-backend:latest
    container_name: osrm
    command: osrm-routed --algorithm mld /data/argentina-latest.osrm
    ports:
      - "5000:5000"
    volumes:
      - osrm-data:/data
    networks:
      - transportes-network
    healthcheck:
      test: ["CMD-SHELL", "wget --spider -q http://localhost:5000/health || exit 1"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 120s

  # ==================== MICROSERVICIOS ====================
  
  clients-service:
    build:
      context: ./clients-service
      dockerfile: Dockerfile
    container_name: clients-service
    environment:
      SPRING_PROFILES_ACTIVE: docker
      SPRING_DATASOURCE_URL: jdbc:postgresql://postgres-clients:5432/clients_db
      SPRING_DATASOURCE_USERNAME: clients_user
      SPRING_DATASOURCE_PASSWORD: clients_pass
      KEYCLOAK_AUTH_SERVER_URL: http://keycloak:8080
      KEYCLOAK_REALM: transportes-realm
      LOGISTICS_SERVICE_URL: http://logistics-service:8082
      BILLING_SERVICE_URL: http://billing-service:8083
    ports:
      - "8081:8081"
    depends_on:
      postgres-clients:
        condition: service_healthy
      keycloak:
        condition: service_started
    networks:
      - transportes-network
    # Healthcheck comentado porque curl no est√° disponible en la imagen Alpine
    # healthcheck:
    #   test: ["CMD-SHELL", "curl -f http://localhost:8081/actuator/health || exit 1"]
    #   interval: 30s
    #   timeout: 10s
    #   retries: 3
    #   start_period: 60s

  logistics-service:
    build:
      context: ./logistics-service
      dockerfile: Dockerfile
    container_name: logistics-service
    environment:
      SPRING_PROFILES_ACTIVE: docker
      SPRING_DATASOURCE_URL: jdbc:postgresql://postgres-logistics:5432/logistics_db
      SPRING_DATASOURCE_USERNAME: logistics_user
      SPRING_DATASOURCE_PASSWORD: logistics_pass
      KEYCLOAK_AUTH_SERVER_URL: http://keycloak:8080
      KEYCLOAK_REALM: transportes-realm
      OSRM_SERVICE_URL: http://osrm:5000
      BILLING_SERVICE_URL: http://billing-service:8083
    ports:
      - "8082:8082"
    depends_on:
      postgres-logistics:
        condition: service_healthy
      keycloak:
        condition: service_started
      osrm:
        condition: service_started
    networks:
      - transportes-network
    # Healthcheck comentado porque curl no est√° disponible en la imagen Alpine
    # healthcheck:
    #   test: ["CMD-SHELL", "curl -f http://localhost:8082/actuator/health || exit 1"]
    #   interval: 30s
    #   timeout: 10s
    #   retries: 3
    #   start_period: 60s

  billing-service:
    build:
      context: ./billing-service
      dockerfile: Dockerfile
    container_name: billing-service
    environment:
      SPRING_PROFILES_ACTIVE: docker
      SPRING_DATASOURCE_URL: jdbc:postgresql://postgres-billing:5432/billing_db
      SPRING_DATASOURCE_USERNAME: billing_user
      SPRING_DATASOURCE_PASSWORD: billing_pass
      KEYCLOAK_AUTH_SERVER_URL: http://keycloak:8080
      KEYCLOAK_REALM: transportes-realm
    ports:
      - "8083:8083"
    depends_on:
      postgres-billing:
        condition: service_healthy
      keycloak:
        condition: service_started
    networks:
      - transportes-network
    # Healthcheck comentado porque curl no est√° disponible en la imagen Alpine
    # healthcheck:
    #   test: ["CMD-SHELL", "curl -f http://localhost:8083/actuator/health || exit 1"]
    #   interval: 30s
    #   timeout: 10s
    #   retries: 3
    #   start_period: 60s

  gateway-service:
    build:
      context: ./gateway-service
      dockerfile: Dockerfile
    container_name: gateway-service
    environment:
      SPRING_PROFILES_ACTIVE: docker
      KEYCLOAK_AUTH_SERVER_URL: http://keycloak:8080
      KEYCLOAK_REALM: transportes-realm
      CLIENTS_SERVICE_URL: http://clients-service:8081
      LOGISTICS_SERVICE_URL: http://logistics-service:8082
      BILLING_SERVICE_URL: http://billing-service:8083
    ports:
      - "8080:8080"
    depends_on:
      clients-service:
        condition: service_started
      logistics-service:
        condition: service_started
      billing-service:
        condition: service_started
      keycloak:
        condition: service_started
    networks:
      - transportes-network
    # Healthcheck comentado porque curl no est√° disponible en la imagen Alpine
    # healthcheck:
    #   test: ["CMD-SHELL", "curl -f http://localhost:8080/actuator/health || exit 1"]
    #   interval: 30s
    #   timeout: 10s
    #   retries: 3
    #   start_period: 60s

networks:
  transportes-network:
    driver: bridge

volumes:
  postgres-clients-data:
  postgres-logistics-data:
  postgres-billing-data:
  postgres-keycloak-data:
  osrm-data:



==================================================
RUTH: gateway-service/Dockerfile
==================================================
# Usamos solo una etapa - esperamos que el JAR ya est√© compilado
FROM eclipse-temurin:17-jre-alpine
WORKDIR /app

# Copiamos el JAR ya compilado desde el host
COPY target/gateway-service-1.0.0.jar app.jar

EXPOSE 8080

ENTRYPOINT ["java", "-jar", "app.jar"]



==================================================
RUTH: gateway-service/pom.xml
==================================================
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 
         http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <parent>
        <groupId>com.transportes</groupId>
        <artifactId>tpi-transportes</artifactId>
        <version>1.0.0</version>
    </parent>

    <artifactId>gateway-service</artifactId>
    <name>Gateway Service</name>
    <description>API Gateway para el sistema de transportes</description>

    <dependencies>
        <!-- Spring Cloud Gateway -->
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-gateway</artifactId>
        </dependency>

        <!-- Spring Boot Actuator -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-actuator</artifactId>
        </dependency>

        <!-- Spring Security + OAuth2 Resource Server -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-security</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-oauth2-resource-server</artifactId>
        </dependency>

        <!-- Resilience4j Circuit Breaker -->
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-circuitbreaker-reactor-resilience4j</artifactId>
        </dependency>

        <!-- Lombok -->
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <optional>true</optional>
        </dependency>

        <!-- Springdoc OpenAPI for Gateway -->
        <dependency>
            <groupId>org.springdoc</groupId>
            <artifactId>springdoc-openapi-starter-webflux-ui</artifactId>
            <version>2.3.0</version>
        </dependency>

        <!-- Test -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>

        <dependency>
            <groupId>org.springframework.security</groupId>
            <artifactId>spring-security-test</artifactId>
            <scope>test</scope>
        </dependency>
    </dependencies>

    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
                <executions>
                    <execution>
                        <goals>
                            <goal>repackage</goal>
                        </goals>
                    </execution>
                </executions>
            </plugin>
        </plugins>
    </build>

</project>



==================================================
RUTH: gateway-service/src/main/java/com/transportes/gateway/GatewayServiceApplication.java
==================================================
package com.transportes.gateway;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class GatewayServiceApplication {

    public static void main(String[] args) {
        SpringApplication.run(GatewayServiceApplication.class, args);
    }
}



==================================================
RUTH: gateway-service/src/main/java/com/transportes/gateway/config/FallbackController.java
==================================================
package com.transportes.gateway.config;

import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;
import reactor.core.publisher.Mono;
import java.time.LocalDateTime;
import java.util.HashMap;
import java.util.Map;

@RestController
public class FallbackController {

    @GetMapping("/fallback")
    public Mono<ResponseEntity<Map<String, Object>>> fallback() {
        Map<String, Object> response = new HashMap<>();
        response.put("timestamp", LocalDateTime.now());
        response.put("status", HttpStatus.SERVICE_UNAVAILABLE.value());
        response.put("error", "Service Unavailable");
        response.put("message", "El servicio no est√° disponible en este momento. Por favor, intente m√°s tarde.");

        return Mono.just(ResponseEntity
                .status(HttpStatus.SERVICE_UNAVAILABLE)
                .body(response));
    }
}



==================================================
RUTH: gateway-service/src/main/java/com/transportes/gateway/config/SecurityConfig.java
==================================================
package com.transportes.gateway.config;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.web.reactive.EnableWebFluxSecurity;
import org.springframework.security.config.web.server.ServerHttpSecurity;
import org.springframework.security.oauth2.jwt.NimbusReactiveJwtDecoder;
import org.springframework.security.oauth2.jwt.ReactiveJwtDecoder;
import org.springframework.security.web.server.SecurityWebFilterChain;

@Configuration
@EnableWebFluxSecurity
public class SecurityConfig {

    @Value("${spring.security.oauth2.resourceserver.jwt.jwk-set-uri}")
    private String jwkSetUri;

    @Bean
    public SecurityWebFilterChain securityWebFilterChain(ServerHttpSecurity http) {
        http
                .csrf(csrf -> csrf.disable())
                .authorizeExchange(exchanges -> exchanges
                        .pathMatchers("/api/clientes/registro").permitAll()
                        .pathMatchers("/actuator/**").permitAll()
                        .pathMatchers(org.springframework.http.HttpMethod.POST, "/api/solicitudes").permitAll()
                        .anyExchange().authenticated()
                )
                .oauth2ResourceServer(oauth2 -> oauth2
                        .jwt(jwt -> jwt.jwtDecoder(jwtDecoder()))
                );

        return http.build();
    }

    @Bean
    public ReactiveJwtDecoder jwtDecoder() {
        return NimbusReactiveJwtDecoder.withJwkSetUri(jwkSetUri).build();
    }
}



==================================================
RUTH: gateway-service/src/main/resources/application-docker.yml
==================================================
spring:
  cloud:
    gateway:
      routes:
        - id: clients-service
          uri: http://clients-service:8081
          predicates:
            - Path=/api/clientes/**, /api/solicitudes/**, /api/contenedores/**
            
        - id: logistics-service
          uri: http://logistics-service:8082
          predicates:
            - Path=/api/rutas/**, /api/camiones/**, /api/depositos/**, /api/tramos/**, /api/transportista/**
            
        - id: billing-service
          uri: http://billing-service:8083
          predicates:
            - Path=/api/costos/**, /api/tarifas/**

  security:
    oauth2:
      resourceserver:
        jwt:
          jwk-set-uri: http://keycloak:8080/realms/transportes-realm/protocol/openid-connect/certs

logging:
  level:
    org.springframework.cloud.gateway: INFO
    com.transportes.gateway: INFO



==================================================
RUTH: gateway-service/src/main/resources/application.yml
==================================================
spring:
  application:
    name: gateway-service
  
  cloud:
    gateway:
      routes:
        # Clients Service
        - id: clients-service
          uri: http://localhost:8081
          predicates:
            - Path=/api/clientes/**, /api/solicitudes/**, /api/contenedores/**
          filters:
            - name: CircuitBreaker
              args:
                name: clientsCircuitBreaker
                fallbackUri: forward:/fallback

        # Logistics Service
        - id: logistics-service
          uri: http://localhost:8082
          predicates:
            - Path=/api/rutas/**, /api/camiones/**, /api/depositos/**, /api/tramos/**, /api/transportista/**
          filters:
            - name: CircuitBreaker
              args:
                name: logisticsCircuitBreaker
                fallbackUri: forward:/fallback

        # Billing Service
        - id: billing-service
          uri: http://localhost:8083
          predicates:
            - Path=/api/costos/**, /api/tarifas/**
          filters:
            - name: CircuitBreaker
              args:
                name: billingCircuitBreaker
                fallbackUri: forward:/fallback

      globalcors:
        corsConfigurations:
          '[/**]':
            allowedOrigins: 
              - "http://localhost:3000"
              - "http://localhost:4200"
            allowedMethods:
              - GET
              - POST
              - PUT
              - DELETE
              - OPTIONS
            allowedHeaders: "*"
            allowCredentials: true

  security:
    oauth2:
      resourceserver:
        jwt:
          jwk-set-uri: http://localhost:8180/realms/transportes-realm/protocol/openid-connect/certs

server:
  port: 8080

management:
  endpoints:
    web:
      exposure:
        include: health,info,metrics,circuitbreakers
  endpoint:
    health:
      show-details: always

resilience4j:
  circuitbreaker:
    configs:
      default:
        registerHealthIndicator: true
        slidingWindowSize: 10
        minimumNumberOfCalls: 5
        permittedNumberOfCallsInHalfOpenState: 3
        automaticTransitionFromOpenToHalfOpenEnabled: true
        waitDurationInOpenState: 5s
        failureRateThreshold: 50
        eventConsumerBufferSize: 10

logging:
  level:
    org.springframework.cloud.gateway: DEBUG
    com.transportes.gateway: DEBUG



==================================================
RUTH: infrastructure/init-scripts/billing-init.sql
==================================================
-- Script de inicializaci√≥n para billing_db

-- Tabla: tarifa_base
CREATE TABLE IF NOT EXISTS tarifa_base (
    id BIGSERIAL PRIMARY KEY,
    nombre VARCHAR(100) NOT NULL,
    descripcion TEXT,
    costo_fijo_gestion DECIMAL(10, 2) NOT NULL,
    costo_adicional_por_tramo DECIMAL(10, 2) DEFAULT 0,
    fecha_vigencia_desde DATE NOT NULL,
    fecha_vigencia_hasta DATE,
    activa BOOLEAN DEFAULT TRUE,
    fecha_creacion TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Tabla: tarifa_combustible
CREATE TABLE IF NOT EXISTS tarifa_combustible (
    id BIGSERIAL PRIMARY KEY,
    precio_por_litro DECIMAL(8, 2) NOT NULL,
    fecha_vigencia_desde DATE NOT NULL,
    fecha_vigencia_hasta DATE,
    activa BOOLEAN DEFAULT TRUE,
    fecha_creacion TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Tabla: tarifa_estadia
CREATE TABLE IF NOT EXISTS tarifa_estadia (
    id BIGSERIAL PRIMARY KEY,
    costo_por_dia DECIMAL(10, 2) NOT NULL,
    costo_por_hora DECIMAL(8, 2) NOT NULL,
    fecha_vigencia_desde DATE NOT NULL,
    fecha_vigencia_hasta DATE,
    activa BOOLEAN DEFAULT TRUE,
    fecha_creacion TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Tabla: tarifa_peso_volumen
CREATE TABLE IF NOT EXISTS tarifa_peso_volumen (
    id BIGSERIAL PRIMARY KEY,
    peso_minimo_kg DECIMAL(10, 2) NOT NULL,
    peso_maximo_kg DECIMAL(10, 2) NOT NULL,
    volumen_minimo_m3 DECIMAL(10, 2) NOT NULL,
    volumen_maximo_m3 DECIMAL(10, 2) NOT NULL,
    multiplicador_costo DECIMAL(5, 2) DEFAULT 1.0,
    fecha_vigencia_desde DATE NOT NULL,
    fecha_vigencia_hasta DATE,
    activa BOOLEAN DEFAULT TRUE,
    fecha_creacion TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Tabla: costo_solicitud
CREATE TABLE IF NOT EXISTS costo_solicitud (
    id BIGSERIAL PRIMARY KEY,
    solicitud_id BIGINT NOT NULL,
    tipo VARCHAR(20) NOT NULL,
    
    -- Costos desglosados
    costo_gestion DECIMAL(10, 2) DEFAULT 0,
    costo_transporte DECIMAL(10, 2) DEFAULT 0,
    costo_combustible DECIMAL(10, 2) DEFAULT 0,
    costo_estadia DECIMAL(10, 2) DEFAULT 0,
    costo_adicionales DECIMAL(10, 2) DEFAULT 0,
    
    -- Total
    costo_total DECIMAL(12, 2) NOT NULL,
    
    -- Referencias a tarifas usadas
    tarifa_base_id BIGINT,
    tarifa_combustible_id BIGINT,
    tarifa_estadia_id BIGINT,
    
    fecha_calculo TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    observaciones TEXT,
    
    CONSTRAINT fk_costo_tarifa_base FOREIGN KEY (tarifa_base_id) REFERENCES tarifa_base(id),
    CONSTRAINT fk_costo_tarifa_combustible FOREIGN KEY (tarifa_combustible_id) REFERENCES tarifa_combustible(id),
    CONSTRAINT fk_costo_tarifa_estadia FOREIGN KEY (tarifa_estadia_id) REFERENCES tarifa_estadia(id),
    CONSTRAINT chk_costo_tipo CHECK (tipo IN ('ESTIMADO', 'FINAL'))
);

-- Tabla: costo_tramo
CREATE TABLE IF NOT EXISTS costo_tramo (
    id BIGSERIAL PRIMARY KEY,
    tramo_id BIGINT NOT NULL,
    costo_solicitud_id BIGINT NOT NULL,
    tipo VARCHAR(20) NOT NULL,
    
    -- Costos del tramo
    distancia_km DECIMAL(10, 2) NOT NULL,
    costo_por_km DECIMAL(8, 2) NOT NULL,
    costo_combustible DECIMAL(10, 2) DEFAULT 0,
    costo_estadia DECIMAL(10, 2) DEFAULT 0,
    horas_estadia DECIMAL(8, 2) DEFAULT 0,
    
    -- Total del tramo
    costo_total_tramo DECIMAL(10, 2) NOT NULL,
    
    fecha_calculo TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    
    CONSTRAINT fk_costo_tramo_solicitud FOREIGN KEY (costo_solicitud_id) REFERENCES costo_solicitud(id) ON DELETE CASCADE,
    CONSTRAINT chk_costo_tramo_tipo CHECK (tipo IN ('ESTIMADO', 'REAL'))
);

-- √çndices
CREATE INDEX IF NOT EXISTS idx_tarifa_base_vigencia ON tarifa_base(fecha_vigencia_desde, fecha_vigencia_hasta);
CREATE INDEX IF NOT EXISTS idx_tarifa_combustible_vigencia ON tarifa_combustible(fecha_vigencia_desde, fecha_vigencia_hasta);
CREATE INDEX IF NOT EXISTS idx_tarifa_estadia_vigencia ON tarifa_estadia(fecha_vigencia_desde, fecha_vigencia_hasta);
CREATE INDEX IF NOT EXISTS idx_costo_solicitud ON costo_solicitud(solicitud_id);
CREATE INDEX IF NOT EXISTS idx_costo_tipo ON costo_solicitud(tipo);
CREATE INDEX IF NOT EXISTS idx_costo_fecha ON costo_solicitud(fecha_calculo DESC);
CREATE INDEX IF NOT EXISTS idx_costo_tramo_tramo ON costo_tramo(tramo_id);
CREATE INDEX IF NOT EXISTS idx_costo_tramo_solicitud ON costo_tramo(costo_solicitud_id);

-- Datos de prueba - Tarifas vigentes
INSERT INTO tarifa_base (nombre, descripcion, costo_fijo_gestion, costo_adicional_por_tramo, fecha_vigencia_desde, activa) 
VALUES 
    ('Tarifa Est√°ndar 2025', 'Tarifa base para servicios de transporte', 5000.00, 800.00, '2025-01-01', TRUE)
ON CONFLICT DO NOTHING;

INSERT INTO tarifa_combustible (precio_por_litro, fecha_vigencia_desde, activa) 
VALUES 
    (950.00, '2025-01-01', TRUE)
ON CONFLICT DO NOTHING;

INSERT INTO tarifa_estadia (costo_por_dia, costo_por_hora, fecha_vigencia_desde, activa) 
VALUES 
    (2500.00, 120.00, '2025-01-01', TRUE)
ON CONFLICT DO NOTHING;

INSERT INTO tarifa_peso_volumen (peso_minimo_kg, peso_maximo_kg, volumen_minimo_m3, volumen_maximo_m3, 
                                 multiplicador_costo, fecha_vigencia_desde, activa) 
VALUES 
    (0, 5000, 0, 15, 1.0, '2025-01-01', TRUE),
    (5001, 10000, 15.01, 30, 1.2, '2025-01-01', TRUE),
    (10001, 20000, 30.01, 60, 1.5, '2025-01-01', TRUE)
ON CONFLICT DO NOTHING;

COMMENT ON TABLE tarifa_base IS 'Tarifas base del servicio de transporte';
COMMENT ON TABLE tarifa_combustible IS 'Precio del combustible para c√°lculo de costos';
COMMENT ON TABLE tarifa_estadia IS 'Costos por estad√≠a en dep√≥sitos';
COMMENT ON TABLE tarifa_peso_volumen IS 'Multiplicadores de costo seg√∫n peso y volumen';
COMMENT ON TABLE costo_solicitud IS 'Costos calculados para cada solicitud';
COMMENT ON TABLE costo_tramo IS 'Costos por tramo de ruta';



==================================================
RUTH: infrastructure/init-scripts/clients-init.sql
==================================================
-- Script de inicializaci√≥n para clients_db

-- Crear extensi√≥n para UUID si es necesaria
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

-- Tabla: cliente
CREATE TABLE IF NOT EXISTS cliente (
    id BIGSERIAL PRIMARY KEY,
    nombre VARCHAR(100) NOT NULL,
    apellido VARCHAR(100) NOT NULL,
    email VARCHAR(150) UNIQUE NOT NULL,
    telefono VARCHAR(20),
    direccion VARCHAR(255),
    keycloak_user_id VARCHAR(100) UNIQUE,
    fecha_registro TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    activo BOOLEAN DEFAULT TRUE
);

-- Tabla: contenedor
CREATE TABLE IF NOT EXISTS contenedor (
    id BIGSERIAL PRIMARY KEY,
    codigo VARCHAR(50) UNIQUE NOT NULL,
    peso_kg DECIMAL(10, 2) NOT NULL,
    volumen_m3 DECIMAL(10, 2) NOT NULL,
    alto_m DECIMAL(5, 2),
    ancho_m DECIMAL(5, 2),
    largo_m DECIMAL(5, 2),
    descripcion TEXT,
    cliente_id BIGINT NOT NULL,
    fecha_creacion TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT fk_contenedor_cliente FOREIGN KEY (cliente_id) REFERENCES cliente(id)
);

-- Tabla: ubicacion
CREATE TABLE IF NOT EXISTS ubicacion (
    id BIGSERIAL PRIMARY KEY,
    tipo VARCHAR(20) NOT NULL,
    direccion TEXT NOT NULL,
    latitud DECIMAL(10, 8) NOT NULL,
    longitud DECIMAL(11, 8) NOT NULL,
    descripcion TEXT,
    deposito_id BIGINT,
    CONSTRAINT chk_ubicacion_tipo CHECK (tipo IN ('ORIGEN', 'DESTINO', 'DEPOSITO'))
);

-- Tabla: solicitud
CREATE TABLE IF NOT EXISTS solicitud (
    id BIGSERIAL PRIMARY KEY,
    numero_solicitud VARCHAR(50) UNIQUE NOT NULL,
    contenedor_id BIGINT NOT NULL,
    cliente_id BIGINT NOT NULL,
    ubicacion_origen_id BIGINT NOT NULL,
    ubicacion_destino_id BIGINT NOT NULL,
    estado VARCHAR(30) NOT NULL,
    costo_estimado DECIMAL(12, 2),
    tiempo_estimado_horas INTEGER,
    costo_final DECIMAL(12, 2),
    tiempo_real_horas INTEGER,
    ruta_id BIGINT,
    fecha_creacion TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    fecha_ultima_actualizacion TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    observaciones TEXT,
    CONSTRAINT fk_solicitud_contenedor FOREIGN KEY (contenedor_id) REFERENCES contenedor(id),
    CONSTRAINT fk_solicitud_cliente FOREIGN KEY (cliente_id) REFERENCES cliente(id),
    CONSTRAINT fk_solicitud_origen FOREIGN KEY (ubicacion_origen_id) REFERENCES ubicacion(id),
    CONSTRAINT fk_solicitud_destino FOREIGN KEY (ubicacion_destino_id) REFERENCES ubicacion(id),
    CONSTRAINT chk_solicitud_estado CHECK (estado IN ('BORRADOR', 'PROGRAMADA', 'EN_TRANSITO', 'ENTREGADA', 'CANCELADA'))
);

-- Tabla: estado_solicitud
CREATE TABLE IF NOT EXISTS estado_solicitud (
    id BIGSERIAL PRIMARY KEY,
    solicitud_id BIGINT NOT NULL,
    estado VARCHAR(30) NOT NULL,
    fecha_hora TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    observacion TEXT,
    usuario VARCHAR(100),
    CONSTRAINT fk_estado_solicitud FOREIGN KEY (solicitud_id) REFERENCES solicitud(id) ON DELETE CASCADE
);

-- √çndices
CREATE INDEX IF NOT EXISTS idx_contenedor_cliente ON contenedor(cliente_id);
CREATE INDEX IF NOT EXISTS idx_contenedor_codigo ON contenedor(codigo);
CREATE INDEX IF NOT EXISTS idx_ubicacion_coords ON ubicacion(latitud, longitud);
CREATE INDEX IF NOT EXISTS idx_solicitud_numero ON solicitud(numero_solicitud);
CREATE INDEX IF NOT EXISTS idx_solicitud_cliente ON solicitud(cliente_id);
CREATE INDEX IF NOT EXISTS idx_solicitud_estado ON solicitud(estado);
CREATE INDEX IF NOT EXISTS idx_solicitud_contenedor ON solicitud(contenedor_id);
CREATE INDEX IF NOT EXISTS idx_solicitud_fecha_creacion ON solicitud(fecha_creacion DESC);
CREATE INDEX IF NOT EXISTS idx_estado_solicitud_solicitud ON estado_solicitud(solicitud_id);
CREATE INDEX IF NOT EXISTS idx_estado_solicitud_fecha ON estado_solicitud(fecha_hora);
CREATE INDEX IF NOT EXISTS idx_estado_solicitud_comp ON estado_solicitud(solicitud_id, fecha_hora DESC);

-- Datos de prueba (opcional)
-- INSERT INTO cliente (nombre, apellido, email, telefono, direccion) 
-- VALUES ('Juan', 'P√©rez', 'juan.perez@example.com', '+5491112345678', 'Av. Corrientes 1234, CABA');

COMMENT ON TABLE cliente IS 'Almacena informaci√≥n de los clientes que solicitan transporte';
COMMENT ON TABLE contenedor IS 'Contenedores a transportar con sus dimensiones';
COMMENT ON TABLE ubicacion IS 'Ubicaciones geogr√°ficas (origen, destino, dep√≥sitos)';
COMMENT ON TABLE solicitud IS 'Solicitudes de transporte con estado y costos';
COMMENT ON TABLE estado_solicitud IS 'Historial de cambios de estado de las solicitudes';



==================================================
RUTH: infrastructure/init-scripts/logistics-init.sql
==================================================
-- Script de inicializaci√≥n para logistics_db

-- Tabla: deposito
CREATE TABLE IF NOT EXISTS deposito (
    id BIGSERIAL PRIMARY KEY,
    codigo VARCHAR(50) UNIQUE NOT NULL,
    nombre VARCHAR(150) NOT NULL,
    direccion TEXT NOT NULL,
    latitud DECIMAL(10, 8) NOT NULL,
    longitud DECIMAL(11, 8) NOT NULL,
    capacidad_maxima_contenedores INTEGER DEFAULT 100,
    contenedores_actuales INTEGER DEFAULT 0,
    activo BOOLEAN DEFAULT TRUE,
    fecha_creacion TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Tabla: transportista
CREATE TABLE IF NOT EXISTS transportista (
    id BIGSERIAL PRIMARY KEY,
    nombre VARCHAR(100) NOT NULL,
    apellido VARCHAR(100) NOT NULL,
    dni VARCHAR(20) UNIQUE NOT NULL,
    telefono VARCHAR(20) NOT NULL,
    email VARCHAR(150),
    licencia_conducir VARCHAR(50) NOT NULL,
    keycloak_user_id VARCHAR(100) UNIQUE,
    activo BOOLEAN DEFAULT TRUE,
    fecha_registro TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Tabla: camion
CREATE TABLE IF NOT EXISTS camion (
    id BIGSERIAL PRIMARY KEY,
    dominio VARCHAR(20) UNIQUE NOT NULL,
    marca VARCHAR(50),
    modelo VARCHAR(50),
    anio INTEGER,
    capacidad_peso_kg DECIMAL(10, 2) NOT NULL,
    capacidad_volumen_m3 DECIMAL(10, 2) NOT NULL,
    consumo_combustible_km_litro DECIMAL(5, 2) NOT NULL,
    costo_base_por_km DECIMAL(8, 2) NOT NULL,
    transportista_id BIGINT,
    estado VARCHAR(20) DEFAULT 'DISPONIBLE',
    activo BOOLEAN DEFAULT TRUE,
    fecha_registro TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT fk_camion_transportista FOREIGN KEY (transportista_id) REFERENCES transportista(id),
    CONSTRAINT chk_camion_estado CHECK (estado IN ('DISPONIBLE', 'OCUPADO', 'MANTENIMIENTO', 'INACTIVO'))
);

-- Tabla: ruta
CREATE TABLE IF NOT EXISTS ruta (
    id BIGSERIAL PRIMARY KEY,
    solicitud_id BIGINT NOT NULL,
    tipo VARCHAR(20) DEFAULT 'PROPUESTA',
    cantidad_tramos INTEGER NOT NULL,
    cantidad_depositos INTEGER DEFAULT 0,
    distancia_total_km DECIMAL(10, 2),
    tiempo_estimado_total_horas INTEGER,
    costo_estimado_total DECIMAL(12, 2),
    costo_real_total DECIMAL(12, 2),
    fecha_creacion TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    seleccionada BOOLEAN DEFAULT FALSE,
    CONSTRAINT chk_ruta_tipo CHECK (tipo IN ('PROPUESTA', 'ASIGNADA'))
);

-- Tabla: tramo
CREATE TABLE IF NOT EXISTS tramo (
    id BIGSERIAL PRIMARY KEY,
    ruta_id BIGINT NOT NULL,
    numero_orden INTEGER NOT NULL,
    tipo_tramo VARCHAR(30) NOT NULL,
    
    -- Origen del tramo
    origen_tipo VARCHAR(20) NOT NULL,
    origen_direccion TEXT NOT NULL,
    origen_latitud DECIMAL(10, 8) NOT NULL,
    origen_longitud DECIMAL(11, 8) NOT NULL,
    origen_deposito_id BIGINT,
    
    -- Destino del tramo
    destino_tipo VARCHAR(20) NOT NULL,
    destino_direccion TEXT NOT NULL,
    destino_latitud DECIMAL(10, 8) NOT NULL,
    destino_longitud DECIMAL(11, 8) NOT NULL,
    destino_deposito_id BIGINT,
    
    -- Datos del tramo
    distancia_km DECIMAL(10, 2) NOT NULL,
    estado VARCHAR(20) DEFAULT 'ESTIMADO',
    camion_id BIGINT,
    
    -- Tiempos
    fecha_hora_inicio_estimada TIMESTAMP,
    fecha_hora_fin_estimada TIMESTAMP,
    fecha_hora_inicio_real TIMESTAMP,
    fecha_hora_fin_real TIMESTAMP,
    
    -- Costos
    costo_estimado DECIMAL(10, 2),
    costo_real DECIMAL(10, 2),
    
    -- Observaciones
    observaciones TEXT,
    fecha_creacion TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    
    CONSTRAINT fk_tramo_ruta FOREIGN KEY (ruta_id) REFERENCES ruta(id) ON DELETE CASCADE,
    CONSTRAINT fk_tramo_camion FOREIGN KEY (camion_id) REFERENCES camion(id),
    CONSTRAINT fk_tramo_origen_deposito FOREIGN KEY (origen_deposito_id) REFERENCES deposito(id),
    CONSTRAINT fk_tramo_destino_deposito FOREIGN KEY (destino_deposito_id) REFERENCES deposito(id),
    CONSTRAINT chk_tramo_tipo CHECK (tipo_tramo IN ('ORIGEN_DEPOSITO', 'DEPOSITO_DEPOSITO', 'DEPOSITO_DESTINO', 'ORIGEN_DESTINO')),
    CONSTRAINT chk_tramo_estado CHECK (estado IN ('ESTIMADO', 'ASIGNADO', 'INICIADO', 'FINALIZADO'))
);

-- √çndices
CREATE INDEX IF NOT EXISTS idx_deposito_codigo ON deposito(codigo);
CREATE INDEX IF NOT EXISTS idx_deposito_coords ON deposito(latitud, longitud);
CREATE INDEX IF NOT EXISTS idx_transportista_dni ON transportista(dni);
CREATE INDEX IF NOT EXISTS idx_camion_dominio ON camion(dominio);
CREATE INDEX IF NOT EXISTS idx_camion_estado ON camion(estado);
CREATE INDEX IF NOT EXISTS idx_camion_transportista ON camion(transportista_id);
CREATE INDEX IF NOT EXISTS idx_camion_capacidad ON camion(capacidad_peso_kg, capacidad_volumen_m3);
CREATE INDEX IF NOT EXISTS idx_ruta_solicitud ON ruta(solicitud_id);
CREATE INDEX IF NOT EXISTS idx_ruta_tipo ON ruta(tipo);
CREATE INDEX IF NOT EXISTS idx_tramo_ruta ON tramo(ruta_id);
CREATE INDEX IF NOT EXISTS idx_tramo_camion ON tramo(camion_id);
CREATE INDEX IF NOT EXISTS idx_tramo_estado ON tramo(estado);
CREATE INDEX IF NOT EXISTS idx_tramo_orden ON tramo(ruta_id, numero_orden);
CREATE INDEX IF NOT EXISTS idx_tramo_fechas ON tramo(fecha_hora_inicio_real, fecha_hora_fin_real);

-- Datos de prueba
-- Dep√≥sitos de ejemplo
INSERT INTO deposito (codigo, nombre, direccion, latitud, longitud, capacidad_maxima_contenedores) 
VALUES 
    ('DEP-001', 'Dep√≥sito CABA Norte', 'Av. Gral Paz 1234, CABA', -34.5869, -58.4398, 150),
    ('DEP-002', 'Dep√≥sito Zona Oeste', 'Ruta 3 Km 25, La Matanza', -34.6892, -58.5897, 200),
    ('DEP-003', 'Dep√≥sito Pilar', 'Panamericana Km 50, Pilar', -34.4587, -58.9142, 100)
ON CONFLICT (codigo) DO NOTHING;

-- Transportistas de ejemplo
INSERT INTO transportista (nombre, apellido, dni, telefono, licencia_conducir) 
VALUES 
    ('Carlos', 'Gonz√°lez', '12345678', '+5491123456789', 'LIC-001-2025'),
    ('Mar√≠a', 'Rodr√≠guez', '23456789', '+5491134567890', 'LIC-002-2025'),
    ('Pedro', 'Mart√≠nez', '34567890', '+5491145678901', 'LIC-003-2025')
ON CONFLICT (dni) DO NOTHING;

-- Camiones de ejemplo
INSERT INTO camion (dominio, marca, modelo, anio, capacidad_peso_kg, capacidad_volumen_m3, 
                    consumo_combustible_km_litro, costo_base_por_km, transportista_id, estado) 
VALUES 
    ('AA123BB', 'Mercedes-Benz', 'Actros 2651', 2020, 15000.00, 40.00, 0.35, 150.00, 1, 'DISPONIBLE'),
    ('CC456DD', 'Scania', 'R450', 2021, 18000.00, 50.00, 0.40, 180.00, 2, 'DISPONIBLE'),
    ('EE789FF', 'Volvo', 'FH16', 2019, 20000.00, 55.00, 0.45, 200.00, 3, 'DISPONIBLE')
ON CONFLICT (dominio) DO NOTHING;

COMMENT ON TABLE deposito IS 'Dep√≥sitos intermedios para almacenamiento temporal de contenedores';
COMMENT ON TABLE transportista IS 'Conductores de los camiones';
COMMENT ON TABLE camion IS 'Flota de camiones con capacidades y costos';
COMMENT ON TABLE ruta IS 'Rutas de transporte con m√∫ltiples tramos';
COMMENT ON TABLE tramo IS 'Segmentos individuales de una ruta entre ubicaciones';



==================================================
RUTH: infrastructure/keycloak/realm-export.json
==================================================
{
  "realm": "transportes-realm",
  "enabled": true,
  "displayName": "Sistema de Transportes",
  "displayNameHtml": "<div class=\"kc-logo-text\"><span>Sistema de Transportes</span></div>",
  "registrationAllowed": true,
  "registrationEmailAsUsername": true,
  "rememberMe": true,
  "verifyEmail": false,
  "loginWithEmailAllowed": true,
  "duplicateEmailsAllowed": false,
  "resetPasswordAllowed": true,
  "editUsernameAllowed": false,
  "bruteForceProtected": true,
  "sslRequired": "none",
  "roles": {
    "realm": [
      {
        "name": "CLIENTE",
        "description": "Rol para clientes que solicitan transporte",
        "composite": false,
        "clientRole": false
      },
      {
        "name": "OPERADOR",
        "description": "Rol para operadores/administradores del sistema",
        "composite": false,
        "clientRole": false
      },
      {
        "name": "TRANSPORTISTA",
        "description": "Rol para transportistas/choferes",
        "composite": false,
        "clientRole": false
      }
    ]
  },
  "clients": [
    {
      "clientId": "gateway-client",
      "name": "API Gateway Client",
      "description": "Cliente confidencial para API Gateway",
      "enabled": true,
      "clientAuthenticatorType": "client-secret",
      "secret": "gateway-secret-key-2025",
      "publicClient": false,
      "standardFlowEnabled": true,
      "implicitFlowEnabled": false,
      "directAccessGrantsEnabled": true,
      "serviceAccountsEnabled": true,
      "authorizationServicesEnabled": false,
      "redirectUris": [
        "http://localhost:8080/*",
        "http://gateway-service:8080/*"
      ],
      "webOrigins": [
        "http://localhost:8080",
        "http://gateway-service:8080"
      ],
      "protocol": "openid-connect",
      "attributes": {
        "access.token.lifespan": "1800",
        "client.secret.creation.time": "1704067200"
      },
      "fullScopeAllowed": true
    },
    {
      "clientId": "public-app",
      "name": "Public Application Client",
      "description": "Cliente p√∫blico para aplicaciones frontend",
      "enabled": true,
      "publicClient": true,
      "standardFlowEnabled": true,
      "implicitFlowEnabled": false,
      "directAccessGrantsEnabled": true,
      "serviceAccountsEnabled": false,
      "redirectUris": [
        "http://localhost:*",
        "http://127.0.0.1:*"
      ],
      "webOrigins": [
        "http://localhost:8080",
        "http://localhost:3000",
        "http://localhost:4200"
      ],
      "protocol": "openid-connect",
      "fullScopeAllowed": true
    },
    {
      "clientId": "clients-service",
      "name": "Clients Service",
      "description": "Microservicio de clientes",
      "enabled": true,
      "clientAuthenticatorType": "client-secret",
      "secret": "clients-service-secret",
      "publicClient": false,
      "serviceAccountsEnabled": true,
      "directAccessGrantsEnabled": true,
      "protocol": "openid-connect",
      "fullScopeAllowed": true
    },
    {
      "clientId": "logistics-service",
      "name": "Logistics Service",
      "description": "Microservicio de log√≠stica",
      "enabled": true,
      "clientAuthenticatorType": "client-secret",
      "secret": "logistics-service-secret",
      "publicClient": false,
      "serviceAccountsEnabled": true,
      "directAccessGrantsEnabled": true,
      "protocol": "openid-connect",
      "fullScopeAllowed": true
    },
    {
      "clientId": "billing-service",
      "name": "Billing Service",
      "description": "Microservicio de facturaci√≥n",
      "enabled": true,
      "clientAuthenticatorType": "client-secret",
      "secret": "billing-service-secret",
      "publicClient": false,
      "serviceAccountsEnabled": true,
      "directAccessGrantsEnabled": true,
      "protocol": "openid-connect",
      "fullScopeAllowed": true
    }
  ],
  "users": [
    {
      "username": "cliente1@example.com",
      "email": "cliente1@example.com",
      "firstName": "Juan",
      "lastName": "P√©rez",
      "enabled": true,
      "emailVerified": true,
      "credentials": [
        {
          "type": "password",
          "value": "Cliente123!",
          "temporary": false
        }
      ],
      "realmRoles": [
        "CLIENTE"
      ]
    },
    {
      "username": "operador1@example.com",
      "email": "operador1@example.com",
      "firstName": "Mar√≠a",
      "lastName": "Gonz√°lez",
      "enabled": true,
      "emailVerified": true,
      "credentials": [
        {
          "type": "password",
          "value": "Operador123!",
          "temporary": false
        }
      ],
      "realmRoles": [
        "OPERADOR"
      ]
    },
    {
      "username": "transportista1@example.com",
      "email": "transportista1@example.com",
      "firstName": "Carlos",
      "lastName": "Rodr√≠guez",
      "enabled": true,
      "emailVerified": true,
      "credentials": [
        {
          "type": "password",
          "value": "Transportista123!",
          "temporary": false
        }
      ],
      "realmRoles": [
        "TRANSPORTISTA"
      ]
    }
  ],
  "defaultRoles": [],
  "requiredCredentials": [
    "password"
  ],
  "passwordPolicy": "length(8) and digits(1) and specialChars(1) and upperCase(1) and lowerCase(1)",
  "otpPolicyType": "totp",
  "otpPolicyAlgorithm": "HmacSHA1",
  "otpPolicyInitialCounter": 0,
  "otpPolicyDigits": 6,
  "otpPolicyLookAheadWindow": 1,
  "otpPolicyPeriod": 30,
  "accessTokenLifespan": 1800,
  "accessTokenLifespanForImplicitFlow": 900,
  "ssoSessionIdleTimeout": 1800,
  "ssoSessionMaxLifespan": 36000,
  "offlineSessionIdleTimeout": 2592000,
  "accessCodeLifespan": 60,
  "accessCodeLifespanUserAction": 300,
  "accessCodeLifespanLogin": 1800,
  "actionTokenGeneratedByAdminLifespan": 43200,
  "actionTokenGeneratedByUserLifespan": 300,
  "oauth2DeviceCodeLifespan": 600,
  "oauth2DevicePollingInterval": 5,
  "internationalizationEnabled": true,
  "supportedLocales": [
    "es",
    "en"
  ],
  "defaultLocale": "es",
  "eventsEnabled": true,
  "eventsListeners": [
    "jboss-logging"
  ],
  "enabledEventTypes": [
    "LOGIN",
    "LOGIN_ERROR",
    "REGISTER",
    "REGISTER_ERROR",
    "LOGOUT",
    "LOGOUT_ERROR"
  ],
  "adminEventsEnabled": true,
  "adminEventsDetailsEnabled": true
}



==================================================
RUTH: logistics-service/Dockerfile
==================================================
# Usamos solo una etapa - esperamos que el JAR ya est√© compilado
FROM eclipse-temurin:17-jre-alpine
WORKDIR /app

# Copiamos el JAR ya compilado desde el host
COPY target/logistics-service-1.0.0.jar app.jar

EXPOSE 8082

ENTRYPOINT ["java", "-jar", "app.jar"]



==================================================
RUTH: logistics-service/pom.xml
==================================================
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 
         http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <parent>
        <groupId>com.transportes</groupId>
        <artifactId>tpi-transportes</artifactId>
        <version>1.0.0</version>
    </parent>

    <artifactId>logistics-service</artifactId>
    <name>Logistics Service</name>
    <description>Microservicio para gesti√≥n de log√≠stica, rutas y camiones</description>

    <dependencies>
        <!-- Spring Boot Starters -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-jpa</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-validation</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-actuator</artifactId>
        </dependency>

        <!-- Spring Security + OAuth2 Resource Server -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-security</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-oauth2-resource-server</artifactId>
        </dependency>

        <!-- Spring Cloud OpenFeign -->
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-openfeign</artifactId>
        </dependency>

        <!-- Database -->
        <dependency>
            <groupId>org.postgresql</groupId>
            <artifactId>postgresql</artifactId>
            <scope>runtime</scope>
        </dependency>

        <!-- Lombok -->
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <optional>true</optional>
        </dependency>

        <!-- MapStruct -->
        <dependency>
            <groupId>org.mapstruct</groupId>
            <artifactId>mapstruct</artifactId>
        </dependency>

        <!-- Springdoc OpenAPI -->
        <dependency>
            <groupId>org.springdoc</groupId>
            <artifactId>springdoc-openapi-starter-webmvc-ui</artifactId>
        </dependency>

        <!-- Keycloak Admin Client (para registro de transportistas) -->
        <dependency>
            <groupId>org.keycloak</groupId>
            <artifactId>keycloak-admin-client</artifactId>
            <version>23.0.0</version>
        </dependency>

        <!-- Test -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>

        <dependency>
            <groupId>org.springframework.security</groupId>
            <artifactId>spring-security-test</artifactId>
            <scope>test</scope>
        </dependency>

        <dependency>
            <groupId>com.h2database</groupId>
            <artifactId>h2</artifactId>
            <scope>test</scope>
        </dependency>
    </dependencies>

    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
                <executions>
                    <execution>
                        <goals>
                            <goal>repackage</goal>
                        </goals>
                    </execution>
                </executions>
            </plugin>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
            </plugin>
        </plugins>
    </build>

</project>



==================================================
RUTH: logistics-service/src/main/java/com/transportes/logistics/LogisticsServiceApplication.java
==================================================
package com.transportes.logistics;

import com.transportes.logistics.config.FeignClientConfig; // <--- IMPORTAR
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.openfeign.EnableFeignClients;

@SpringBootApplication
// AGREGAR: defaultConfiguration = FeignClientConfig.class
@EnableFeignClients(defaultConfiguration = FeignClientConfig.class)
public class LogisticsServiceApplication {

    public static void main(String[] args) {
        SpringApplication.run(LogisticsServiceApplication.class, args);
    }
}


==================================================
RUTH: logistics-service/src/main/java/com/transportes/logistics/client/BillingClient.java
==================================================
package com.transportes.logistics.client;

import org.springframework.cloud.openfeign.FeignClient;
import org.springframework.web.bind.annotation.*;

import java.math.BigDecimal;
import java.util.List;

@FeignClient(name = "billing-service", url = "${billing.service.url}")
public interface BillingClient {

    @PostMapping("/api/costos/calcular-estimado")
    CostoEstimadoResponse calcularCostoEstimado(@RequestBody CalcularCostoRequest request);

    @PostMapping("/api/costos/calcular-real")
    CostoEstimadoResponse calcularCostoReal(@RequestBody CalcularCostoRequest request);

    // DTOs internos (deben coincidir con billing-service)
    record CalcularCostoRequest(
        Long solicitudId,
        List<TramoRequest> tramos,
        BigDecimal pesoTotalKg,
        BigDecimal volumenTotalM3,
        Integer diasEstadiaEstimados,
        BigDecimal horasEstadiaTotales,
        BigDecimal costosAdicionales
    ) {}

    record TramoRequest(
        Long tramoId,
        BigDecimal distanciaKm,
        BigDecimal costoBasePorKm,
        BigDecimal consumoKmLitro
    ) {}

    record CostoEstimadoResponse(
        BigDecimal costoTotal,
        BigDecimal costoGestion,
        BigDecimal costoTransporte,
        BigDecimal costoCombustible,
        BigDecimal costoEstadia
    ) {}
}



==================================================
RUTH: logistics-service/src/main/java/com/transportes/logistics/client/ClientsClient.java
==================================================
package com.transportes.logistics.client;

import org.springframework.cloud.openfeign.FeignClient;
import org.springframework.web.bind.annotation.*;

@FeignClient(name = "clients-service", url = "${clients.service.url}")
public interface ClientsClient {

    @PutMapping("/api/solicitudes/{id}/estado")
    void actualizarEstado(@PathVariable("id") Long id, @RequestBody ActualizarEstadoRequest request);

    @GetMapping("/api/solicitudes/internal/{id}")
    SolicitudResponse obtenerSolicitud(@PathVariable("id") Long id);

    record ActualizarEstadoRequest(
        String estado,
        String observacion
    ) {}

    record SolicitudResponse(
        Long id,
        String numeroSolicitud,
        String estado,
        ContenedorData contenedor,
        UbicacionData origen,
        UbicacionData destino
    ) {}

    record ContenedorData(
        Long id,
        java.math.BigDecimal pesoKg,
        java.math.BigDecimal volumenM3
    ) {}

    record UbicacionData(
        Long id,
        String direccion,
        java.math.BigDecimal latitud,
        java.math.BigDecimal longitud
    ) {}
}



==================================================
RUTH: logistics-service/src/main/java/com/transportes/logistics/client/OsrmClient.java
==================================================
package com.transportes.logistics.client;

import lombok.Data;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;
import org.springframework.web.client.RestTemplate;
import java.math.BigDecimal;
import java.util.List;

@Slf4j
@Component
@RequiredArgsConstructor
public class OsrmClient {

    private final RestTemplate restTemplate = new RestTemplate();

    @Value("${osrm.service.url:http://localhost:5000}")
    private String osrmUrl;

    public RouteResponse calcularRuta(BigDecimal origenLat, BigDecimal origenLon,
                                      BigDecimal destinoLat, BigDecimal destinoLon) {
        try {
            // OSRM usa formato: lon,lat (invertido)
            String url = String.format("%s/route/v1/driving/%s,%s;%s,%s?overview=false",
                    osrmUrl,
                    origenLon, origenLat,
                    destinoLon, destinoLat);

            log.debug("Llamando a OSRM: {}", url);

            OsrmResponse response = restTemplate.getForObject(url, OsrmResponse.class);

            if (response != null && "Ok".equals(response.getCode()) && 
                !response.getRoutes().isEmpty()) {
                
                OsrmRoute route = response.getRoutes().get(0);
                
                return RouteResponse.builder()
                        .distanciaMetros(route.getDistance())
                        .distanciaKm(BigDecimal.valueOf(route.getDistance() / 1000.0))
                        .duracionSegundos(route.getDuration().intValue())
                        .duracionHoras((int) Math.ceil(route.getDuration() / 3600.0))
                        .build();
            } else {
                log.warn("OSRM no devolvi√≥ ruta v√°lida");
                return calcularRutaFallback(origenLat, origenLon, destinoLat, destinoLon);
            }

        } catch (Exception e) {
            log.error("Error al consultar OSRM", e);
            return calcularRutaFallback(origenLat, origenLon, destinoLat, destinoLon);
        }
    }

    private RouteResponse calcularRutaFallback(BigDecimal lat1, BigDecimal lon1,
                                               BigDecimal lat2, BigDecimal lon2) {
        // C√°lculo aproximado usando f√≥rmula de Haversine
        double distanciaKm = calcularDistanciaHaversine(
                lat1.doubleValue(), lon1.doubleValue(),
                lat2.doubleValue(), lon2.doubleValue());

        // Estimaci√≥n: 60 km/h promedio
        int duracionHoras = (int) Math.ceil(distanciaKm / 60.0);

        log.warn("Usando c√°lculo fallback de distancia: {} km", distanciaKm);

        return RouteResponse.builder()
                .distanciaKm(BigDecimal.valueOf(distanciaKm))
                .distanciaMetros(distanciaKm * 1000)
                .duracionHoras(duracionHoras)
                .duracionSegundos(duracionHoras * 3600)
                .build();
    }

    private double calcularDistanciaHaversine(double lat1, double lon1, double lat2, double lon2) {
        final double R = 6371; // Radio de la Tierra en km

        double latDistance = Math.toRadians(lat2 - lat1);
        double lonDistance = Math.toRadians(lon2 - lon1);

        double a = Math.sin(latDistance / 2) * Math.sin(latDistance / 2)
                + Math.cos(Math.toRadians(lat1)) * Math.cos(Math.toRadians(lat2))
                * Math.sin(lonDistance / 2) * Math.sin(lonDistance / 2);

        double c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));

        return R * c;
    }

    @Data
    public static class OsrmResponse {
        private String code;
        private List<OsrmRoute> routes;
    }

    @Data
    public static class OsrmRoute {
        private Double distance; // en metros
        private Double duration; // en segundos
    }

    @Data
    @lombok.Builder
    public static class RouteResponse {
        private BigDecimal distanciaKm;
        private Double distanciaMetros;
        private Integer duracionHoras;
        private Integer duracionSegundos;
    }
}



==================================================
RUTH: logistics-service/src/main/java/com/transportes/logistics/config/FeignClientConfig.java
==================================================
package com.transportes.logistics.config;

import feign.RequestInterceptor;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.http.HttpHeaders;
import org.springframework.web.context.request.RequestContextHolder;
import org.springframework.web.context.request.ServletRequestAttributes;

@Configuration
public class FeignClientConfig {
    @Bean
    public RequestInterceptor requestInterceptor() {
        return template -> {
            ServletRequestAttributes attributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();
            if (attributes != null) {
                String authHeader = attributes.getRequest().getHeader(HttpHeaders.AUTHORIZATION);
                if (authHeader != null) {
                    template.header(HttpHeaders.AUTHORIZATION, authHeader);
                }
            }
        };
    }
}


==================================================
RUTH: logistics-service/src/main/java/com/transportes/logistics/config/SecurityConfig.java
==================================================
package com.transportes.logistics.config;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.oauth2.jwt.Jwt;
import org.springframework.security.oauth2.jwt.JwtDecoder;
import org.springframework.security.oauth2.jwt.NimbusJwtDecoder;
import org.springframework.security.oauth2.server.resource.authentication.JwtAuthenticationConverter;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.core.convert.converter.Converter;

import java.util.Collection;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

@Configuration
@EnableWebSecurity
@EnableMethodSecurity
public class SecurityConfig {

    @Value("${spring.security.oauth2.resourceserver.jwt.jwk-set-uri}")
    private String jwkSetUri;

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
                .csrf(csrf -> csrf.disable())
                .authorizeHttpRequests(auth -> auth
                        .requestMatchers("/actuator/**").permitAll()
                        .requestMatchers("/swagger-ui/**", "/v3/api-docs/**").permitAll()
                        .anyRequest().authenticated()
                )
                .oauth2ResourceServer(oauth2 -> oauth2
                        .jwt(jwt -> jwt
                                .decoder(jwtDecoder())
                                .jwtAuthenticationConverter(jwtAuthenticationConverter())
                        )
                )
                .sessionManagement(session -> session
                        .sessionCreationPolicy(SessionCreationPolicy.STATELESS)
                );
        return http.build();
    }

    @Bean
    public JwtDecoder jwtDecoder() {
        return NimbusJwtDecoder.withJwkSetUri(jwkSetUri).build();
    }

    @Bean
    public JwtAuthenticationConverter jwtAuthenticationConverter() {
        JwtAuthenticationConverter converter = new JwtAuthenticationConverter();
        converter.setJwtGrantedAuthoritiesConverter(new Converter<Jwt, Collection<GrantedAuthority>>() {
            @Override
            public Collection<GrantedAuthority> convert(Jwt jwt) {
                Map<String, Object> realmAccess = jwt.getClaim("realm_access");
                Collection<String> roles = List.of();
                if (realmAccess != null && !realmAccess.isEmpty()) {
                    roles = (Collection<String>) realmAccess.get("roles");
                }

                return roles.stream()
                        .map(role -> new SimpleGrantedAuthority("ROLE_" + role))
                        .collect(Collectors.toList());
            }
        });

        // Esta l√≠nea es clave para que lea el email del token como principal
        converter.setPrincipalClaimName("email");

        return converter;
    }
}


==================================================
RUTH: logistics-service/src/main/java/com/transportes/logistics/controller/CamionController.java
==================================================
package com.transportes.logistics.controller;

import com.transportes.logistics.dto.CamionDTO;
import com.transportes.logistics.entity.Camion;
import com.transportes.logistics.entity.Transportista;
import com.transportes.logistics.repository.CamionRepository;
import com.transportes.logistics.repository.TransportistaRepository;
import com.transportes.logistics.service.CamionService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.security.SecurityRequirement;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

import java.math.BigDecimal;
import java.net.URI;
import java.util.List;

@Tag(name = "Camiones", description = "API para gesti√≥n de camiones")
@RestController
@RequestMapping("/api/camiones")
@RequiredArgsConstructor
@SecurityRequirement(name = "bearer-jwt")
public class CamionController {

    private final CamionService camionService;
    private final CamionRepository camionRepository;
    private final TransportistaRepository transportistaRepository;

    @Operation(summary = "Obtener todos los camiones")
    @PreAuthorize("hasRole('OPERADOR')")
    @GetMapping
    public ResponseEntity<List<CamionDTO>> obtenerTodos() {
        List<CamionDTO> camiones = camionService.obtenerTodosLosCamiones();
        return ResponseEntity.ok(camiones);
    }

    @Operation(summary = "Obtener camiones disponibles", description = "Filtra por capacidad de peso y volumen")
    @PreAuthorize("hasRole('OPERADOR')")
    @GetMapping("/disponibles")
    public ResponseEntity<List<CamionDTO>> obtenerDisponibles(
            @RequestParam BigDecimal pesoKg,
            @RequestParam BigDecimal volumenM3) {

        List<CamionDTO> camiones = camionService.obtenerCamionesDisponibles(pesoKg, volumenM3);
        return ResponseEntity.ok(camiones);
    }

    @PostMapping
    @PreAuthorize("hasRole('OPERADOR')")
    @Operation(summary = "Crear nuevo cami√≥n")
    public ResponseEntity<CamionDTO> crear(@Valid @RequestBody CamionDTO camionDTO) {
        // Buscar transportista si se proporciona
        Transportista transportista = null;
        if (camionDTO.getTransportistaId() != null) {
            transportista = transportistaRepository.findById(camionDTO.getTransportistaId())
                    .orElseThrow(() -> new RuntimeException("Transportista no encontrado"));
        }

        Camion camion = Camion.builder()
                .dominio(camionDTO.getDominio())
                .marca(camionDTO.getMarca())
                .modelo(camionDTO.getModelo())
                .anio(camionDTO.getAnio())
                .capacidadPesoKg(camionDTO.getCapacidadPesoKg())
                .capacidadVolumenM3(camionDTO.getCapacidadVolumenM3())
                .consumoCombustibleKmLitro(camionDTO.getConsumoCombustibleKmLitro())
                .costoBasePorKm(camionDTO.getCostoBasePorKm())
                .transportista(transportista)
                .estado(camionDTO.getEstado() != null ?
                        camionDTO.getEstado() :
                        Camion.EstadoCamion.DISPONIBLE)
                .activo(camionDTO.getActivo() != null ? camionDTO.getActivo() : true)
                .build();

        Camion guardado = camionRepository.save(camion);
        return ResponseEntity.created(URI.create("/api/camiones/" + guardado.getId()))
                .body(convertirADTO(guardado));
    }

    @PutMapping("/{id}")
    @PreAuthorize("hasRole('OPERADOR')")
    @Operation(summary = "Actualizar cami√≥n")
    public ResponseEntity<CamionDTO> actualizar(@PathVariable Long id, @Valid @RequestBody CamionDTO camionDTO) {
        return camionRepository.findById(id)
                .map(camion -> {
                    // Actualizar transportista si se proporciona
                    if (camionDTO.getTransportistaId() != null) {
                        Transportista transportista = transportistaRepository.findById(camionDTO.getTransportistaId())
                                .orElseThrow(() -> new RuntimeException("Transportista no encontrado"));
                        camion.setTransportista(transportista);
                    }

                    // Actualizar datos del cami√≥n
                    if (camionDTO.getDominio() != null) {
                        camion.setDominio(camionDTO.getDominio());
                    }
                    if (camionDTO.getMarca() != null) {
                        camion.setMarca(camionDTO.getMarca());
                    }
                    if (camionDTO.getModelo() != null) {
                        camion.setModelo(camionDTO.getModelo());
                    }
                    if (camionDTO.getAnio() != null) {
                        camion.setAnio(camionDTO.getAnio());
                    }
                    if (camionDTO.getCapacidadPesoKg() != null) {
                        camion.setCapacidadPesoKg(camionDTO.getCapacidadPesoKg());
                    }
                    if (camionDTO.getCapacidadVolumenM3() != null) {
                        camion.setCapacidadVolumenM3(camionDTO.getCapacidadVolumenM3());
                    }
                    if (camionDTO.getConsumoCombustibleKmLitro() != null) {
                        camion.setConsumoCombustibleKmLitro(camionDTO.getConsumoCombustibleKmLitro());
                    }
                    if (camionDTO.getCostoBasePorKm() != null) {
                        camion.setCostoBasePorKm(camionDTO.getCostoBasePorKm());
                    }
                    if (camionDTO.getEstado() != null) {
                        camion.setEstado(camionDTO.getEstado());
                    }
                    if (camionDTO.getActivo() != null) {
                        camion.setActivo(camionDTO.getActivo());
                    }

                    return ResponseEntity.ok(convertirADTO(camionRepository.save(camion)));
                })
                .orElse(ResponseEntity.notFound().build());
    }

    @DeleteMapping("/{id}")
    @PreAuthorize("hasRole('OPERADOR')")
    @Operation(summary = "Eliminar cami√≥n (soft delete)")
    public ResponseEntity<Void> eliminar(@PathVariable Long id) {
        return camionRepository.findById(id)
                .map(camion -> {
                    camion.setActivo(false);
                    camion.setEstado(Camion.EstadoCamion.INACTIVO);
                    camionRepository.save(camion);
                    return ResponseEntity.noContent().<Void>build();
                })
                .orElse(ResponseEntity.notFound().build());
    }

    private CamionDTO convertirADTO(Camion camion) {
        return CamionDTO.builder()
                .id(camion.getId())
                .dominio(camion.getDominio())
                .marca(camion.getMarca())
                .modelo(camion.getModelo())
                .anio(camion.getAnio())
                .capacidadPesoKg(camion.getCapacidadPesoKg())
                .capacidadVolumenM3(camion.getCapacidadVolumenM3())
                .consumoCombustibleKmLitro(camion.getConsumoCombustibleKmLitro())
                .costoBasePorKm(camion.getCostoBasePorKm())
                .transportistaId(camion.getTransportista() != null ? camion.getTransportista().getId() : null)
                .estado(camion.getEstado())
                .activo(camion.getActivo())
                .build();
    }
}



==================================================
RUTH: logistics-service/src/main/java/com/transportes/logistics/controller/DepositoController.java
==================================================
package com.transportes.logistics.controller;

import com.transportes.logistics.dto.DepositoDTO;
import com.transportes.logistics.entity.Deposito;
import com.transportes.logistics.repository.DepositoRepository;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.tags.Tag;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

import jakarta.validation.Valid;
import java.net.URI;
import java.util.List;
import java.util.stream.Collectors;

@RestController
@RequestMapping("/api/depositos")
@RequiredArgsConstructor
@PreAuthorize("hasRole('OPERADOR')")
@Tag(name = "Dep√≥sitos", description = "Gesti√≥n de dep√≥sitos")
public class DepositoController {

    private final DepositoRepository depositoRepository;

    @GetMapping
    @Operation(summary = "Listar todos los dep√≥sitos")
    public ResponseEntity<List<DepositoDTO>> listarTodos() {
        List<DepositoDTO> depositos = depositoRepository.findAll().stream()
                .map(this::convertirADTO)
                .collect(Collectors.toList());
        return ResponseEntity.ok(depositos);
    }

    @GetMapping("/activos")
    @Operation(summary = "Listar dep√≥sitos activos")
    public ResponseEntity<List<DepositoDTO>> listarActivos() {
        List<DepositoDTO> depositos = depositoRepository.findByActivoTrue().stream()
                .map(this::convertirADTO)
                .collect(Collectors.toList());
        return ResponseEntity.ok(depositos);
    }

    @GetMapping("/{id}")
    @Operation(summary = "Obtener dep√≥sito por ID")
    public ResponseEntity<DepositoDTO> obtenerPorId(@PathVariable Long id) {
        return depositoRepository.findById(id)
                .map(this::convertirADTO)
                .map(ResponseEntity::ok)
                .orElse(ResponseEntity.notFound().build());
    }

    @PostMapping
    @Operation(summary = "Crear nuevo dep√≥sito")
    public ResponseEntity<DepositoDTO> crear(@Valid @RequestBody DepositoDTO depositoDTO) {
        Deposito deposito = convertirAEntidad(depositoDTO);
        Deposito guardado = depositoRepository.save(deposito);
        return ResponseEntity.created(URI.create("/api/depositos/" + guardado.getId()))
                .body(convertirADTO(guardado));
    }

    @PutMapping("/{id}")
    @Operation(summary = "Actualizar dep√≥sito")
    public ResponseEntity<DepositoDTO> actualizar(@PathVariable Long id,
                                                    @Valid @RequestBody DepositoDTO depositoDTO) {
        return depositoRepository.findById(id)
                .map(deposito -> {
                    deposito.setNombre(depositoDTO.getNombre());
                    deposito.setDireccion(depositoDTO.getDireccion());
                    deposito.setLatitud(depositoDTO.getLatitud());
                    deposito.setLongitud(depositoDTO.getLongitud());
                    deposito.setCapacidadMaximaContenedores(depositoDTO.getCapacidadMaxima());
                    deposito.setActivo(depositoDTO.getActivo());
                    return ResponseEntity.ok(convertirADTO(depositoRepository.save(deposito)));
                })
                .orElse(ResponseEntity.notFound().build());
    }

    @DeleteMapping("/{id}")
    @Operation(summary = "Eliminar dep√≥sito (soft delete)")
    public ResponseEntity<Void> eliminar(@PathVariable Long id) {
        return depositoRepository.findById(id)
                .map(deposito -> {
                    deposito.setActivo(false);
                    depositoRepository.save(deposito);
                    return ResponseEntity.noContent().<Void>build();
                })
                .orElse(ResponseEntity.notFound().build());
    }

    private DepositoDTO convertirADTO(Deposito deposito) {
        return DepositoDTO.builder()
                .id(deposito.getId())
                .codigo(deposito.getCodigo())
                .nombre(deposito.getNombre())
                .direccion(deposito.getDireccion())
                .latitud(deposito.getLatitud())
                .longitud(deposito.getLongitud())
                .capacidadMaxima(deposito.getCapacidadMaximaContenedores())
                .contenedoresActuales(deposito.getContenedoresActuales())
                .activo(deposito.getActivo())
                .build();
    }

    private Deposito convertirAEntidad(DepositoDTO dto) {
        return Deposito.builder()
                .nombre(dto.getNombre())
                .direccion(dto.getDireccion())
                .latitud(dto.getLatitud())
                .longitud(dto.getLongitud())
                .capacidadMaximaContenedores(dto.getCapacidadMaxima())
                .activo(dto.getActivo() != null ? dto.getActivo() : true)
                .build();
    }
}



==================================================
RUTH: logistics-service/src/main/java/com/transportes/logistics/controller/RutaController.java
==================================================
package com.transportes.logistics.controller;

import com.transportes.logistics.client.ClientsClient;
import com.transportes.logistics.dto.RutaDTO;
import com.transportes.logistics.service.RutaService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.security.SecurityRequirement;
import io.swagger.v3.oas.annotations.tags.Tag;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;
import java.math.BigDecimal;
import java.util.List;

@Tag(name = "Rutas", description = "API para gesti√≥n de rutas de transporte")
@RestController
@RequestMapping("/api/rutas")
@RequiredArgsConstructor
@SecurityRequirement(name = "bearer-jwt")
public class RutaController {

    private final RutaService rutaService;
    private final ClientsClient clientsClient;

    @Operation(summary = "Generar rutas alternativas", description = "Genera m√∫ltiples opciones de ruta para una solicitud")
    @PreAuthorize("hasRole('OPERADOR')")
    @GetMapping("/alternativas/{solicitudId}")
    public ResponseEntity<List<RutaDTO>> generarRutasAlternativas(@PathVariable("solicitudId") Long solicitudId) {
        // Obtener informaci√≥n de la solicitud desde clients-service
        ClientsClient.SolicitudResponse solicitud = clientsClient.obtenerSolicitud(solicitudId);

        // Extraer datos necesarios
        BigDecimal origenLat = solicitud.origen().latitud();
        BigDecimal origenLon = solicitud.origen().longitud();
        BigDecimal destinoLat = solicitud.destino().latitud();
        BigDecimal destinoLon = solicitud.destino().longitud();
        BigDecimal pesoKg = solicitud.contenedor().pesoKg();
        BigDecimal volumenM3 = solicitud.contenedor().volumenM3();

        List<RutaDTO> rutas = rutaService.generarRutasAlternativas(
                solicitudId, origenLat, origenLon, destinoLat, destinoLon, pesoKg, volumenM3);

        return ResponseEntity.ok(rutas);
    }

    @Operation(summary = "Asignar ruta a solicitud",
               description = "Regenera y guarda la ruta seleccionada seg√∫n su √≠ndice (0=directa, 1=1 dep√≥sito, 2=2 dep√≥sitos)")
    @PreAuthorize("hasRole('OPERADOR')")
    @PostMapping("/{solicitudId}/asignar/{indiceRuta}")
    public ResponseEntity<RutaDTO> asignarRuta(
            @PathVariable("solicitudId") Long solicitudId,
            @PathVariable("indiceRuta") Integer indiceRuta) {
        RutaDTO ruta = rutaService.asignarRuta(solicitudId, indiceRuta);
        return ResponseEntity.ok(ruta);
    }
}



==================================================
RUTH: logistics-service/src/main/java/com/transportes/logistics/controller/TramoController.java
==================================================
package com.transportes.logistics.controller;

import com.transportes.logistics.dto.TramoDTO;
import com.transportes.logistics.service.CamionService;
import com.transportes.logistics.service.TramoService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.security.SecurityRequirement;
import io.swagger.v3.oas.annotations.tags.Tag;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.security.core.Authentication;
import org.springframework.web.bind.annotation.*;
import java.util.List;

@Tag(name = "Tramos", description = "API para gesti√≥n de tramos de ruta")
@RestController
@RequestMapping("/api/tramos")
@RequiredArgsConstructor
@SecurityRequirement(name = "bearer-jwt")
public class TramoController {

    private final TramoService tramoService;
    private final CamionService camionService;

    @Operation(summary = "Asignar cami√≥n a tramo")
    @PreAuthorize("hasRole('OPERADOR')")
    @PostMapping("/{tramoId}/asignar-camion")
    public ResponseEntity<Void> asignarCamion(
            @PathVariable("tramoId") Long tramoId,
            @RequestParam("camionId") Long camionId) {

        camionService.asignarCamionATramo(tramoId, camionId);
        return ResponseEntity.ok().build();
    }

    @Operation(summary = "Obtener tramo por ID")
    @PreAuthorize("hasAnyRole('OPERADOR', 'TRANSPORTISTA')")
    @GetMapping("/{tramoId}")
    public ResponseEntity<TramoDTO> obtenerTramo(@PathVariable("tramoID") Long tramoId) {
        TramoDTO tramo = tramoService.obtenerTramo(tramoId);
        return ResponseEntity.ok(tramo);
    }
}



==================================================
RUTH: logistics-service/src/main/java/com/transportes/logistics/controller/TransportistaController.java
==================================================
package com.transportes.logistics.controller;

import com.transportes.logistics.dto.TramoDTO;
import com.transportes.logistics.dto.TransportistaDTO;
import com.transportes.logistics.service.TramoService;
import com.transportes.logistics.service.TransportistaService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.security.SecurityRequirement;
import io.swagger.v3.oas.annotations.tags.Tag;
import lombok.RequiredArgsConstructor;
import jakarta.validation.Valid;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.security.core.Authentication;
import org.springframework.web.bind.annotation.*;
import java.util.List;

@Tag(name = "Transportista", description = "API para operaciones de transportistas")
@RestController
@RequestMapping("/api/transportista")
@RequiredArgsConstructor
@SecurityRequirement(name = "bearer-jwt")
public class TransportistaController {

    private final TramoService tramoService;
    private final TransportistaService transportistaService;

    @Operation(summary = "Crear nuevo transportista")
    @PreAuthorize("hasRole('OPERADOR')")
    @PostMapping
    public ResponseEntity<TransportistaDTO> crear(@Valid @RequestBody TransportistaDTO dto) {
        return ResponseEntity.ok(transportistaService.crear(dto));
    }

    @Operation(summary = "Obtener mis tramos asignados")
    @PreAuthorize("hasRole('TRANSPORTISTA')")
    @GetMapping("/tramos-asignados")
    public ResponseEntity<List<TramoDTO>> obtenerMisTramosAsignados(Authentication authentication) {
        String keycloakUserId = authentication.getName();
        List<TramoDTO> tramos = tramoService.obtenerTramosAsignadosATransportista(keycloakUserId);
        return ResponseEntity.ok(tramos);
    }

    @Operation(summary = "Iniciar tramo")
    @PreAuthorize("hasRole('TRANSPORTISTA')")
    @PostMapping("/tramos/{tramoId}/iniciar")
    public ResponseEntity<TramoDTO> iniciarTramo(
            @PathVariable Long tramoId,
            Authentication authentication) {

        String keycloakUserId = authentication.getName();
        TramoDTO tramo = tramoService.iniciarTramo(tramoId, keycloakUserId);
        return ResponseEntity.ok(tramo);
    }

    @Operation(summary = "Finalizar tramo")
    @PreAuthorize("hasRole('TRANSPORTISTA')")
    @PostMapping("/tramos/{tramoId}/finalizar")
    public ResponseEntity<TramoDTO> finalizarTramo(
            @PathVariable Long tramoId,
            Authentication authentication) {

        String keycloakUserId = authentication.getName();
        TramoDTO tramo = tramoService.finalizarTramo(tramoId, keycloakUserId);
        return ResponseEntity.ok(tramo);
    }
}



==================================================
RUTH: logistics-service/src/main/java/com/transportes/logistics/dto/CamionDTO.java
==================================================
package com.transportes.logistics.dto;

import com.transportes.logistics.entity.Camion;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Pattern;
import jakarta.validation.constraints.Positive;
import lombok.*;
import java.math.BigDecimal;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class CamionDTO {
    private Long id;

    @NotBlank(message = "El dominio es obligatorio")
    @Pattern(regexp = "^[A-Z]{2,3}\\d{3}[A-Z]{2,3}$", message = "Dominio/patente inv√°lido")
    private String dominio;

    private String marca;
    private String modelo;
    private Integer anio;

    @NotNull(message = "La capacidad de peso es obligatoria")
    @Positive(message = "La capacidad de peso debe ser positiva")
    private BigDecimal capacidadPesoKg;

    @NotNull(message = "La capacidad de volumen es obligatoria")
    @Positive(message = "La capacidad de volumen debe ser positiva")
    private BigDecimal capacidadVolumenM3;

    @NotNull(message = "El consumo de combustible es obligatorio")
    @Positive(message = "El consumo de combustible debe ser positivo")
    private BigDecimal consumoCombustibleKmLitro;

    private BigDecimal costoBasePorKm;
    private Long transportistaId;
    private Camion.EstadoCamion estado;
    private Boolean activo;
}



==================================================
RUTH: logistics-service/src/main/java/com/transportes/logistics/dto/DepositoDTO.java
==================================================
package com.transportes.logistics.dto;

import jakarta.validation.constraints.*;
import lombok.*;
import java.math.BigDecimal;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class DepositoDTO {
    private Long id;

    private String codigo;

    @NotBlank(message = "El nombre es obligatorio")
    @Size(max = 150, message = "El nombre no puede exceder 150 caracteres")
    private String nombre;

    @NotBlank(message = "La direcci√≥n es obligatoria")
    private String direccion;

    @NotNull(message = "La latitud es obligatoria")
    @DecimalMin(value = "-90", message = "La latitud debe estar entre -90 y 90")
    @DecimalMax(value = "90", message = "La latitud debe estar entre -90 y 90")
    private BigDecimal latitud;

    @NotNull(message = "La longitud es obligatoria")
    @DecimalMin(value = "-180", message = "La longitud debe estar entre -180 y 180")
    @DecimalMax(value = "180", message = "La longitud debe estar entre -180 y 180")
    private BigDecimal longitud;

    @Positive(message = "La capacidad m√°xima debe ser positiva")
    private Integer capacidadMaxima;

    private Integer contenedoresActuales;

    private Boolean activo;
}



==================================================
RUTH: logistics-service/src/main/java/com/transportes/logistics/dto/RutaDTO.java
==================================================
package com.transportes.logistics.dto;

import lombok.*;
import java.math.BigDecimal;
import java.util.List;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class RutaDTO {
    private Long id;
    private Long solicitudId;
    private String tipo;
    private Integer indice; // √çndice para identificar la ruta cuando no est√° guardada en BD
    private String descripcion; // Descripci√≥n de la ruta (ej: "Ruta directa", "Con 1 dep√≥sito")
    private Integer cantidadTramos;
    private Integer cantidadDepositos;
    private BigDecimal distanciaTotalKm;
    private Integer tiempoEstimadoTotalHoras;
    private BigDecimal costoEstimadoTotal;
    private Boolean seleccionada;
    private List<TramoDTO> tramos;
}



==================================================
RUTH: logistics-service/src/main/java/com/transportes/logistics/dto/TramoDTO.java
==================================================
package com.transportes.logistics.dto;

import com.transportes.logistics.entity.Tramo;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Positive;
import lombok.*;
import java.math.BigDecimal;
import java.time.LocalDateTime;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class TramoDTO {
    private Long id;

    @NotNull(message = "El n√∫mero de orden es obligatorio")
    @Positive(message = "El n√∫mero de orden debe ser positivo")
    private Integer numeroOrden;

    private Tramo.TipoTramo tipoTramo;
    private String origenDireccion;
    private String destinoDireccion;

    @NotNull(message = "La distancia es obligatoria")
    @Positive(message = "La distancia debe ser positiva")
    private BigDecimal distanciaKm;

    private Tramo.EstadoTramo estado;
    private Long camionId;
    private String camionDominio;
    private LocalDateTime fechaHoraInicioEstimada;
    private LocalDateTime fechaHoraFinEstimada;
    private LocalDateTime fechaHoraInicioReal;
    private LocalDateTime fechaHoraFinReal;
    private BigDecimal costoEstimado;
    private BigDecimal costoReal;
}



==================================================
RUTH: logistics-service/src/main/java/com/transportes/logistics/dto/TransportistaDTO.java
==================================================
package com.transportes.logistics.dto;

import com.fasterxml.jackson.annotation.JsonProperty;
import jakarta.validation.constraints.NotBlank;
import lombok.*;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class TransportistaDTO {
    private Long id;

    @NotBlank(message = "El nombre es obligatorio")
    private String nombre;

    @NotBlank(message = "El apellido es obligatorio")
    private String apellido;

    @NotBlank(message = "El DNI es obligatorio")
    private String dni;

    private String telefono;
    private String email;

    @NotBlank(message = "La licencia es obligatoria")
    private String licenciaConducir;

    @NotBlank(message = "La contrase√±a es obligatoria")
    @JsonProperty(access = JsonProperty.Access.WRITE_ONLY)
    private String password;

    private String keycloakUserId;
    private Boolean activo;
}


==================================================
RUTH: logistics-service/src/main/java/com/transportes/logistics/entity/Camion.java
==================================================
package com.transportes.logistics.entity;

import jakarta.persistence.*;
import lombok.*;
import java.math.BigDecimal;
import java.time.LocalDateTime;

@Entity
@Table(name = "camion")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class Camion {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false, unique = true, length = 20)
    private String dominio;

    @Column(length = 50)
    private String marca;

    @Column(length = 50)
    private String modelo;

    private Integer anio;

    @Column(name = "capacidad_peso_kg", nullable = false, precision = 10, scale = 2)
    private BigDecimal capacidadPesoKg;

    @Column(name = "capacidad_volumen_m3", nullable = false, precision = 10, scale = 2)
    private BigDecimal capacidadVolumenM3;

    @Column(name = "consumo_combustible_km_litro", nullable = false, precision = 5, scale = 2)
    private BigDecimal consumoCombustibleKmLitro;

    @Column(name = "costo_base_por_km", nullable = false, precision = 8, scale = 2)
    private BigDecimal costoBasePorKm;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "transportista_id")
    private Transportista transportista;

    @Column(length = 20)
    @Enumerated(EnumType.STRING)
    private EstadoCamion estado = EstadoCamion.DISPONIBLE;

    @Column(nullable = false)
    private Boolean activo = true;

    @Column(name = "fecha_registro")
    private LocalDateTime fechaRegistro;

    @PrePersist
    protected void onCreate() {
        fechaRegistro = LocalDateTime.now();
        if (activo == null) {
            activo = true;
        }
        if (estado == null) {
            estado = EstadoCamion.DISPONIBLE;
        }
    }

    public enum EstadoCamion {
        DISPONIBLE,
        OCUPADO,
        MANTENIMIENTO,
        INACTIVO
    }
}



==================================================
RUTH: logistics-service/src/main/java/com/transportes/logistics/entity/Deposito.java
==================================================
package com.transportes.logistics.entity;

import jakarta.persistence.*;
import lombok.*;
import java.math.BigDecimal;
import java.time.LocalDateTime;

@Entity
@Table(name = "deposito")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class Deposito {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false, unique = true, length = 50)
    private String codigo;

    @Column(nullable = false, length = 150)
    private String nombre;

    @Column(nullable = false, columnDefinition = "TEXT")
    private String direccion;

    @Column(nullable = false, precision = 10, scale = 8)
    private BigDecimal latitud;

    @Column(nullable = false, precision = 11, scale = 8)
    private BigDecimal longitud;

    @Column(name = "capacidad_maxima_contenedores")
    private Integer capacidadMaximaContenedores = 100;

    @Column(name = "contenedores_actuales")
    private Integer contenedoresActuales = 0;

    @Column(nullable = false)
    private Boolean activo = true;

    @Column(name = "fecha_creacion")
    private LocalDateTime fechaCreacion;

    @PrePersist
    protected void onCreate() {
        fechaCreacion = LocalDateTime.now();
        if (activo == null) {
            activo = true;
        }
        if (capacidadMaximaContenedores == null) {
            capacidadMaximaContenedores = 100;
        }
        if (contenedoresActuales == null) {
            contenedoresActuales = 0;
        }
        if (codigo == null || codigo.isEmpty()) {
            codigo = "DEP-" + java.time.Year.now().getValue() + "-" +
                     String.format("%05d", System.currentTimeMillis() % 100000);
        }
    }
}



==================================================
RUTH: logistics-service/src/main/java/com/transportes/logistics/entity/Ruta.java
==================================================
package com.transportes.logistics.entity;

import jakarta.persistence.*;
import lombok.*;
import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;

@Entity
@Table(name = "ruta")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class Ruta {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = "solicitud_id", nullable = false)
    private Long solicitudId;

    @Column(length = 20)
    @Enumerated(EnumType.STRING)
    private TipoRuta tipo = TipoRuta.PROPUESTA;

    @Column(name = "indice")
    private Integer indice; // √çndice de la ruta seleccionada (0, 1, 2)

    @Column(name = "descripcion", length = 255)
    private String descripcion; // Descripci√≥n de la ruta

    @Column(name = "cantidad_tramos", nullable = false)
    private Integer cantidadTramos;

    @Column(name = "cantidad_depositos")
    private Integer cantidadDepositos = 0;

    @Column(name = "distancia_total_km", precision = 10, scale = 2)
    private BigDecimal distanciaTotalKm;

    @Column(name = "tiempo_estimado_total_horas")
    private Integer tiempoEstimadoTotalHoras;

    @Column(name = "costo_estimado_total", precision = 12, scale = 2)
    private BigDecimal costoEstimadoTotal;

    @Column(name = "costo_real_total", precision = 12, scale = 2)
    private BigDecimal costoRealTotal;

    @Column(name = "fecha_creacion")
    private LocalDateTime fechaCreacion;

    @Column(nullable = false)
    private Boolean seleccionada = false;

    @OneToMany(mappedBy = "ruta", cascade = CascadeType.ALL, orphanRemoval = true)
    @OrderBy("numeroOrden ASC")
    @Builder.Default
    private List<Tramo> tramos = new ArrayList<>();

    @PrePersist
    protected void onCreate() {
        fechaCreacion = LocalDateTime.now();
        if (tipo == null) {
            tipo = TipoRuta.PROPUESTA;
        }
        if (seleccionada == null) {
            seleccionada = false;
        }
        if (cantidadDepositos == null) {
            cantidadDepositos = 0;
        }
    }

    public enum TipoRuta {
        PROPUESTA,
        ASIGNADA
    }
}



==================================================
RUTH: logistics-service/src/main/java/com/transportes/logistics/entity/Tramo.java
==================================================
package com.transportes.logistics.entity;

import jakarta.persistence.*;
import lombok.*;
import java.math.BigDecimal;
import java.time.LocalDateTime;

@Entity
@Table(name = "tramo")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class Tramo {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "ruta_id", nullable = false)
    private Ruta ruta;

    @Column(name = "numero_orden", nullable = false)
    private Integer numeroOrden;

    @Column(name = "tipo_tramo", nullable = false, length = 30)
    @Enumerated(EnumType.STRING)
    private TipoTramo tipoTramo;

    // Origen del tramo
    @Column(name = "origen_tipo", nullable = false, length = 20)
    private String origenTipo;

    @Column(name = "origen_direccion", nullable = false, columnDefinition = "TEXT")
    private String origenDireccion;

    @Column(name = "origen_latitud", nullable = false, precision = 10, scale = 8)
    private BigDecimal origenLatitud;

    @Column(name = "origen_longitud", nullable = false, precision = 11, scale = 8)
    private BigDecimal origenLongitud;

    @Column(name = "origen_deposito_id")
    private Long origenDepositoId;

    // Destino del tramo
    @Column(name = "destino_tipo", nullable = false, length = 20)
    private String destinoTipo;

    @Column(name = "destino_direccion", nullable = false, columnDefinition = "TEXT")
    private String destinoDireccion;

    @Column(name = "destino_latitud", nullable = false, precision = 10, scale = 8)
    private BigDecimal destinoLatitud;

    @Column(name = "destino_longitud", nullable = false, precision = 11, scale = 8)
    private BigDecimal destinoLongitud;

    @Column(name = "destino_deposito_id")
    private Long destinoDepositoId;

    // Datos del tramo
    @Column(name = "distancia_km", nullable = false, precision = 10, scale = 2)
    private BigDecimal distanciaKm;

    @Column(length = 20)
    @Enumerated(EnumType.STRING)
    private EstadoTramo estado = EstadoTramo.ESTIMADO;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "camion_id")
    private Camion camion;

    // Tiempos
    @Column(name = "fecha_hora_inicio_estimada")
    private LocalDateTime fechaHoraInicioEstimada;

    @Column(name = "fecha_hora_fin_estimada")
    private LocalDateTime fechaHoraFinEstimada;

    @Column(name = "fecha_hora_inicio_real")
    private LocalDateTime fechaHoraInicioReal;

    @Column(name = "fecha_hora_fin_real")
    private LocalDateTime fechaHoraFinReal;

    // Costos
    @Column(name = "costo_estimado", precision = 10, scale = 2)
    private BigDecimal costoEstimado;

    @Column(name = "costo_real", precision = 10, scale = 2)
    private BigDecimal costoReal;

    @Column(columnDefinition = "TEXT")
    private String observaciones;

    @Column(name = "fecha_creacion")
    private LocalDateTime fechaCreacion;

    @PrePersist
    protected void onCreate() {
        fechaCreacion = LocalDateTime.now();
        if (estado == null) {
            estado = EstadoTramo.ESTIMADO;
        }
    }

    public enum TipoTramo {
        ORIGEN_DEPOSITO,
        DEPOSITO_DEPOSITO,
        DEPOSITO_DESTINO,
        ORIGEN_DESTINO
    }

    public enum EstadoTramo {
        ESTIMADO,
        ASIGNADO,
        INICIADO,
        FINALIZADO
    }
}



==================================================
RUTH: logistics-service/src/main/java/com/transportes/logistics/entity/Transportista.java
==================================================
package com.transportes.logistics.entity;

import jakarta.persistence.*;
import lombok.*;
import java.time.LocalDateTime;

@Entity
@Table(name = "transportista")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class Transportista {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false, length = 100)
    private String nombre;

    @Column(nullable = false, length = 100)
    private String apellido;

    @Column(nullable = false, unique = true, length = 20)
    private String dni;

    @Column(nullable = false, length = 20)
    private String telefono;

    @Column(length = 150)
    private String email;

    @Column(name = "licencia_conducir", nullable = false, length = 50)
    private String licenciaConducir;

    @Column(name = "keycloak_user_id", unique = true, length = 100)
    private String keycloakUserId;

    @Column(nullable = false)
    private Boolean activo = true;

    @Column(name = "fecha_registro")
    private LocalDateTime fechaRegistro;

    @PrePersist
    protected void onCreate() {
        fechaRegistro = LocalDateTime.now();
        if (activo == null) {
            activo = true;
        }
    }
}



==================================================
RUTH: logistics-service/src/main/java/com/transportes/logistics/exception/GlobalExceptionHandler.java
==================================================
package com.transportes.logistics.exception;

import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice;
import java.util.HashMap;
import java.util.Map;

@RestControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(RuntimeException.class)
    public ResponseEntity<Map<String, String>> handleRuntimeException(RuntimeException ex) {
        Map<String, String> error = new HashMap<>();
        error.put("error", "Error Interno");
        error.put("message", ex.getMessage());
        // Esto atrapar√° errores como "Transportista no encontrado" o conflictos de DB
        return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(error);
    }

    @ExceptionHandler(Exception.class)
    public ResponseEntity<Map<String, String>> handleException(Exception ex) {
        Map<String, String> error = new HashMap<>();
        error.put("error", "Error General");
        error.put("message", ex.getMessage());
        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(error);
    }
}


==================================================
RUTH: logistics-service/src/main/java/com/transportes/logistics/repository/CamionRepository.java
==================================================
package com.transportes.logistics.repository;

import com.transportes.logistics.entity.Camion;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;
import java.math.BigDecimal;
import java.util.List;
import java.util.Optional;

@Repository
public interface CamionRepository extends JpaRepository<Camion, Long> {
    
    Optional<Camion> findByDominio(String dominio);
    
    List<Camion> findByEstado(Camion.EstadoCamion estado);
    
    @Query("SELECT c FROM Camion c WHERE c.estado = 'DISPONIBLE' AND c.activo = true " +
           "AND c.capacidadPesoKg >= :pesoRequerido AND c.capacidadVolumenM3 >= :volumenRequerido")
    List<Camion> findCamionesDisponiblesParaContenedor(
            @Param("pesoRequerido") BigDecimal pesoRequerido,
            @Param("volumenRequerido") BigDecimal volumenRequerido);
    
    List<Camion> findByActivoTrue();
}



==================================================
RUTH: logistics-service/src/main/java/com/transportes/logistics/repository/DepositoRepository.java
==================================================
package com.transportes.logistics.repository;

import com.transportes.logistics.entity.Deposito;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;
import java.util.List;
import java.util.Optional;

@Repository
public interface DepositoRepository extends JpaRepository<Deposito, Long> {
    
    Optional<Deposito> findByCodigo(String codigo);
    
    List<Deposito> findByActivoTrue();
    
    boolean existsByCodigo(String codigo);
}



==================================================
RUTH: logistics-service/src/main/java/com/transportes/logistics/repository/RutaRepository.java
==================================================
package com.transportes.logistics.repository;

import com.transportes.logistics.entity.Ruta;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;
import java.util.List;
import java.util.Optional;

@Repository
public interface RutaRepository extends JpaRepository<Ruta, Long> {
    
    List<Ruta> findBySolicitudId(Long solicitudId);
    
    Optional<Ruta> findBySolicitudIdAndSeleccionadaTrue(Long solicitudId);
    
    List<Ruta> findBySolicitudIdAndTipo(Long solicitudId, Ruta.TipoRuta tipo);
}



==================================================
RUTH: logistics-service/src/main/java/com/transportes/logistics/repository/TramoRepository.java
==================================================
package com.transportes.logistics.repository;

import com.transportes.logistics.entity.Tramo;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;
import java.util.List;

@Repository
public interface TramoRepository extends JpaRepository<Tramo, Long> {
    
    List<Tramo> findByRutaIdOrderByNumeroOrdenAsc(Long rutaId);
    
    List<Tramo> findByCamionId(Long camionId);
    
    @Query("SELECT t FROM Tramo t WHERE t.camion.transportista.keycloakUserId = :keycloakUserId " +
           "AND t.estado IN ('ASIGNADO', 'INICIADO') ORDER BY t.fechaHoraInicioEstimada ASC")
    List<Tramo> findTramosAsignadosPorTransportista(@Param("keycloakUserId") String keycloakUserId);
    
    List<Tramo> findByEstado(Tramo.EstadoTramo estado);
}



==================================================
RUTH: logistics-service/src/main/java/com/transportes/logistics/repository/TransportistaRepository.java
==================================================
package com.transportes.logistics.repository;

import com.transportes.logistics.entity.Transportista;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;
import java.util.Optional;

@Repository
public interface TransportistaRepository extends JpaRepository<Transportista, Long> {
    
    Optional<Transportista> findByDni(String dni);
    
    Optional<Transportista> findByKeycloakUserId(String keycloakUserId);
}



==================================================
RUTH: logistics-service/src/main/java/com/transportes/logistics/service/CamionService.java
==================================================
package com.transportes.logistics.service;

import com.transportes.logistics.dto.CamionDTO;
import com.transportes.logistics.entity.Camion;
import com.transportes.logistics.entity.Tramo;
import com.transportes.logistics.repository.CamionRepository;
import com.transportes.logistics.repository.TramoRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import java.math.BigDecimal;
import java.util.List;
import java.util.stream.Collectors;

@Slf4j
@Service
@RequiredArgsConstructor
public class CamionService {

    private final CamionRepository camionRepository;
    private final TramoRepository tramoRepository;

    @Transactional
    public void asignarCamionATramo(Long tramoId, Long camionId) {
        Tramo tramo = tramoRepository.findById(tramoId)
                .orElseThrow(() -> new RuntimeException("Tramo no encontrado"));

        Camion camion = camionRepository.findById(camionId)
                .orElseThrow(() -> new RuntimeException("Cami√≥n no encontrado"));

        // Validar que el cami√≥n est√© disponible
        if (camion.getEstado() != Camion.EstadoCamion.DISPONIBLE) {
            throw new RuntimeException("El cami√≥n no est√° disponible");
        }

        // Asignar cami√≥n al tramo
        tramo.setCamion(camion);
        tramo.setEstado(Tramo.EstadoTramo.ASIGNADO);

        // Cambiar estado del cami√≥n
        camion.setEstado(Camion.EstadoCamion.OCUPADO);

        tramoRepository.save(tramo);
        camionRepository.save(camion);

        log.info("Cami√≥n {} asignado al tramo {}", camionId, tramoId);
    }

    @Transactional(readOnly = true)
    public List<CamionDTO> obtenerCamionesDisponibles(BigDecimal pesoRequerido, BigDecimal volumenRequerido) {
        List<Camion> camiones = camionRepository.findCamionesDisponiblesParaContenedor(
                pesoRequerido, volumenRequerido);

        return camiones.stream()
                .map(this::convertirACamionDTO)
                .collect(Collectors.toList());
    }

    @Transactional(readOnly = true)
    public List<CamionDTO> obtenerTodosLosCamiones() {
        return camionRepository.findAll().stream()
                .map(this::convertirACamionDTO)
                .collect(Collectors.toList());
    }

    private CamionDTO convertirACamionDTO(Camion camion) {
        return CamionDTO.builder()
                .id(camion.getId())
                .dominio(camion.getDominio())
                .marca(camion.getMarca())
                .modelo(camion.getModelo())
                .anio(camion.getAnio())
                .capacidadPesoKg(camion.getCapacidadPesoKg())
                .capacidadVolumenM3(camion.getCapacidadVolumenM3())
                .consumoCombustibleKmLitro(camion.getConsumoCombustibleKmLitro())
                .costoBasePorKm(camion.getCostoBasePorKm())
                .transportistaId(camion.getTransportista() != null ? camion.getTransportista().getId() : null)
                .estado(camion.getEstado())
                .activo(camion.getActivo())
                .build();
    }
}



==================================================
RUTH: logistics-service/src/main/java/com/transportes/logistics/service/KeycloakService.java
==================================================
package com.transportes.logistics.service;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.keycloak.admin.client.Keycloak;
import org.keycloak.admin.client.KeycloakBuilder;
import org.keycloak.admin.client.resource.RealmResource;
import org.keycloak.admin.client.resource.UsersResource;
import org.keycloak.representations.idm.CredentialRepresentation;
import org.keycloak.representations.idm.UserRepresentation;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;

import jakarta.annotation.PostConstruct;
import jakarta.ws.rs.core.Response;
import java.util.Collections;
import java.util.List;

@Slf4j
@Service
@RequiredArgsConstructor
public class KeycloakService {

    @Value("${keycloak.auth-server-url}")
    private String authServerUrl;

    @Value("${keycloak.realm}")
    private String realm;

    @Value("${keycloak.admin.username:admin}")
    private String adminUsername;

    @Value("${keycloak.admin.password:admin}")
    private String adminPassword;

    @Value("${keycloak.admin.client-id:admin-cli}")
    private String adminClientId;

    private Keycloak keycloak;

    @PostConstruct
    public void init() {
        try {
            this.keycloak = KeycloakBuilder.builder()
                    .serverUrl(authServerUrl)
                    .realm("master")
                    .clientId(adminClientId)
                    .username(adminUsername)
                    .password(adminPassword)
                    .build();
            log.info("Keycloak admin client initialized successfully");
        } catch (Exception e) {
            log.error("Error initializing Keycloak admin client", e);
        }
    }

    /**
     * Crea un usuario transportista en Keycloak
     */
    public String crearUsuarioTransportista(String email, String password, String nombre, String apellido) {
        try {
            RealmResource realmResource = keycloak.realm(realm);
            UsersResource usersResource = realmResource.users();

            // Verificar si el usuario ya existe
            List<UserRepresentation> existingUsers = usersResource.search(email);
            if (!existingUsers.isEmpty()) {
                log.info("El usuario ya existe en Keycloak. Recuperando ID para sincronizaci√≥n.");
                return existingUsers.get(0).getId();
            }

            // Crear usuario
            UserRepresentation user = new UserRepresentation();
            user.setUsername(email);
            user.setEmail(email);
            user.setFirstName(nombre);
            user.setLastName(apellido);
            user.setEnabled(true);
            user.setEmailVerified(true);

            // Crear credencial
            CredentialRepresentation credential = new CredentialRepresentation();
            credential.setType(CredentialRepresentation.PASSWORD);
            credential.setValue(password);
            credential.setTemporary(false);
            user.setCredentials(Collections.singletonList(credential));

            // Crear usuario en Keycloak
            Response response = usersResource.create(user);

            if (response.getStatus() == 201) {
                String userId = extractUserIdFromResponse(response);

                // Asignar rol TRANSPORTISTA
                asignarRolTransportista(userId);

                log.info("Usuario transportista creado en Keycloak: {}", email);
                return userId;
            } else {
                String errorMsg = response.readEntity(String.class);
                log.error("Error creating user in Keycloak. Status: {}, Error: {}", response.getStatus(), errorMsg);
                throw new RuntimeException("Error al crear usuario en Keycloak: " + errorMsg);
            }

        } catch (Exception e) {
            log.error("Error al crear usuario transportista en Keycloak", e);
            throw new RuntimeException("Error al crear usuario transportista en Keycloak", e);
        }
    }

    private String extractUserIdFromResponse(Response response) {
        String location = response.getHeaderString("Location");
        if (location != null) {
            return location.substring(location.lastIndexOf('/') + 1);
        }
        throw new RuntimeException("No se pudo obtener el ID del usuario creado");
    }

    private void asignarRolTransportista(String userId) {
        try {
            RealmResource realmResource = keycloak.realm(realm);

            // Buscar rol TRANSPORTISTA
            var roleRepresentation = realmResource.roles().get("TRANSPORTISTA").toRepresentation();

            // Asignar rol al usuario
            realmResource.users().get(userId).roles().realmLevel()
                    .add(Collections.singletonList(roleRepresentation));

            log.info("Rol TRANSPORTISTA asignado al usuario {}", userId);
        } catch (Exception e) {
            log.error("Error al asignar rol TRANSPORTISTA", e);
            // No lanzamos excepci√≥n para no interrumpir el flujo
        }
    }
}



==================================================
RUTH: logistics-service/src/main/java/com/transportes/logistics/service/RutaService.java
==================================================
package com.transportes.logistics.service;

import com.transportes.logistics.client.BillingClient;
import com.transportes.logistics.client.ClientsClient;
import com.transportes.logistics.client.OsrmClient;
import com.transportes.logistics.dto.RutaDTO;
import com.transportes.logistics.dto.TramoDTO;
import com.transportes.logistics.entity.*;
import com.transportes.logistics.repository.CamionRepository;
import com.transportes.logistics.repository.DepositoRepository;
import com.transportes.logistics.repository.RutaRepository;
import com.transportes.logistics.repository.TramoRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import java.math.BigDecimal;
import java.math.RoundingMode;
import java.time.LocalDateTime;
import java.util.*;
import java.util.stream.Collectors;

@Slf4j
@Service
@RequiredArgsConstructor
public class RutaService {

    private final RutaRepository rutaRepository;
    private final TramoRepository tramoRepository;
    private final DepositoRepository depositoRepository;
    private final CamionRepository camionRepository;
    private final OsrmClient osrmClient;
    private final BillingClient billingClient;
    private final ClientsClient clientsClient;

    @Transactional
    public List<RutaDTO> generarRutasAlternativas(Long solicitudId,
                                                   BigDecimal origenLat, BigDecimal origenLon,
                                                   BigDecimal destinoLat, BigDecimal destinoLon,
                                                   BigDecimal pesoKg, BigDecimal volumenM3) {
        log.info("Generando rutas alternativas para solicitud {}", solicitudId);

        // Obtener datos reales de la solicitud
        ClientsClient.SolicitudResponse solicitud = clientsClient.obtenerSolicitud(solicitudId);

        // Usar direcciones reales de la solicitud
        String direccionOrigen = solicitud.origen().direccion();
        BigDecimal latOrigen = solicitud.origen().latitud();
        BigDecimal lonOrigen = solicitud.origen().longitud();

        String direccionDestino = solicitud.destino().direccion();
        BigDecimal latDestino = solicitud.destino().latitud();
        BigDecimal lonDestino = solicitud.destino().longitud();

        BigDecimal peso = solicitud.contenedor().pesoKg();
        BigDecimal volumen = solicitud.contenedor().volumenM3();

        List<RutaDTO> rutasAlternativas = new ArrayList<>();

        // Ruta 1: Directa (sin dep√≥sitos)
        Ruta rutaDirecta = crearRutaDirecta(solicitudId, latOrigen, lonOrigen, latDestino, lonDestino,
                                             direccionOrigen, direccionDestino);
        calcularYAsignarCostoEstimado(rutaDirecta, peso, volumen);
        // NO guardamos en BD - solo generamos el DTO
        RutaDTO dto1 = convertirARutaDTO(rutaDirecta);
        dto1.setIndice(0); // √çndice para identificar esta ruta
        dto1.setDescripcion("Ruta directa sin dep√≥sitos");
        rutasAlternativas.add(dto1);

        // Ruta 2: Con 1 dep√≥sito intermedio
        List<Deposito> depositosActivos = depositoRepository.findByActivoTrue();
        if (!depositosActivos.isEmpty()) {
            List<Deposito> depositos1 = seleccionarDepositosParaRuta(latOrigen, lonOrigen,
                                                                       latDestino, lonDestino, 1);
            if (!depositos1.isEmpty()) {
                Ruta rutaCon1Deposito = crearRutaConDepositos(solicitudId, latOrigen, lonOrigen,
                                                               latDestino, lonDestino,
                                                               direccionOrigen, direccionDestino,
                                                               depositos1);
                calcularYAsignarCostoEstimado(rutaCon1Deposito, peso, volumen);
                // NO guardamos en BD - solo generamos el DTO
                RutaDTO dto2 = convertirARutaDTO(rutaCon1Deposito);
                dto2.setIndice(1); // √çndice para identificar esta ruta
                dto2.setDescripcion("Ruta con 1 dep√≥sito intermedio");
                rutasAlternativas.add(dto2);
            }
        }

        // Ruta 3: Con 2 dep√≥sitos intermedios
        if (depositosActivos.size() >= 2) {
            List<Deposito> depositos2 = seleccionarDepositosParaRuta(latOrigen, lonOrigen,
                                                                       latDestino, lonDestino, 2);
            if (depositos2.size() == 2) {
                Ruta rutaCon2Depositos = crearRutaConDepositos(solicitudId, latOrigen, lonOrigen,
                                                                latDestino, lonDestino,
                                                                direccionOrigen, direccionDestino,
                                                                depositos2);
                calcularYAsignarCostoEstimado(rutaCon2Depositos, peso, volumen);
                // NO guardamos en BD - solo generamos el DTO
                RutaDTO dto3 = convertirARutaDTO(rutaCon2Depositos);
                dto3.setIndice(2); // √çndice para identificar esta ruta
                dto3.setDescripcion("Ruta con 2 dep√≥sitos intermedios");
                rutasAlternativas.add(dto3);
            }
        }

        log.info("Se generaron {} rutas alternativas (NO guardadas en BD)", rutasAlternativas.size());
        return rutasAlternativas;
    }

    private Ruta crearRutaDirecta(Long solicitudId, BigDecimal origenLat, BigDecimal origenLon,
                                  BigDecimal destinoLat, BigDecimal destinoLon,
                                  String direccionOrigen, String direccionDestino) {
        // Calcular distancia con OSRM
        OsrmClient.RouteResponse routeInfo = osrmClient.calcularRuta(origenLat, origenLon,
                                                                      destinoLat, destinoLon);

        Ruta ruta = Ruta.builder()
                .solicitudId(solicitudId)
                .tipo(Ruta.TipoRuta.PROPUESTA)
                .cantidadTramos(1)
                .cantidadDepositos(0)
                .distanciaTotalKm(routeInfo.getDistanciaKm())
                .tiempoEstimadoTotalHoras(routeInfo.getDuracionHoras())
                .tramos(new ArrayList<>())
                .build();

        // Crear tramo directo
        Tramo tramo = Tramo.builder()
                .ruta(ruta)
                .numeroOrden(1)
                .tipoTramo(Tramo.TipoTramo.ORIGEN_DESTINO)
                .origenTipo("ORIGEN")
                .origenDireccion(direccionOrigen)
                .origenLatitud(origenLat)
                .origenLongitud(origenLon)
                .destinoTipo("DESTINO")
                .destinoDireccion(direccionDestino)
                .destinoLatitud(destinoLat)
                .destinoLongitud(destinoLon)
                .distanciaKm(routeInfo.getDistanciaKm())
                .estado(Tramo.EstadoTramo.ESTIMADO)
                .build();

        ruta.getTramos().add(tramo);
        return ruta;
    }

    private Ruta crearRutaConDepositos(Long solicitudId, BigDecimal origenLat, BigDecimal origenLon,
                                       BigDecimal destinoLat, BigDecimal destinoLon,
                                       String direccionOrigen, String direccionDestino,
                                       List<Deposito> depositos) {
        List<Tramo> tramos = new ArrayList<>();
        BigDecimal distanciaTotal = BigDecimal.ZERO;
        int tiempoTotal = 0;
        int numeroOrden = 1;

        // Primer tramo: Origen -> Primer Dep√≥sito
        Deposito primerDeposito = depositos.get(0);
        OsrmClient.RouteResponse tramo1 = osrmClient.calcularRuta(
                origenLat, origenLon,
                primerDeposito.getLatitud(), primerDeposito.getLongitud());

        Tramo primerTramo = Tramo.builder()
                .numeroOrden(numeroOrden++)
                .tipoTramo(Tramo.TipoTramo.ORIGEN_DEPOSITO)
                .origenTipo("ORIGEN")
                .origenDireccion(direccionOrigen)
                .origenLatitud(origenLat)
                .origenLongitud(origenLon)
                .destinoTipo("DEPOSITO")
                .destinoDireccion(primerDeposito.getDireccion())
                .destinoLatitud(primerDeposito.getLatitud())
                .destinoLongitud(primerDeposito.getLongitud())
                .destinoDepositoId(primerDeposito.getId())
                .distanciaKm(tramo1.getDistanciaKm())
                .estado(Tramo.EstadoTramo.ESTIMADO)
                .build();

        tramos.add(primerTramo);
        distanciaTotal = distanciaTotal.add(tramo1.getDistanciaKm());
        tiempoTotal += tramo1.getDuracionHoras();

        // Tramos entre dep√≥sitos (si hay m√°s de 1 dep√≥sito)
        for (int i = 0; i < depositos.size() - 1; i++) {
            Deposito depositoOrigen = depositos.get(i);
            Deposito depositoDestino = depositos.get(i + 1);

            OsrmClient.RouteResponse tramoEntreDepositos = osrmClient.calcularRuta(
                    depositoOrigen.getLatitud(), depositoOrigen.getLongitud(),
                    depositoDestino.getLatitud(), depositoDestino.getLongitud());

            Tramo tramoIntermedio = Tramo.builder()
                    .numeroOrden(numeroOrden++)
                    .tipoTramo(Tramo.TipoTramo.DEPOSITO_DEPOSITO)
                    .origenTipo("DEPOSITO")
                    .origenDireccion(depositoOrigen.getDireccion())
                    .origenLatitud(depositoOrigen.getLatitud())
                    .origenLongitud(depositoOrigen.getLongitud())
                    .origenDepositoId(depositoOrigen.getId())
                    .destinoTipo("DEPOSITO")
                    .destinoDireccion(depositoDestino.getDireccion())
                    .destinoLatitud(depositoDestino.getLatitud())
                    .destinoLongitud(depositoDestino.getLongitud())
                    .destinoDepositoId(depositoDestino.getId())
                    .distanciaKm(tramoEntreDepositos.getDistanciaKm())
                    .estado(Tramo.EstadoTramo.ESTIMADO)
                    .build();

            tramos.add(tramoIntermedio);
            distanciaTotal = distanciaTotal.add(tramoEntreDepositos.getDistanciaKm());
            tiempoTotal += tramoEntreDepositos.getDuracionHoras();
        }

        // √öltimo tramo: √öltimo Dep√≥sito -> Destino
        Deposito ultimoDeposito = depositos.get(depositos.size() - 1);
        OsrmClient.RouteResponse tramoFinal = osrmClient.calcularRuta(
                ultimoDeposito.getLatitud(), ultimoDeposito.getLongitud(),
                destinoLat, destinoLon);

        Tramo ultimoTramo = Tramo.builder()
                .numeroOrden(numeroOrden)
                .tipoTramo(Tramo.TipoTramo.DEPOSITO_DESTINO)
                .origenTipo("DEPOSITO")
                .origenDireccion(ultimoDeposito.getDireccion())
                .origenLatitud(ultimoDeposito.getLatitud())
                .origenLongitud(ultimoDeposito.getLongitud())
                .origenDepositoId(ultimoDeposito.getId())
                .destinoTipo("DESTINO")
                .destinoDireccion(direccionDestino)
                .destinoLatitud(destinoLat)
                .destinoLongitud(destinoLon)
                .distanciaKm(tramoFinal.getDistanciaKm())
                .estado(Tramo.EstadoTramo.ESTIMADO)
                .build();

        tramos.add(ultimoTramo);
        distanciaTotal = distanciaTotal.add(tramoFinal.getDistanciaKm());
        tiempoTotal += tramoFinal.getDuracionHoras();

        Ruta ruta = Ruta.builder()
                .solicitudId(solicitudId)
                .tipo(Ruta.TipoRuta.PROPUESTA)
                .cantidadTramos(tramos.size())
                .cantidadDepositos(depositos.size())
                .distanciaTotalKm(distanciaTotal)
                .tiempoEstimadoTotalHoras(tiempoTotal)
                .tramos(new ArrayList<>())
                .build();

        tramos.forEach(t -> {
            t.setRuta(ruta);
            ruta.getTramos().add(t);
        });

        return ruta;
    }

    private List<Deposito> seleccionarDepositosParaRuta(BigDecimal latOrigen, BigDecimal lonOrigen,
                                                         BigDecimal latDestino, BigDecimal lonDestino,
                                                         int cantidadDepositos) {
        List<Deposito> depositosActivos = depositoRepository.findByActivoTrue();

        if (depositosActivos.isEmpty() || cantidadDepositos == 0) {
            return Collections.emptyList();
        }

        if (cantidadDepositos == 1) {
            // Punto medio entre origen y destino
            BigDecimal latMedio = latOrigen.add(latDestino).divide(BigDecimal.valueOf(2), 8, RoundingMode.HALF_UP);
            BigDecimal lonMedio = lonOrigen.add(lonDestino).divide(BigDecimal.valueOf(2), 8, RoundingMode.HALF_UP);

            return depositosActivos.stream()
                    .min(Comparator.comparingDouble(d ->
                            calcularDistanciaHaversine(latMedio, lonMedio, d.getLatitud(), d.getLongitud())))
                    .map(List::of)
                    .orElse(Collections.emptyList());
        }

        if (cantidadDepositos == 2) {
            // Dividir el trayecto en 3 partes iguales
            BigDecimal lat1 = latOrigen.add(latDestino.subtract(latOrigen).multiply(BigDecimal.valueOf(0.33)));
            BigDecimal lon1 = lonOrigen.add(lonDestino.subtract(lonOrigen).multiply(BigDecimal.valueOf(0.33)));

            BigDecimal lat2 = latOrigen.add(latDestino.subtract(latOrigen).multiply(BigDecimal.valueOf(0.66)));
            BigDecimal lon2 = lonOrigen.add(lonDestino.subtract(lonOrigen).multiply(BigDecimal.valueOf(0.66)));

            Deposito deposito1 = depositosActivos.stream()
                    .min(Comparator.comparingDouble(d ->
                            calcularDistanciaHaversine(lat1, lon1, d.getLatitud(), d.getLongitud())))
                    .orElse(null);

            if (deposito1 == null) {
                return Collections.emptyList();
            }

            List<Deposito> depositosRestantes = depositosActivos.stream()
                    .filter(d -> !d.equals(deposito1))
                    .toList();

            Deposito deposito2 = depositosRestantes.stream()
                    .min(Comparator.comparingDouble(d ->
                            calcularDistanciaHaversine(lat2, lon2, d.getLatitud(), d.getLongitud())))
                    .orElse(null);

            if (deposito2 != null) {
                return List.of(deposito1, deposito2);
            }
        }

        return Collections.emptyList();
    }

    private double calcularDistanciaHaversine(BigDecimal lat1, BigDecimal lon1, BigDecimal lat2, BigDecimal lon2) {
        final double R = 6371.0; // Radio de la Tierra en kil√≥metros

        double lat1Rad = Math.toRadians(lat1.doubleValue());
        double lat2Rad = Math.toRadians(lat2.doubleValue());
        double deltaLatRad = Math.toRadians(lat2.subtract(lat1).doubleValue());
        double deltaLonRad = Math.toRadians(lon2.subtract(lon1).doubleValue());

        double a = Math.sin(deltaLatRad / 2) * Math.sin(deltaLatRad / 2) +
                   Math.cos(lat1Rad) * Math.cos(lat2Rad) *
                   Math.sin(deltaLonRad / 2) * Math.sin(deltaLonRad / 2);

        double c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));

        return R * c;
    }

    @Transactional
    public RutaDTO asignarRuta(Long solicitudId, Integer indiceRuta) {
        log.info("Asignando ruta con √≠ndice {} a solicitud {}", indiceRuta, solicitudId);

        // Desmarcar otras rutas de la misma solicitud (si existen)
        List<Ruta> rutasExistentes = rutaRepository.findBySolicitudId(solicitudId);
        rutasExistentes.forEach(r -> {
            r.setSeleccionada(false);
            r.setTipo(Ruta.TipoRuta.PROPUESTA);
        });

        // Obtener datos de la solicitud para regenerar la ruta seleccionada
        ClientsClient.SolicitudResponse solicitud = clientsClient.obtenerSolicitud(solicitudId);

        String direccionOrigen = solicitud.origen().direccion();
        BigDecimal latOrigen = solicitud.origen().latitud();
        BigDecimal lonOrigen = solicitud.origen().longitud();

        String direccionDestino = solicitud.destino().direccion();
        BigDecimal latDestino = solicitud.destino().latitud();
        BigDecimal lonDestino = solicitud.destino().longitud();

        BigDecimal peso = solicitud.contenedor().pesoKg();
        BigDecimal volumen = solicitud.contenedor().volumenM3();

        // Regenerar la ruta seg√∫n el √≠ndice seleccionado
        Ruta rutaSeleccionada;
        String descripcionRuta;

        switch (indiceRuta) {
            case 0: // Ruta directa
                rutaSeleccionada = crearRutaDirecta(solicitudId, latOrigen, lonOrigen,
                        latDestino, lonDestino, direccionOrigen, direccionDestino);
                descripcionRuta = "Ruta directa sin dep√≥sitos";
                break;

            case 1: // Ruta con 1 dep√≥sito
                List<Deposito> depositos1 = seleccionarDepositosParaRuta(latOrigen, lonOrigen,
                        latDestino, lonDestino, 1);
                if (depositos1.isEmpty()) {
                    throw new RuntimeException("No se pudieron seleccionar dep√≥sitos para esta ruta");
                }
                rutaSeleccionada = crearRutaConDepositos(solicitudId, latOrigen, lonOrigen,
                        latDestino, lonDestino, direccionOrigen, direccionDestino, depositos1);
                descripcionRuta = "Ruta con 1 dep√≥sito intermedio";
                break;

            case 2: // Ruta con 2 dep√≥sitos
                List<Deposito> depositos2 = seleccionarDepositosParaRuta(latOrigen, lonOrigen,
                        latDestino, lonDestino, 2);
                if (depositos2.size() < 2) {
                    throw new RuntimeException("No se pudieron seleccionar 2 dep√≥sitos para esta ruta");
                }
                rutaSeleccionada = crearRutaConDepositos(solicitudId, latOrigen, lonOrigen,
                        latDestino, lonDestino, direccionOrigen, direccionDestino, depositos2);
                descripcionRuta = "Ruta con 2 dep√≥sitos intermedios";
                break;

            default:
                throw new RuntimeException("√çndice de ruta inv√°lido: " + indiceRuta);
        }

        // Asignar √≠ndice y descripci√≥n
        rutaSeleccionada.setIndice(indiceRuta);
        rutaSeleccionada.setDescripcion(descripcionRuta);

        // Marcar como seleccionada y asignada
        rutaSeleccionada.setSeleccionada(true);
        rutaSeleccionada.setTipo(Ruta.TipoRuta.ASIGNADA);

        // AHORA S√ç guardamos la ruta en BD
        Ruta rutaGuardada = rutaRepository.save(rutaSeleccionada);
        log.info("Ruta {} guardada y asignada a solicitud {}", rutaGuardada.getId(), solicitudId);

        // Refrescar desde BD para obtener los IDs de los tramos generados
        rutaGuardada = rutaRepository.findById(rutaGuardada.getId())
                .orElseThrow(() -> new RuntimeException("No se pudo recuperar la ruta guardada"));

        log.info("Ruta refrescada - ID: {}, Cantidad de tramos: {}", rutaGuardada.getId(), rutaGuardada.getTramos().size());
        rutaGuardada.getTramos().forEach(tramo ->
            log.info("Tramo - ID: {}, NumeroOrden: {}", tramo.getId(), tramo.getNumeroOrden())
        );

        // Calcular costo estimado (DESPU√âS de guardar para que los tramos tengan IDs)
        calcularYAsignarCostoEstimado(rutaGuardada, peso, volumen);
        rutaGuardada = rutaRepository.save(rutaGuardada); // Guardar nuevamente con el costo

        // Actualizar estado de la solicitud a PROGRAMADA
        try {
            ClientsClient.ActualizarEstadoRequest estadoRequest =
                    new ClientsClient.ActualizarEstadoRequest("PROGRAMADA", "Ruta asignada y programada para transporte");

            clientsClient.actualizarEstado(solicitudId, estadoRequest);
            log.info("Solicitud {} actualizada a estado PROGRAMADA", solicitudId);
        } catch (Exception e) {
            log.error("Error al actualizar estado de solicitud a PROGRAMADA: {}", e.getMessage(), e);
        }

        // Retornar la ruta guardada con los IDs de los tramos
        return convertirARutaDTO(rutaGuardada);
    }

    private RutaDTO convertirARutaDTO(Ruta ruta) {
        List<TramoDTO> tramosDTO = ruta.getTramos().stream()
                .map(tramo -> TramoDTO.builder()
                        .id(tramo.getId())
                        .numeroOrden(tramo.getNumeroOrden())
                        .tipoTramo(tramo.getTipoTramo())
                        .origenDireccion(tramo.getOrigenDireccion())
                        .destinoDireccion(tramo.getDestinoDireccion())
                        .distanciaKm(tramo.getDistanciaKm())
                        .estado(tramo.getEstado())
                        .camionId(tramo.getCamion() != null ? tramo.getCamion().getId() : null)
                        .camionDominio(tramo.getCamion() != null ? tramo.getCamion().getDominio() : null)
                        .fechaHoraInicioEstimada(tramo.getFechaHoraInicioEstimada())
                        .fechaHoraFinEstimada(tramo.getFechaHoraFinEstimada())
                        .fechaHoraInicioReal(tramo.getFechaHoraInicioReal())
                        .fechaHoraFinReal(tramo.getFechaHoraFinReal())
                        .costoEstimado(tramo.getCostoEstimado())
                        .costoReal(tramo.getCostoReal())
                        .build())
                .collect(Collectors.toList());

        return RutaDTO.builder()
                .id(ruta.getId())
                .solicitudId(ruta.getSolicitudId())
                .tipo(ruta.getTipo().name())
                .indice(ruta.getIndice())
                .descripcion(ruta.getDescripcion())
                .cantidadTramos(ruta.getCantidadTramos())
                .cantidadDepositos(ruta.getCantidadDepositos())
                .distanciaTotalKm(ruta.getDistanciaTotalKm())
                .tiempoEstimadoTotalHoras(ruta.getTiempoEstimadoTotalHoras())
                .costoEstimadoTotal(ruta.getCostoEstimadoTotal())
                .seleccionada(ruta.getSeleccionada())
                .tramos(tramosDTO)
                .build();
    }

    private void calcularYAsignarCostoEstimado(Ruta ruta, BigDecimal pesoKg, BigDecimal volumenM3) {
        try {
            // Obtener un cami√≥n disponible para obtener costos base
            Camion camion = camionRepository.findAll().stream()
                    .filter(c -> c.getActivo() && c.getEstado() == Camion.EstadoCamion.DISPONIBLE)
                    .findFirst()
                    .orElse(null);

            if (camion == null) {
                log.warn("No hay camiones disponibles para calcular costo estimado");
                return;
            }

            // Construir request para BillingClient
            List<BillingClient.TramoRequest> tramosRequest = ruta.getTramos().stream()
                    .map(tramo -> new BillingClient.TramoRequest(
                            tramo.getId(),
                            tramo.getDistanciaKm(),
                            camion.getCostoBasePorKm(),
                            camion.getConsumoCombustibleKmLitro()
                    ))
                    .collect(Collectors.toList());

            // Estimar d√≠as de estad√≠a (1 d√≠a por cada dep√≥sito)
            Integer diasEstadia = ruta.getCantidadDepositos();

            BillingClient.CalcularCostoRequest request = new BillingClient.CalcularCostoRequest(
                    ruta.getSolicitudId(),
                    tramosRequest,
                    pesoKg,
                    volumenM3,
                    diasEstadia,
                    null, // horasEstadiaTotales para c√°lculo estimado
                    null  // costosAdicionales para c√°lculo estimado
            );

            // Llamar a billing-service
            BillingClient.CostoEstimadoResponse costoResponse = billingClient.calcularCostoEstimado(request);

            // Asignar costo estimado a la ruta
            ruta.setCostoEstimadoTotal(costoResponse.costoTotal());

            log.info("Costo estimado calculado para ruta {}: {}", ruta.getId(), costoResponse.costoTotal());
        } catch (Exception e) {
            log.error("Error al calcular costo estimado para ruta {}: {}", ruta.getId(), e.getMessage());
        }
    }
}



==================================================
RUTH: logistics-service/src/main/java/com/transportes/logistics/service/TramoService.java
==================================================
package com.transportes.logistics.service;

import com.transportes.logistics.client.BillingClient;
import com.transportes.logistics.client.ClientsClient;
import com.transportes.logistics.dto.TramoDTO;
import com.transportes.logistics.entity.Camion;
import com.transportes.logistics.entity.Ruta;
import com.transportes.logistics.entity.Tramo;
import com.transportes.logistics.repository.CamionRepository;
import com.transportes.logistics.repository.RutaRepository;
import com.transportes.logistics.repository.TramoRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.List;
import java.util.stream.Collectors;

@Slf4j
@Service
@RequiredArgsConstructor
public class TramoService {

    private final TramoRepository tramoRepository;
    private final CamionRepository camionRepository;
    private final RutaRepository rutaRepository;
    private final ClientsClient clientsClient;
    private final BillingClient billingClient;

    @Transactional(readOnly = true)
    public List<TramoDTO> obtenerTramosAsignadosATransportista(String keycloakUserId) {
        List<Tramo> tramos = tramoRepository.findTramosAsignadosPorTransportista(keycloakUserId);

        return tramos.stream()
                .map(this::convertirATramoDTO)
                .collect(Collectors.toList());
    }

    @Transactional
    public TramoDTO iniciarTramo(Long tramoId, String keycloakUserId) {
        Tramo tramo = tramoRepository.findById(tramoId)
                .orElseThrow(() -> new RuntimeException("Tramo no encontrado"));

        // Validar que el tramo est√© asignado
        if (tramo.getEstado() != Tramo.EstadoTramo.ASIGNADO) {
            throw new RuntimeException("El tramo no est√° en estado ASIGNADO");
        }

        // Validar que el transportista sea el asignado
        if (tramo.getCamion() == null || tramo.getCamion().getTransportista() == null ||
            !tramo.getCamion().getTransportista().getKeycloakUserId().equals(keycloakUserId)) {
            throw new RuntimeException("No tiene permisos para iniciar este tramo");
        }

        // Marcar inicio
        tramo.setEstado(Tramo.EstadoTramo.INICIADO);
        tramo.setFechaHoraInicioReal(LocalDateTime.now());

        Tramo tramoActualizado = tramoRepository.save(tramo);
        log.info("Tramo {} iniciado por transportista", tramoId);

        // Verificar si es el primer tramo de la ruta y actualizar estado de solicitud
        verificarYActualizarEstadoEnTransito(tramoActualizado);

        return convertirATramoDTO(tramoActualizado);
    }

    @Transactional
    public TramoDTO finalizarTramo(Long tramoId, String keycloakUserId) {
        Tramo tramo = tramoRepository.findById(tramoId)
                .orElseThrow(() -> new RuntimeException("Tramo no encontrado"));

        // Validar que el tramo est√© iniciado
        if (tramo.getEstado() != Tramo.EstadoTramo.INICIADO) {
            throw new RuntimeException("El tramo no est√° en estado INICIADO");
        }

        // Validar que el transportista sea el asignado
        if (tramo.getCamion() == null || tramo.getCamion().getTransportista() == null ||
            !tramo.getCamion().getTransportista().getKeycloakUserId().equals(keycloakUserId)) {
            throw new RuntimeException("No tiene permisos para finalizar este tramo");
        }

        // Marcar fin
        tramo.setEstado(Tramo.EstadoTramo.FINALIZADO);
        tramo.setFechaHoraFinReal(LocalDateTime.now());

        // Liberar cami√≥n si no hay m√°s tramos pendientes
        Camion camion = tramo.getCamion();
        List<Tramo> tramosRestantes = tramoRepository.findByCamionId(camion.getId()).stream()
                .filter(t -> t.getEstado() == Tramo.EstadoTramo.ASIGNADO || t.getEstado() == Tramo.EstadoTramo.INICIADO)
                .collect(Collectors.toList());

        if (tramosRestantes.isEmpty()) {
            camion.setEstado(Camion.EstadoCamion.DISPONIBLE);
            camionRepository.save(camion);
            log.info("Cami√≥n {} liberado", camion.getId());
        }

        Tramo tramoActualizado = tramoRepository.save(tramo);
        log.info("Tramo {} finalizado por transportista", tramoId);

        // Verificar si es el √∫ltimo tramo de la ruta
        verificarYFinalizarRuta(tramoActualizado);

        return convertirATramoDTO(tramoActualizado);
    }

    @Transactional(readOnly = true)
    public TramoDTO obtenerTramo(Long tramoId) {
        Tramo tramo = tramoRepository.findById(tramoId)
                .orElseThrow(() -> new RuntimeException("Tramo no encontrado"));
        return convertirATramoDTO(tramo);
    }

    private TramoDTO convertirATramoDTO(Tramo tramo) {
        return TramoDTO.builder()
                .id(tramo.getId())
                .numeroOrden(tramo.getNumeroOrden())
                .tipoTramo(tramo.getTipoTramo())
                .origenDireccion(tramo.getOrigenDireccion())
                .destinoDireccion(tramo.getDestinoDireccion())
                .distanciaKm(tramo.getDistanciaKm())
                .estado(tramo.getEstado())
                .camionId(tramo.getCamion() != null ? tramo.getCamion().getId() : null)
                .camionDominio(tramo.getCamion() != null ? tramo.getCamion().getDominio() : null)
                .fechaHoraInicioEstimada(tramo.getFechaHoraInicioEstimada())
                .fechaHoraFinEstimada(tramo.getFechaHoraFinEstimada())
                .fechaHoraInicioReal(tramo.getFechaHoraInicioReal())
                .fechaHoraFinReal(tramo.getFechaHoraFinReal())
                .costoEstimado(tramo.getCostoEstimado())
                .costoReal(tramo.getCostoReal())
                .build();
    }

    private void verificarYActualizarEstadoEnTransito(Tramo tramoIniciado) {
        try {
            Ruta ruta = tramoIniciado.getRuta();

            // Verificar si es el primer tramo en iniciarse (numeroOrden = 1)
            if (tramoIniciado.getNumeroOrden() == 1) {
                log.info("Primer tramo de la ruta {} iniciado. Actualizando solicitud a EN_TRANSITO...", ruta.getId());

                // Actualizar estado de la solicitud a EN_TRANSITO
                ClientsClient.ActualizarEstadoRequest estadoRequest =
                        new ClientsClient.ActualizarEstadoRequest("EN_TRANSITO", "Transporte iniciado");

                clientsClient.actualizarEstado(ruta.getSolicitudId(), estadoRequest);

                log.info("Solicitud {} actualizada a estado EN_TRANSITO", ruta.getSolicitudId());
            }
        } catch (Exception e) {
            log.error("Error al actualizar estado de solicitud a EN_TRANSITO: {}", e.getMessage(), e);
        }
    }

    private void verificarYFinalizarRuta(Tramo tramoFinalizado) {
        try {
            Ruta ruta = tramoFinalizado.getRuta();

            // Verificar si todos los tramos de la ruta est√°n finalizados
            boolean todosFinalizados = ruta.getTramos().stream()
                    .allMatch(t -> t.getEstado() == Tramo.EstadoTramo.FINALIZADO);

            if (todosFinalizados) {
                log.info("Todos los tramos de la ruta {} finalizados. Procesando finalizaci√≥n...", ruta.getId());

                // Obtener datos de la solicitud
                ClientsClient.SolicitudResponse solicitud = clientsClient.obtenerSolicitud(ruta.getSolicitudId());

                // Calcular costo real
                List<BillingClient.TramoRequest> tramosRequest = ruta.getTramos().stream()
                        .map(tramo -> {
                            Camion camion = tramo.getCamion();
                            return new BillingClient.TramoRequest(
                                    tramo.getId(),
                                    tramo.getDistanciaKm(),
                                    camion.getCostoBasePorKm(),
                                    camion.getConsumoCombustibleKmLitro()
                            );
                        })
                        .collect(Collectors.toList());

                BillingClient.CalcularCostoRequest costoRequest = new BillingClient.CalcularCostoRequest(
                        ruta.getSolicitudId(),
                        tramosRequest,
                        solicitud.contenedor().pesoKg(),
                        solicitud.contenedor().volumenM3(),
                        ruta.getCantidadDepositos(), // d√≠as de estad√≠a
                        null, // horasEstadiaTotales - se calcular√° en base a fechas reales
                        null  // costosAdicionales
                );

                BillingClient.CostoEstimadoResponse costoReal = billingClient.calcularCostoReal(costoRequest);

                // Actualizar costo real en la ruta
                ruta.setCostoRealTotal(costoReal.costoTotal());
                rutaRepository.save(ruta);

                log.info("Costo real calculado para ruta {}: {}", ruta.getId(), costoReal.costoTotal());

                // Actualizar estado de la solicitud a ENTREGADA
                ClientsClient.ActualizarEstadoRequest estadoRequest =
                        new ClientsClient.ActualizarEstadoRequest("ENTREGADA", "Entrega completada exitosamente");

                clientsClient.actualizarEstado(ruta.getSolicitudId(), estadoRequest);

                log.info("Solicitud {} actualizada a estado ENTREGADA", ruta.getSolicitudId());
            }
        } catch (Exception e) {
            log.error("Error al verificar y finalizar ruta: {}", e.getMessage(), e);
        }
    }
}



==================================================
RUTH: logistics-service/src/main/java/com/transportes/logistics/service/TransportistaService.java
==================================================
package com.transportes.logistics.service;

import com.transportes.logistics.dto.TransportistaDTO;
import com.transportes.logistics.entity.Transportista;
import com.transportes.logistics.repository.TransportistaRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

@Slf4j
@Service
@RequiredArgsConstructor
public class TransportistaService {

    private final TransportistaRepository transportistaRepository;
    private final KeycloakService keycloakService;

    @Transactional
    public TransportistaDTO crear(TransportistaDTO dto) {
        if (transportistaRepository.findByDni(dto.getDni()).isPresent()) {
            throw new RuntimeException("Ya existe un transportista con ese DNI");
        }

        if (dto.getEmail() == null || dto.getPassword() == null) {
            throw new RuntimeException("Email y contrase√±a son obligatorios");
        }

        // Crear usuario en Keycloak
        String keycloakId = keycloakService.crearUsuarioTransportista(
                dto.getEmail(),
                dto.getPassword(),
                dto.getNombre(),
                dto.getApellido()
        );

        Transportista entity = Transportista.builder()
                .nombre(dto.getNombre())
                .apellido(dto.getApellido())
                .dni(dto.getDni())
                .telefono(dto.getTelefono())
                .email(dto.getEmail())
                .licenciaConducir(dto.getLicenciaConducir())
                .keycloakUserId(keycloakId)
                .activo(dto.getActivo() != null ? dto.getActivo() : true)
                .build();

        Transportista guardado = transportistaRepository.save(entity);
        log.info("Transportista creado exitosamente con ID: {} y Keycloak ID: {}", guardado.getId(), keycloakId);

        return convertirADTO(guardado);
    }

    private TransportistaDTO convertirADTO(Transportista entity) {
        return TransportistaDTO.builder()
                .id(entity.getId())
                .nombre(entity.getNombre())
                .apellido(entity.getApellido())
                .dni(entity.getDni())
                .telefono(entity.getTelefono())
                .email(entity.getEmail())
                .licenciaConducir(entity.getLicenciaConducir())
                .keycloakUserId(entity.getKeycloakUserId())
                .activo(entity.getActivo())
                .build();
    }
}



==================================================
RUTH: logistics-service/src/main/resources/application-docker.yml
==================================================
spring:
  datasource:
    url: jdbc:postgresql://postgres-logistics:5432/logistics_db
    username: logistics_user
    password: logistics_pass

  security:
    oauth2:
      resourceserver:
        jwt:
          jwk-set-uri: http://keycloak:8080/realms/transportes-realm/protocol/openid-connect/certs

keycloak:
  auth-server-url: http://keycloak:8080
  realm: transportes-realm
  admin:
    username: admin
    password: admin
    client-id: admin-cli

osrm:
  service:
    url: http://osrm:5000

clients:
  service:
    url: http://clients-service:8081

billing:
  service:
    url: http://billing-service:8083



==================================================
RUTH: logistics-service/src/main/resources/application.yml
==================================================
spring:
  application:
    name: logistics-service
  
  datasource:
    url: jdbc:postgresql://localhost:5433/logistics_db
    username: logistics_user
    password: logistics_pass
    driver-class-name: org.postgresql.Driver
  
  jpa:
    hibernate:
      ddl-auto: validate
    show-sql: true
    properties:
      hibernate:
        format_sql: true
        dialect: org.hibernate.dialect.PostgreSQLDialect
  
  security:
    oauth2:
      resourceserver:
        jwt:
          jwk-set-uri: http://localhost:8180/realms/transportes-realm/protocol/openid-connect/certs

server:
  port: 8082

keycloak:
  auth-server-url: http://localhost:8180
  realm: transportes-realm
  admin:
    username: admin
    password: admin
    client-id: admin-cli

osrm:
  service:
    url: http://localhost:5000

management:
  endpoints:
    web:
      exposure:
        include: health,info,metrics
  endpoint:
    health:
      show-details: always

springdoc:
  api-docs:
    path: /v3/api-docs
  swagger-ui:
    path: /swagger-ui.html

logging:
  level:
    com.transportes.logistics: DEBUG

clients:
  service:
    url: http://localhost:8081

billing:
  service:
    url: http://localhost:8083



==================================================
RUTH: logistics-service/src/main/resources/db/migration/add_costo_real_total_to_ruta.sql
==================================================
-- Agregar columna costo_real_total a la tabla ruta
-- Este script debe ejecutarse manualmente en la base de datos logistics_db

ALTER TABLE ruta
ADD COLUMN IF NOT EXISTS costo_real_total DECIMAL(12, 2);

COMMENT ON COLUMN ruta.costo_real_total IS 'Costo real total de la ruta calculado despu√©s de la entrega';



==================================================
RUTH: pom.xml
==================================================
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 
         http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>com.transportes</groupId>
    <artifactId>tpi-transportes</artifactId>
    <version>1.0.0</version>
    <packaging>pom</packaging>

    <name>TPI Transportes - Sistema de Gesti√≥n de Transporte</name>
    <description>Sistema de backend para gesti√≥n de transporte de contenedores</description>

    <modules>
        <module>clients-service</module>
        <module>logistics-service</module>
        <module>billing-service</module>
        <module>gateway-service</module>
    </modules>

    <properties>
        <java.version>17</java.version>
        <maven.compiler.source>17</maven.compiler.source>
        <maven.compiler.target>17</maven.compiler.target>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
        
        <!-- Spring Boot -->
        <spring-boot.version>3.2.0</spring-boot.version>
        <spring-cloud.version>2023.0.0</spring-cloud.version>
        
        <!-- Dependencies -->
        <lombok.version>1.18.30</lombok.version>
        <mapstruct.version>1.5.5.Final</mapstruct.version>
        <springdoc.version>2.3.0</springdoc.version>
        <postgresql.version>42.7.1</postgresql.version>
        
        <!-- Plugins -->
        <maven-compiler-plugin.version>3.11.0</maven-compiler-plugin.version>
    </properties>

    <dependencyManagement>
        <dependencies>
            <!-- Spring Boot BOM -->
            <dependency>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-dependencies</artifactId>
                <version>${spring-boot.version}</version>
                <type>pom</type>
                <scope>import</scope>
            </dependency>

            <!-- Spring Cloud BOM -->
            <dependency>
                <groupId>org.springframework.cloud</groupId>
                <artifactId>spring-cloud-dependencies</artifactId>
                <version>${spring-cloud.version}</version>
                <type>pom</type>
                <scope>import</scope>
            </dependency>

            <!-- PostgreSQL -->
            <dependency>
                <groupId>org.postgresql</groupId>
                <artifactId>postgresql</artifactId>
                <version>${postgresql.version}</version>
            </dependency>

            <!-- Lombok -->
            <dependency>
                <groupId>org.projectlombok</groupId>
                <artifactId>lombok</artifactId>
                <version>${lombok.version}</version>
            </dependency>

            <!-- MapStruct -->
            <dependency>
                <groupId>org.mapstruct</groupId>
                <artifactId>mapstruct</artifactId>
                <version>${mapstruct.version}</version>
            </dependency>

            <!-- Springdoc OpenAPI -->
            <dependency>
                <groupId>org.springdoc</groupId>
                <artifactId>springdoc-openapi-starter-webmvc-ui</artifactId>
                <version>${springdoc.version}</version>
            </dependency>
        </dependencies>
    </dependencyManagement>

    <build>
        <pluginManagement>
            <plugins>
                <plugin>
                    <groupId>org.springframework.boot</groupId>
                    <artifactId>spring-boot-maven-plugin</artifactId>
                    <version>${spring-boot.version}</version>
                    <configuration>
                        <excludes>
                            <exclude>
                                <groupId>org.projectlombok</groupId>
                                <artifactId>lombok</artifactId>
                            </exclude>
                        </excludes>
                    </configuration>
                </plugin>

                <plugin>
                    <groupId>org.apache.maven.plugins</groupId>
                    <artifactId>maven-compiler-plugin</artifactId>
                    <version>${maven-compiler-plugin.version}</version>
                    <configuration>
                        <source>${java.version}</source>
                        <target>${java.version}</target>
                        <annotationProcessorPaths>
                            <path>
                                <groupId>org.projectlombok</groupId>
                                <artifactId>lombok</artifactId>
                                <version>${lombok.version}</version>
                            </path>
                            <path>
                                <groupId>org.mapstruct</groupId>
                                <artifactId>mapstruct-processor</artifactId>
                                <version>${mapstruct.version}</version>
                            </path>
                        </annotationProcessorPaths>
                    </configuration>
                </plugin>
            </plugins>
        </pluginManagement>
    </build>

</project>



